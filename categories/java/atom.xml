<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-11-21T20:16:04+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tugas Kuliah Pemrograman 1]]></title>
    <link href="http://software.endy.muhardin.com/java/tugas-kuliah-pemrograman-1/"/>
    <updated>2013-11-21T19:54:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/tugas-kuliah-pemrograman-1</id>
    <content type="html"><![CDATA[<p>Pada posting sebelumnya, kita sudah membahas:</p>

<ul>
<li><a href="http://software.endy.muhardin.com/life/otodidak/">bagaimana cara belajar secara otodidak</a></li>
<li><a href="http://software.endy.muhardin.com/life/lan-na-zha/">pentingnya menguasai konsep dasar / fundamental dari segala sesuatu</a></li>
<li>pentingnya latihan <a href="http://software.endy.muhardin.com/life/rtfm/">membaca dokumentasi</a>, <a href="http://software.endy.muhardin.com/life/problem-solving/">menyelesaikan masalah</a>, dan <a href="http://software.endy.muhardin.com/aplikasi/teknik-menggunakan-google/">mencari solusi</a></li>
</ul>


<blockquote><p>Lalu bagaimana kalau kita baru menguasai dasar-dasar Java? Bagaimana latihannya?</p></blockquote>

<p>Nah, sebetulnya cuma masalah kreativitas saja. Banyak aplikasi yang bisa dibuat dengan teknik minimalis. Sebagai contoh, coba simak tugas kuliah yang saya berikan untuk mata kuliah Pemrograman 1 di Universitas Pancasila. Untuk bisa menyelesaikan tugas ini, skill yang dibutuhkan hanyalah:</p>

<ul>
<li>variabel dan tipe data</li>
<li>looping (for,while) dan percabangan (if-else)</li>
<li>menggunakan class <code>java.lang.String</code></li>
<li>baca/tulis file</li>
</ul>


<p>Referensi yang dibutuhkan hanyalah:</p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/index.html">Tutorial resmi dari Oracle</a> atau <a href="http://project-template.googlecode.com/files/Java%20Desktop%20-%20Ifnu%20Bima.pdf">buku Java Desktop karangan Ifnu Bima</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/api/index.html">Dokumentasi API Java (JavaDocs)</a></li>
</ul>


<p>Studi kasus pada tugas ini merupakan aplikasi yang benar-benar digunakan di dunia nyata.</p>

<p>Selamat mencoba.</p>

<!--more-->


<h1>Deskripsi Aplikasi</h1>

<p>Aplikasi ini akan memproses perhitungan take home pay pegawai tiap bulannya. Tidak digunakan antarmuka pengguna (user interface) karena aplikasi bersifat <code>batch</code>, yaitu berjalan otomatis pada waktu yang ditentukan tanpa membutuhkan intervensi manusia. Input aplikasi berupa file text, dan outputnya juga berupa file text.</p>

<p><img src="http://lh5.googleusercontent.com/-zREpwzUHZVs/Uo4B8sUpjdI/AAAAAAAACT4/3HgNUTbbu1s/w909-h314-no/tugas-kuliah.jpg"></p>

<p>Pada pemakaian sebenarnya, data tarif gaji pegawai bisa diambil dari database. Data absensi diambil dari mesin fingerprint. Hasil perhitungan take home pay akan diupload ke bank untuk proses payroll otomatis.</p>

<h1>Proses Bisnis</h1>

<h2>Input dan Output</h2>

<p>Aplikasi menerima input berupa file text sebagai berikut :</p>

<ul>
<li><code>tarif.csv</code> : berisi nomer induk, nama, tarif gaji pokok, tarif denda, tarif lembur, tarif tunjangan transport</li>
<li><code>absen-MM.csv</code> : berisi nomer induk, tanggal, jam datang, jam pulang</li>
</ul>


<p>Dari dua file input tersebut, aplikasi akan mengeluarkan file text sebagai berikut :</p>

<ul>
<li>takehome-MM.csv : berisi nomer induk, nama, gaji pokok, total denda, total lembur, total tunjangan transport, take home pay</li>
</ul>


<p><code>MM</code> adalah 2 digit bulan. Untuk bulan November, berarti <code>MM</code> akan terisi <code>11</code>.</p>

<h2>Aturan Bisnis</h2>

<ol>
<li>Hari kerja normal Senin - Jumat. Sabtu dan Minggu libur.</li>
<li>Jam kerja normal 09:00 - 17:00.</li>
<li>Bila hadir kerja pada hari normal, mendapatkan tunjangan transport harian sesuai tarif.</li>
<li>Bila datang terlambat, dikenakan denda per jam sesuai tarif denda per jam.</li>
<li>Bila pulang lebih cepat, dikenakan denda per jam sesuai tarif denda per jam.</li>
<li>Bila datang lebih cepat, tidak mendapatkan bonus.</li>
<li>Bila pulang lebih lambat dari jam normal, mendapatkan lembur sesuai tarif lembur per jam.</li>
<li>Bila masuk di hari libur, mendapatkan tunjangan transport dan bonus lembur dihitung per jam sesuai tarif.</li>
<li>Diasumsikan tidak ada hari libur di luar Sabtu-Minggu.</li>
<li>Rumus : <code>take home pay = gaji pokok - total denda + total lembur + total tunjangan transport</code></li>
</ol>


<h2>Contoh File</h2>

<h3>tarif.csv</h3>

<p><code>
no,nama,gaji,denda,lembur,transport
1001,Endy,2000,10,15,30
1002,Adi,3000,15,20,50
1003,Jimmy,3500,15,20,50
1004,Doni,3250,10,10,35
</code></p>

<h3>absen-11.csv</h3>

<p><code>
no,tanggal,datang,pulang
1001,2013-11-01,08:55,17:05
1002,2013-11-01,08:57,17:02
1003,2013-11-01,08:55,17:03
1004,2013-11-01,08:55,17:05
1001,2013-11-02,08:58,17:01
1002,2013-11-02,09:01,18:02
1003,2013-11-02,09:15,18:33
1004,2013-11-02,08:54,19:05
</code></p>

<h3>takehome-11.csv</h3>

<p><code>
no,nama,gaji,denda,lembur,transport,takehome
1001,Endy,2000,100,150,600,2650
1002,Adi,3000,200,300,1000,4100
1003,Jimmy,3500,150,200,950,4500
1004,Doni,3250,250,300,550,3850
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symmetric Encryption dengan Java]]></title>
    <link href="http://software.endy.muhardin.com/java/symmetric-encryption-dengan-java/"/>
    <updated>2013-11-21T12:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/symmetric-encryption-dengan-java</id>
    <content type="html"><![CDATA[<p>Beberapa hari terakhir ini, media massa ribut-ribut mengenai telepon si bos yang disadap orang ostrali. Karena ini blog programming, kita tidak akan membahas tentang implikasi politik dari urusan sadap-menyadap tersebut. Kita juga tidak akan membahas kelakuan ABG script-kiddies yang sudah merasa hebat hanya bermodal donlod script dan menjalankannya (di Windows lagi ;p)</p>

<p>Pada artikel ini, kita akan membahas tentang enkripsi dan dekripsi file. Bagaimana konsepnya, apa pilihan-pilihan yang tersedia, dan mana yang sebaiknya digunakan.</p>

<blockquote><p>Warning! Topik tingkat advanced. Minimal harus sudah menguasai <code>java.io</code>.</p></blockquote>

<!--more-->


<p>Enkripsi adalah proses mengacak data sehingga tidak bisa dibaca orang yang tidak berhak. Sebelum lebih jauh, kita bahas dulu beberapa istilah:</p>

<ul>
<li>enkripsi : proses mengacak data sehingga sulit dibaca</li>
<li>dekripsi : proses membalik data yang diacak sehingga bisa dibaca lagi</li>
<li>key : serangkaian angka/huruf yang digunakan untuk proses enkripsi dan dekripsi</li>
<li>plaintext : data yang ingin dienkripsi. Biasanya data rahasia dan penting, kalau tidak buat apa repot2 dienkripsi.</li>
<li>ciphertext : data yang sudah dienkripsi. Cipher text ini secara teori tidak bisa dibaca oleh orang yang tidak punya key.</li>
</ul>


<p>Prosesnya sederhana.</p>

<ul>
<li>Untuk mengenkripsi :</li>
</ul>


<p><code>
plaintext + key =&gt; ciphertext
</code></p>

<ul>
<li>Untuk mendekripsi :</li>
</ul>


<p><code>
ciphertext + key =&gt; plaintext
</code></p>

<h2>Berbagai Jenis Enkripsi</h2>

<p>Sebenarnya cuma ada dua, jadi tidak perlu pusing ;)</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Symmetric-key_algorithm">Symmetric Encryption</a> : key untuk enkripsi <strong>sama</strong> dengan key untuk dekripsi</li>
<li><a href="http://en.wikipedia.org/wiki/Public-key_cryptography">Asymmetric Encryption</a> : key untuk enkripsi <strong>berbeda</strong> dengan key untuk dekripsi</li>
</ul>


<p>Pada prakteknya, kedua jenis enkripsi ini dipakai secara bersamaan. Jadi bukan pilih yang mana, tapi pakai dua-duanya.</p>

<blockquote><p>Kenapa begitu?</p></blockquote>

<p>Dengan asymmetric encryption <a href="http://stackoverflow.com/questions/10007147/getting-a-illegalblocksizeexception-data-must-not-be-longer-than-256-bytes-when">sulit untuk mengenkripsi data yang besar</a> dan juga <a href="http://en.wikipedia.org/wiki/RSA_(algorithm)#Attacks_against_plain_RSA">tidak aman</a>. Oleh karena itu, biasanya asymmetric encryption hanya digunakan untuk mengenkripsi <code>key</code> saja untuk kemudian dikirim ke pihak lain yang berkomunikasi dengan kita. <code>Key</code> inilah yang nantinya akan digunakan untuk mengenkripsi data sebenarnya menggunakan metode symmetric.</p>

<p>Asymmetric encryption akan kita bahas pada kesempatan lain.</p>

<p>Ada dua metode dalam symmetric encryption, yaitu:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a> : mengenkripsi tiap byte data</li>
<li><a href="http://en.wikipedia.org/wiki/Block_cipher">block cipher</a> : membagi data menjadi beberapa blok, kemudian mengenkripsi masing-masing blok.</li>
</ul>


<p>Kali ini kita hanya membahas block cipher saja.</p>

<h2>Cara Kerja Block Cipher</h2>

<p>Pertama, kita bagi dulu data menjadi blok-blok. Satu blok ukurannya berbeda-beda tergantung algoritma yang digunakan. Misalnya, algoritma AES bloknya berisi 128 bit (atau 16 byte) data. Jadi kalau data kita ada 1 KB, maka akan dibagi menjadi 1024 * 16 = 64 blok.</p>

<p>Masing-masing blok lalu dienkripsi secara terpisah, seperti ilustrasi berikut yang <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">diambil dari Wikipedia</a></p>

<p><img src="https://lh3.googleusercontent.com/-4-C-V41PDlM/Uo2LxRnUjOI/AAAAAAAACSw/JzcKfGUMsAQ/w600-h245-no/Ecb_encryption.png"></p>

<p>Ada berbagai metode dalam mengenkripsi blok-blok data ini. Gambar di atas menunjukkan metode Electronic Codebook yang paling sederhana. Banyak metode lain dengan berbagai plus dan minusnya. Kita tidak akan bahas di sini, silahkan lihat penjelasannya <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">di Wikipedia</a> atau <a href="http://stackoverflow.com/a/1220869">di Stack Overflow</a>.</p>

<p>Setelah memahami cara kerjanya, kita buat dulu rekapitulasi komponen apa saja yang kita butuhkan dalam proses enkripsi ini:</p>

<ul>
<li>plaintext yang ingin dienkripsi</li>
<li>key. Untuk symmetric encryption, key ini harus dirahasiakan. Sebab siapapun yang memiliki key akan bisa melakukan dekripsi</li>
<li><a href="http://en.wikipedia.org/wiki/Initialization_vector">initialization vector</a> : random input supaya hasil enkripsi terlihat berbeda walaupun plain text dan key sama. Initialization vector tidak harus dirahasiakan. Kita bisa kirim IV bersama dengan ciphertext. Walaupun demikian, IV ini harus unik dan sulit ditebak (random). Mengapa? Silahkan baca diskusinya <a href="http://stackoverflow.com/questions/3008139/why-is-using-a-non-random-iv-with-cbc-mode-a-vulnerability">di Stack Overflow</a></li>
<li>algoritma</li>
<li>block cipher mode : metode untuk menggabungkan blok data yang dienkripsi. Block encryption bekerja dengan cara memotong data seukuran blok yang dia mau. Kemudian masing-masing blok dienkripsi. Hasil akhirnya digabungkan menjadi satu lagi. Metode potong-enkripsi-gabung ini <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">memiliki beberapa implementasi berbeda dengan konsekuensi berbeda pula</a>.</li>
<li>padding : Karena ukuran data yang akan dienkripsi bervariasi, kemungkinan besar blok paling akhir tidak terisi penuh. Padahal block encryption mengharuskan semua bloknya terisi. Untuk itu kita harus <em>menambal</em> data jika tidak pas memenuhi ukuran blok. Metode manapun yang dipilih <a href="http://crypto.stackexchange.com/a/1488">tidak berpengaruh terhadap security</a>. Jadi pilih mana saja yang bisa dipakai.</li>
</ul>


<h2>Memilih Algoritma</h2>

<p>Ada beberapa pilihan algoritma untuk melakukan enkripsi, diantaranya:</p>

<ul>
<li>DES</li>
<li>Triple Des / 3DES</li>
<li>AES</li>
<li>Blowfish</li>
<li>dsb</li>
</ul>


<p>Masing-masing memiliki plus-minus, untuk menyingkat pembahasan, kita akan menggunakan AES saja. Perbandingan dan alasan pemilihan AES bisa dibaca <a href="http://www.javamex.com/tutorials/cryptography/ciphers.shtml">di artikel ini</a>.</p>

<p>Selain AES, 3DES juga banyak digunakan di industri perbankan untuk mengamankan transaksi ATM, EDC, dan berbagai bentuk transaksi elektronik lainnya. Algoritma manapun yang digunakan tidak masalah, langkah-langkah dan prinsipnya tetap sama. Untuk mengubah dari algoritma satu ke yang lain cuma perlu mengubah satu baris kode program saja.</p>

<p>Pilihan algoritma yang didukung oleh Java bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher">di daftar ini</a>.</p>

<h2>Generate Key</h2>

<p>Sebelum membuat key, kita harus menentukan dulu panjang keynya.</p>

<blockquote><p>Berapa panjang key yang ideal?</p></blockquote>

<p>Menurut NSA, 256 bit. <a href="https://twitter.com/SteveBellovin/status/311545287313330176">Katanya supaya kebal dari serangan quantum computer</a>. Nah, sudah jelas bahwa saya tidak lebih pintar daripada NSA, yang mengajari orang ostrali bagaimana cara menyadap bos kita. Jadi ya kita terima saja sarannya untuk menggunakan 256 bit. Toh ngetik 128 dan 256 sama-sama efisien dari sisi jumlah tombol yang ditekan ;)</p>

<p>Dengan menggunakan 256 bit, kita akan mendapatkan <a href="http://blog.agilebits.com/2013/03/09/guess-why-were-moving-to-256-bit-aes-keys/">keuntungan tambahan</a> jika nantinya kita menggunakan <a href="http://blog.agilebits.com/2013/01/18/authenticated-encryption-and-how-not-to-get-caught-chasing-a-coyote/">message authentication</a> dan <a href="http://blog.agilebits.com/2011/05/05/defending-against-crackers-peanut-butter-keeps-dogs-friendly-too/">password derivation</a>.</p>

<p>Berdasarkan cara membuatnya, kita bedakan menjadi dua macam key:</p>

<ul>
<li>key yang dibuat secara random</li>
<li>key yang ditentukan user (password)</li>
</ul>


<p>Random key biasanya digunakan tanpa user input. Misalnya aplikasi A ingin mengirim data ke aplikasi B. Supaya aman, data ini ingin dienkripsi. Supaya lebih aman, key yang digunakan untuk enkripsi diganti secara periodik, supaya tidak bisa ditebak oleh penyadap. Nah tentunya akan sangat merepotkan kalau key ini harus diinput user tiap kali dia harus diganti. Untuk keperluan ini, kita gunakan random key. Karena tidak perlu dihafalkan manusia, maka key ini bentuknya bebas saja.</p>

<p>Berbeda halnya dengan key yang ditentukan user. Karena key ini harus dihafalkan user, maka biasanya user mencari rangkaian huruf/angka yang mudah dia hafalkan. Untuk itu, perlu ada tindakan tambahan supaya lebih aman. Tindakan tambahan ini disebut dengan istilah <a href="http://en.wikipedia.org/wiki/Key_stretching">key stretching</a>.</p>

<p>Cara kerja key stretching intinya adalah <a href="http://en.wikipedia.org/wiki/Key_derivation_function">key derivation</a>, yaitu mengkonversi key asli menjadi key turunan. Key turunan inilah yang sebenarnya digunakan untuk melakukan enkripsi, bukan key asli. Proses key derivation dirancang sedemikian rupa untuk menghindari <a href="http://en.wikipedia.org/wiki/Weak_key">kelemahan</a> yang biasa ditemukan di password biasa, misalnya:</p>

<ul>
<li>jumlah karakternya kurang</li>
<li>variasi angka/huruf/karakter kurang banyak</li>
<li>biasanya menggunakan kata-kata yang ada di kamus, sehingga mudah ditebak</li>
<li>urutan karakter tidak random (misalnya abcd4321, cobacoba1234)</li>
</ul>


<p>Melalui proses <em>key stretching</em> password yang biasanya tidak memenuhi syarat kriptografi dikonversi sehingga memenuhi syarat. Algoritma yang biasa digunakan antara lain:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bcrypt">Bcrypt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Scrypt">Scrypt</a></li>
</ul>


<p>Kita hanya akan bahas PBKDF2 saja karena:</p>

<ul>
<li>populer</li>
<li>tersedia di Java tanpa perlu donlod paket tambahan</li>
<li>kebutuhan resource tidak terlalu besar, sehingga tersedia di berbagai platform (misalnya smartphone dan tablet)</li>
</ul>


<h3>Generate Random Key</h3>

<p>Berikut kode program untuk membuat key yang random.</p>

<p>```java
KeyGenerator keygen = KeyGenerator.getInstance("AES");
keygen.init(256);
SecretKey key = keygen.generateKey();</p>

<p>System.out.println("Generated Key : " + Base64.encodeBase64String(key.getEncoded()));
```</p>

<p>Key yang digenerate harus sesuai dengan algoritma enkripsi yang digunakan.</p>

<h3>Key Stretching</h3>

<p>Berikut kode program untuk key stretching. Kita akan membuat key turunan dari password yang lemah (hanya ada huruf, tidak ada angka dan karakter aneh).</p>

<p>```java
String password = "sangat rahasia sekali";</p>

<p>// generate random salt
SecureRandom randomizer = new SecureRandom();
BigInteger random = new BigInteger(32, randomizer);
String salt = random.toString(64);</p>

<p>int perulangan = 1000;
String algoritma = "PBKDF2WithHmacSHA1";
int panjangKey = 256;</p>

<p>PBEKeySpec keyspec = new PBEKeySpec(password.toCharArray(), salt.getBytes("UTF-8"), perulangan, panjangKey);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algoritma);
SecretKey key = keyFactory.generateSecret(keyspec);</p>

<p>System.out.println("Password asli : "+password);
System.out.println("Salt : "+salt);
System.out.println("Generated Key : " + Base64.encodeBase64String(key.getEncoded()));
```</p>

<p>Secara fungsi, salt mirip dengan initialization vector. Yaitu agar password yang sama hasil hash-nya berbeda. Salt juga tidak perlu dirahasiakan, tapi perlu disimpan supaya bisa dipakai untuk memeriksa password. Jika kita simpan password di database dengan mekanisme <em>key stretching</em> ini, yang harus kita simpan adalah:</p>

<ul>
<li>salt</li>
<li>jumlah perulangan</li>
<li>panjang key</li>
<li>key yang dihasilkan (ciphertext)</li>
</ul>


<blockquote><p>Perhatian! Key stretching ini bekerja satu arah. Artinya kita tidak bisa mendapatkan password plaintext dari ciphertextnya.</p></blockquote>

<h2>Contoh Kasus</h2>

<p>Sebagai contoh, kita ingin mengenkripsi file text. Supaya mudah, kita buat saja file text berisi lirik lagu yang bisa kita dapatkan di internet. Sepanjang prosedur enkripsi-dekripsi, ada beberapa file yang kita akan buat:</p>

<ul>
<li><code>lyric.txt</code> : file plaintext yang ingin kita enkripsi</li>
<li><code>key.txt</code> : file berisi key untuk enkripsi. Key ini bisa dibuat secara random ataupun dari input user yang sudah melalui proses <em>key stretching</em>.</li>
<li><code>iv.txt</code> : initialization vector</li>
<li><code>lyric-enc.txt</code> : file ciphertext hasil enkripsi</li>
<li><code>lyric-dec.txt</code> : file plaintext hasil dekripsi lyric-enc.txt</li>
</ul>


<p>Berikut langkah-langkah enkripsi:</p>

<ol>
<li>Generate key</li>
<li>Inisialisasi object yang akan melakukan enkripsi (<code>java.crypto.Cipher</code>) menggunakan key</li>
<li>Generate IV</li>
<li>Lakukan prosedur enkripsi, hasilnya tulis ke <code>lyric-enc.txt</code>.</li>
<li>Tulis juga key ke file <code>key.txt</code> dan IV ke file <code>iv.txt</code> untuk digunakan dalam proses dekripsi. Pada kondisi riil, IV bisa kita kirimkan melalui jalur publik, sedangkan key harus kita kirim melalui jalur aman. Biasanya key dienkripsi lagi menggunakan asymmetric encryption agar bisa dikirim dengan aman.</li>
</ol>


<p>Langkah-langkah dekripsi kebalikannya:</p>

<ol>
<li>Baca key dari file <code>key.txt</code></li>
<li>Baca IV dari file <code>iv.txt</code></li>
<li>Inisialisasi object yang akan melakukan dekripsi (<code>java.crypto.Cipher</code>) menggunakan key <strong>dan</strong> IV</li>
<li>Lakukan proses dekripsi</li>
</ol>


<p>Kalau sudah paham langkahnya, mari kita coding. Sebelum masuk ke kriptografi, kita bereskan dulu masalah tampilan.</p>

<h2>String Conversion</h2>

<p>Proses enkripsi menghasilkan binary data, dalam Java ini ditampung dalam tipe data <code>byte[]</code>. Binary data ini tidak bisa kita buka di text editor, sehingga menyulitkan kita untuk debug. Oleh karena itu, kita perlu menggunakan <a href="http://en.wikipedia.org/wiki/Base64">encoding Base 64</a> untuk mengkonversinya menjadi <code>String</code>. Kalau kita langsung memasukkannya ke dalam constructor String, hasilnya akan kacau karena <a href="http://stackoverflow.com/a/10759422">constructor String bingung ketika menghadapi karakter-karakter aneh</a> (non-printable).</p>

<p>Encoding Base64 kita lakukan dengan <a href="http://commons.apache.org/proper/commons-codec/">library <code>commons-codec</code> dari Apache</a>.</p>

<h2>Inisialisasi Cipher untuk Enkripsi</h2>

<p>Pertama, kita generate dulu key. Untuk enkripsi, object <code>cipher</code> harus diinisialisasi dengan key.</p>

<p>```java
String algoritmaKey = "AES";</p>

<p>// generate random key
KeyGenerator keygen = KeyGenerator.getInstance(algoritmaKey);
keygen.init(256);
SecretKey key = keygen.generateKey();</p>

<p>// tulis key ke file untuk keperluan dekripsi
Files.write(keyFile.toPath(), Base64.encodeBase64String(key.getEncoded()).getBytes(), StandardOpenOption.CREATE);
```</p>

<p>Pada kode program di atas, kita lihat bahwa sebelum ditulis ke file, kita encode dulu dengan method <code>Base64.encodeBase64String</code> supaya filenya bisa dibuka di text editor.</p>

<p>Setelah punya key, kita buat object <code>cipher</code></p>

<p><code>java
String algoritmaEnkripsi = "AES/CBC/PKCS5Padding";
Cipher cipher = Cipher.getInstance(algoritmaEnkripsi);
cipher.init(Cipher.ENCRYPT_MODE, key);
</code></p>

<p>Dari kode program di atas, kita bisa lihat bahwa:</p>

<ul>
<li>algoritma yang digunakan adalah <code>AES</code></li>
<li>block cipher mode menggunakan <code>CBC</code></li>
<li>padding menggunakan <code>PKCS5</code></li>
</ul>


<h2>Generate Initialization Vector</h2>

<p>IV kita generate menggunakan object <code>cipher</code></p>

<p><code>java
// generate IV
byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
</code></p>

<p>Jangan lupa ditulis ke file karena nanti akan kita butuhkan di proses dekripsi.</p>

<p><code>java
Files.write(ivFile.toPath(), Base64.encodeBase64String(iv).getBytes(), StandardOpenOption.CREATE);
</code></p>

<h2>Proses Enkripsi</h2>

<p>Kelengkapan sudah siap, mari kita lakukan proses enkripsi</p>

<p>```java
// tujuan hasil enkripsi
CipherOutputStream writer =</p>

<pre><code>        new CipherOutputStream(
            new FileOutputStream(encryptedFile), cipher);
</code></pre>

<p>// enkripsi isi file
FileReader reader = new FileReader(plain);
int data;
while((data = reader.read()) != -1){</p>

<pre><code>System.out.print((char)data);
writer.write(data);
</code></pre>

<p>}</p>

<p>reader.close();
writer.close();
```</p>

<p>Seharusnya, pada tahap ini kita sudah memiliki file berikut:</p>

<ol>
<li><code>lyric.txt</code></li>
<li><code>key.txt</code></li>
<li><code>iv.txt</code></li>
<li><code>lyric-enc.txt</code></li>
</ol>


<p>File <code>lyric-enc.txt</code> dan <code>iv.txt</code> kita kirimkan ke penerima. Dia harusnya sudah memiliki file <code>key.txt</code>.</p>

<p>Proses enkripsi selesai. Kode program lengkapnya bisa dilihat <a href="https://github.com/endymuhardin/belajar-enkripsi/blob/master/src/main/java/com/muhardin/endy/belajar/enkripsi/AESEncryptionDemo.java">di Github</a>.</p>

<p>Mari kita lanjutkan dengan proses dekripsi.</p>

<h2>Membaca key dan IV dari file</h2>

<p>Berikut kode programnya</p>

<p>```java
// load key
List<String> keys = Files.readAllLines(keyFile.toPath(), Charset.forName("UTF-8"));
if(keys.isEmpty()){</p>

<pre><code>throw new IllegalStateException("File key invalid");
</code></pre>

<p>}
String key = keys.get(0);
System.out.println("Key : "+key);
SecretKeySpec keySpec = new SecretKeySpec(Base64.decodeBase64(key), algoritmaKey);</p>

<p>// load IV
List<String> ivs = Files.readAllLines(ivFile.toPath(), Charset.forName("UTF-8"));
if(ivs.isEmpty()){</p>

<pre><code>throw new IllegalStateException("File IV invalid");
</code></pre>

<p>}
String iv = ivs.get(0);
System.out.println("IV : "+iv);
IvParameterSpec ivSpec = new IvParameterSpec(Base64.decodeBase64(iv));
```</p>

<h2>Inisialisasi Cipher</h2>

<p>Untuk proses dekripsi, inisialisasi <code>cipher</code> membutuhkan key dan IV.</p>

<p><code>java
// inisialisasi AES
Cipher cipher = Cipher.getInstance(algoritmaEnkripsi);
cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
</code></p>

<p>Jangan lupa gunakan mode <code>Cipher.DECRYPT_MODE</code>.</p>

<h2>Proses Dekripsi</h2>

<p>Tidak sulit, tinggal membalik saja prosedur enkripsi.</p>

<p>```java
// output hasil dekripsi
FileWriter output = new FileWriter(decryptedFile);</p>

<p>// dekripsi isi file
CipherInputStream cis = new CipherInputStream(new FileInputStream(encryptedFile), cipher);
int data;
while((data = cis.read()) != -1){</p>

<pre><code>output.write(data);
</code></pre>

<p>}
cis.close();
output.close();
```</p>

<h2>Verifikasi</h2>

<p>Setelah kita punya hasil dekripsi, tentu kita harus verifikasi apakah sama persis dengan aslinya. Caranya adalah dengan membandingkan <code>hash</code> file asli dan file hasil dekripsi. Kita bisa gunakan berbagai algoritma seperti <code>MD5</code> atau <code>SHA</code>. Berikut contohnya</p>

<p><code>java
// bandingkan apakah hasil dekripsi sama dengan file asli
String md5sumAsli = DigestUtils.md5Hex(new FileInputStream(plainFile));
String md5sumHasilDekripsi = DigestUtils.md5Hex(new FileInputStream(decryptedFile));
System.out.println("MD5 Sum File Asli           : "+md5sumAsli);
System.out.println("MD5 Sum File Hasil Dekripsi : "+md5sumHasilDekripsi);
System.out.println(md5sumAsli.equals(md5sumHasilDekripsi) ? "Cocok" : "Tidak cocok");
</code></p>

<p>Proses dekripsi selesai. Kode program lengkapnya bisa dilihat <a href="https://github.com/endymuhardin/belajar-enkripsi/blob/master/src/main/java/com/muhardin/endy/belajar/enkripsi/AESDecryptionDemo.java">di Github</a>.</p>

<h3>Message Authentication</h3>

<p>Message authentication cara kerjanya kira-kira sama dengan metode verifikasi di atas. Intinya adalah:</p>

<ol>
<li>Generate hash dari file A</li>
<li>Generate hash dari file B</li>
<li>Bandingkan, jika hash sama berarti file A dan B isinya sama</li>
</ol>


<p>Dalam kaitannya dengan enkripsi, kita menambahkan key pada proses hash ini supaya lebih aman. Tanpa key, orang lain bisa mencoba-coba generate hash dari file yang dia miliki. Kalau berhasil membuat hash yang sama, maka dia bisa menebak atau memalsukan data yang dikirim. Dengan menggunakan key yang hanya diketahui pihak yang berkomunikasi, maka orang lain sulit untuk membuat hash yang sama.</p>

<p>Proses ini nama kerennya adalah <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC (hash-based message authentication code)</a>.</p>

<p>Berikut kode program untuk menghasilkan hash dari data yang sudah dienkripsi</p>

<p>```java
// HMAC untuk memastikan integritas data
String algoritmaHmac = "HmacSHA512";
KeyGenerator keygenHmac = KeyGenerator.getInstance(algoritmaHmac);
keygenHmac.init(256);</p>

<p>// key untuk HMAC
SecretKey keyHmac = keygenHmac.generateKey();
Files.write(hmacKeyFile.toPath(),</p>

<pre><code>    Base64.encodeBase64String(keyHmac.getEncoded()).getBytes(), 
    StandardOpenOption.CREATE);
</code></pre>

<p>// buat HMAC
Mac hmacGenerator = Mac.getInstance(algoritmaHmac);
hmacGenerator.init(keyHmac);
byte[] hmac = hmacGenerator.doFinal(Files.readAllBytes(encryptedFile.toPath()));
Files.write(hmacFile.toPath(), hmac, StandardOpenOption.CREATE);
```</p>

<p>Perhatikan bahwa kita terlebih dulu menghasilkan key untuk membuat hash. Key ini harus dimiliki juga oleh pihak penerima data.</p>

<p>Sekarang, kita lakukan verifikasi di sisi penerima.</p>

<p>```java
// sebelum dekripsi, cek dulu HMAC apakah datanya otentik
List<String> hmacKeys = Files.readAllLines(hmacKeyFile.toPath(), Charset.forName("UTF-8"));
if(hmacKeys.isEmpty()) {</p>

<pre><code>throw new IllegalStateException("No mac key");
</code></pre>

<p>}
String hmacKey = hmacKeys.get(0);
SecretKeySpec hmacKeySpec = new SecretKeySpec(Base64.decodeBase64(hmacKey), algoritmaHmac);
Mac hmacGenerator = Mac.getInstance(algoritmaHmac);
hmacGenerator.init(hmacKeySpec);</p>

<p>// generate hmac dari data yang diterima
byte[] hmacDiterima = hmacGenerator.doFinal(Files.readAllBytes(encryptedFile.toPath()));
// baca hmac yang disertakan bersama data
byte[] hmacSeharusnya = Files.readAllBytes(hmacFile.toPath());
boolean cocok = Arrays.equals(hmacDiterima, hmacSeharusnya);
System.out.println(cocok ? "HMAC Cocok" : "HMAC Tidak Cocok");
if(!cocok){</p>

<pre><code>throw new IllegalStateException("Data tidak otentik, mungkin sudah dioprek orang ditengah jalan");
</code></pre>

<p>}
```</p>

<p>Verifikasi HMAC ini kita lakukan <strong>sebelum</strong> melakukan dekripsi. Tidak ada gunanya dan menambah resiko kalau kita melakukan proses dekripsi (di mana kita membuka dan menggunakan key rahasia) terhadap data yang invalid.</p>

<h1>Kesimpulan</h1>

<p>Pengirim dan penerima harus terlebih dulu memiliki:</p>

<ul>
<li>key enkripsi</li>
<li>key HMAC</li>
</ul>


<p>Kedua file ini harus dirahasiakan dari pihak yang tidak berkepentingan. Distribusinya bisa dilakukan dengan enkripsi menggunakan asymmetric encryption.</p>

<p>Pada saat berkomunikasi, pengirim akan memberikan:</p>

<ul>
<li>initialization vector</li>
<li>data yang terenkripsi</li>
<li>HMAC</li>
</ul>


<p>Ketiga data di atas boleh dikirim melalui jalur publik.</p>

<p>Setelah menerima ketiga file tersebut, penerima akan melakukan:</p>

<ol>
<li>Generate HMAC dari data terenkripsi</li>
<li>Bandingkan HMAC hasil generate dengan HMAC yang dikirim bersama data. Kalau tidak cocok, jangan diteruskan.</li>
<li>Kalau cocok, barulah lakukan dekripsi menggunakan key dan IV.</li>
</ol>


<blockquote><p>Bagaimana, pusing?</p></blockquote>

<p>Ya tinggal pilih, pusing belajar atau kena sadap :D</p>

<p>Kode program selengkapnya (seperti biasa) ada <a href="https://github.com/endymuhardin/belajar-enkripsi">di Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mendapatkan Informasi System dengan Java]]></title>
    <link href="http://software.endy.muhardin.com/java/mendapatkan-informasi-system-dengan-java/"/>
    <updated>2013-10-29T09:52:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mendapatkan-informasi-system-dengan-java</id>
    <content type="html"><![CDATA[<p>Pada salah satu project yang sedang saya kerjakan, ada kebutuhan untuk mendapatkan informasi mengenai sistem dimana aplikasi diinstal. Informasi yang dibutuhkan antara lain:</p>

<ul>
<li>Sistem Operasi</li>
<li>Kapasitas Memori</li>
<li>Kapasitas Disk</li>
<li>Jumlah Network Interface</li>
<li>MAC Address dari masing-masing Network Interface</li>
</ul>


<p>Dalam artikel ini, kita akan membahas cara mendapatkan berbagai informasi tersebut. Seperti biasa, kode program bisa diambil di <a href="https://github.com/endymuhardin/belajar-java-sysinfo">repository Github saya</a>.</p>

<!--more-->


<h2>Sistem Operasi</h2>

<p>Informasi tentang Sistem Operasi dapat diperoleh dengan menggunakan class java.lang.System. Dari class ini kita bisa menggunakan method getProperty yang berisi berbagai informasi tentang sistem. Daftar property yang tersedia dapat dilihat di <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperties()">halaman dokumentasinya</a>. Property yang berkaitan dengan sistem operasi adalah:</p>

<ul>
<li>os.name</li>
<li>os.version</li>
<li>os.arch</li>
</ul>


<p>Berikut contoh penggunaannya</p>

<p>```java
String os = System.getProperty("os.name");
os += ":" + System.getProperty("os.version");
os += ":" + System.getProperty("os.arch");</p>

<p>System.out.println(os);
```</p>

<p>Di laptop saya, outputnya seperti ini:</p>

<p><code>
Linux:3.11.0-12-generic:amd64
</code></p>

<h2>Kapasitas Memori</h2>

<p>Aplikasi Java berjalan di atas JVM, tidak langsung di atas sistem operasi. Untuk urusan memori, ada dua jenis memori yang kita kenal, yaitu memori yang disediakan untuk JVM dan memori yang tersedia di komputer (RAM). Hal ini sering menimbulkan kebingungan di programmer Java pemula, yaitu</p>

<blockquote><p>Komputer saya RAM-nya 8 GB, kenapa aplikasi Java saya cuma bisa pakai 2 GB?</p></blockquote>

<p>Biasanya penyebabnya adalah karena memori yang dialokasikan untuk JVM hanya 2 GB.</p>

<h3>Memori Fisik (RAM)</h3>

<p>Untuk mendapatkan informasi tentang memori fisik yang tersedia, kita gunakan class <code>com.sun.management.OperatingSystemMXBean</code>. Berikut cara mendapatkan object dari class tersebut.</p>

<p>```java
OperatingSystemMXBean osBean</p>

<pre><code>= (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
</code></pre>

<p>```</p>

<p>Setelah itu, kita bisa gunakan untuk mendapatkan informasi memori sebagai berikut</p>

<p><code>java
Long memory = osBean.getTotalPhysicalMemorySize();
</code></p>

<p>Dokumentasi lengkap dari class tersebut bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html">di sini</a>.</p>

<h3>Memori JVM</h3>

<p>Ada dua variabel yang menginformasikan memori JVM, yaitu memori yang dialokasikan, dan memori yang terpakai. Aplikasi kita boleh menggunakan memori maksimal sebanyak yang dialokasikan. Tapi aplikasi belum tentu menggunakan semuanya, hanya sebagian saja yang terpakai. Informasi memori JVM bisa didapatkan dari class <code>java.lang.Runtime</code>.</p>

<p>Berikut cara untuk mendapatkan memori yang dialokasikan untuk JVM</p>

<p><code>java
Long totalMemory = Runtime.getRuntime().totalMemory();
</code></p>

<p>Sedangkan untuk mendapatkan memori terpakai, kita kurangi <code>totalMemory</code> dengan <code>freeMemory</code> (memori yang tidak terpakai)</p>

<p><code>java
Long freeMemory = Runtime.getRuntime().freeMemory();
Long terpakai = totalMemory - freeMemory;
</code></p>

<p>Lebih lengkapnya bisa dilihat langsung di <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#totalMemory()">dokumentasi class <code>Runtime</code></a></p>

<h2>Kapasitas Storage</h2>

<p>Informasi tentang storage bisa didapatkan di class <code>java.io.File</code>. Pertama, kita buat dulu objek <code>File</code> yang mengarah ke partisi yang ingin kita ketahui informasinya.</p>

<p>Untuk Windows, gunakan <code>C:</code>, <code>D:</code>, dan seterusnya.</p>

<p><code>java
File f = new File("C:");
</code></p>

<p>Untuk Linux, gunakan <code>/</code>, <code>/home</code>, dan sebagainya.</p>

<p><code>java
File f = new File("/home");
</code></p>

<p>Ada beberapa method yang disediakan yaitu:</p>

<ul>
<li>totalSpace() : kapasitas storage</li>
<li>usableSpace() : kapasitas yang bisa digunakan</li>
<li>freeSpace() : ruang kosong</li>
</ul>


<p>Kita tentu bertanya-tanya, apa bedanya <code>usable</code> dan <code>free</code>? Free adalah ruang yang tidak terpakai, tapi belum tentu boleh dipakai karena masalah permission, ijin akses, dan sebagainya. Usable adalah ruang yang boleh dipakai. Kadang-kadang, nilai <code>usable</code> sama dengan nilai <code>free</code>. Penjelasannya bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#getUsableSpace(">di sini</a>).</p>

<p>Cara pakainya tidak sulit.</p>

<p><code>java
Long totalSpace = f.getTotalSpace();
Long usableSpace = f.getUsableSpace();
Long freeSpace = f.getFreeSpace();
</code></p>

<h2>Network Interface</h2>

<p>Informasi tentang network interface bisa didapatkan di <code>java.net.NetworkInterface</code>. Pertama, kita dapatkan dulu seluruh interface yang ada di komputer. Satu komputer (apalagi server) biasa memiliki lebih dari satu interface. Laptop saja biasanya punya dua, ethernet dan wifi.</p>

<p><code>java
Enumeration&lt;NetworkInterface&gt; semuaInterface = NetworkInterface.getNetworkInterfaces();
</code></p>

<p>Setelah itu, kita bisa melakukan loop untuk mendapatkan jumlah interface, nama interface, dan MAC addressnya.</p>

<p>```java
Integer jumlah = 0;
while(semuaInterface.hasMoreElements()){</p>

<pre><code>NetworkInterface ni = semuaInterface.nextElement();
System.out.println("Nama Interface : "+ni.getDisplayName());
byte[] mac = ni.getHardwareAddress();
if(mac != null){
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; mac.length; i++) {
            sb.append(String.format("%02X%s", mac[i], (i &lt; mac.length - 1) ? "-" : ""));        
    }
    System.out.println("MAC Address : "+sb.toString());
}
jumlah++;
</code></pre>

<p>}
System.out.println("Jumlah interface : "+jumlah);
```</p>

<p>Demikianlah cara mendapatkan informasi tentang sistem tempat aplikasi Java kita dijalankan.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrasi Database dengan Liquibase]]></title>
    <link href="http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase/"/>
    <updated>2013-10-01T21:22:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase</id>
    <content type="html"><![CDATA[<p>Salah satu kepuasan kita sebagai programmer adalah pada waktu aplikasi yang kita buat digunakan banyak user dan menghasilkan banyak manfaat bagi mereka. Sebagai konsekuensinya, akan banyak permintaan tambahan dari user untuk menambah fitur ataupun mengubah fitur yang sudah ada supaya makin nyaman digunakan.</p>

<p>Seringkali terjadi, perubahan yang diminta ini akan menyebabkan berubahnya skema database. Ini merupakan hal yang wajar dan umum terjadi, sehingga kita perlu menyiapkan mental untuk menerima kondisi ini sebagai sesuatu yang lumrah dan tidak mengerikan.</p>

<p>Tools yang sering saya gunakan untuk mengurus perubahan (evolusi) skema database adalah <a href="http://www.liquibase.org">Liquibase</a>. Pada <a href="http://software.endy.muhardin.com/java/membuat-changelog-liquibase/">artikel terdahulu</a>, kita sudah membahas cara menggunakan Liquibase untuk mengkonversi skema database menjadi XML supaya bisa dikelola di version control. Kali ini, kita akan menggunakan Liquibase untuk melakukan migrasi dari skema database antar versi aplikasi.</p>

<!--more-->


<p>Studi kasusnya sebagai berikut. Misalnya kita punya aplikasi versi <code>1.0</code> yang sudah berjalan di production (live) dan digunakan user. Aplikasi versi <code>1.0</code> ini kita kembangkan selama beberapa minggu --diberikan tambahan fitur, bug diperbaiki, tampilan diperindah, dan berbagai peningkatan lainnya-- menjadi versi <code>2.0</code>. Antar kedua versi ini terjadi perubahan skema database. Kita ingin membuat script SQL untuk mengkonversi (migrasi) skema database versi <code>1.0</code> menjadi skema versi <code>2.0</code>. Untuk keperluan itu, kita gunakan Liquibase.</p>

<p>Liquibase memiliki kemampuan untuk membandingkan (diff) dua database, kemudian membuatkan file untuk migrasi dari skema yang satu (versi <code>1.0</code>) menjadi skema lainnya (versi <code>2.0</code>).</p>

<h2>Menyiapkan kedua database</h2>

<p>Langkah pertama adalah menyiapkan kedua versi database. Biasanya saya membuat dump dari database production (skema versi <code>1.0</code>), kemudian di-restore di tempat lain (misalnya di laptop). Kemudian saya juga menyiapkan database development yang menggunakan skema versi <code>2.0</code>.</p>

<p>Agar lebih jelas, kita namakan saja database yang diambil dari production dengan nama <code>aplikasi_v_1_0</code> dan database baru dengan nama <code>aplikasi_v_2_0</code>. Berikut adalah informasi koneksi JDBC untuk kedua database</p>

<h3>aplikasi_v_1_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_1_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h3>aplikasi_v_2_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_2_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h2>Konfigurasi Liquibase</h2>

<p>Seperti di artikel terdahulu, kita membutuhkan tiga file yang kita letakkan di folder yang sama, yaitu:</p>

<ul>
<li><code>mysql-connector-java-5.1.25.jar</code> : driver database</li>
<li><code>liquibase-core-2.0.5.jar</code> : aplikasi liquibase</li>
<li><code>liquibase.properties</code> : konfigurasi liquibase</li>
</ul>


<p>Sesuaikan kedua file jar dengan versi yang terbaru.</p>

<p>File <code>liquibase.properties</code> berisi konfigurasi yang dibutuhkan oleh liquibase. Berikut isinya</p>

<p><code>
driver: com.mysql.jdbc.Driver
classpath: mysql-connector-java-5.1.25.jar
url: jdbc:mysql://localhost/aplikasi_v_2_0
username: root
password: admin
referenceUrl: jdbc:mysql://localhost/aplikasi_v_1_0
referenceUsername: root
referencePassword: admin
changeLogFile: changelog.xml
</code></p>

<p>Berikut penjelasan dari isi file:</p>

<ul>
<li>driver: JDBC driver sesuai merek database yang kita gunakan</li>
<li>classpath: lokasi file JDBC driver</li>
<li>url: JDBC url untuk database tujuan (versi <code>2.0</code>)</li>
<li>username: username untuk database tujuan (versi <code>2.0</code>)</li>
<li>password: password untuk database tujuan (versi <code>2.0</code>)</li>
<li>referenceUrl: JDBC url untuk database asal (versi <code>1.0</code>)</li>
<li>referenceUsername: username untuk database asal (versi <code>1.0</code>)</li>
<li>referencePassword: password untuk database asal (versi <code>1.0</code>)</li>
<li>changeLogFile: nama file tujuan untuk menulis hasil perbandingan kedua database</li>
</ul>


<h2>Menjalankan Liquibase : Membuat file changelog</h2>

<p>Pertama, kita buat dulu file changelog sesuai format Liquibase. Commandnya adalah sebagai berikut:</p>

<p><code>
java -jar liquibase-core-2.0.5.jar diffChangeLog
</code></p>

<p>Berikut output dari perintah di atas</p>

<p><code>
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: changelog.xml does not exist, creating
Liquibase 'diffChangeLog' Successful
</code></p>

<p>Perintah ini akan menghasilkan file <code>changelog.xml</code> di folder tempat kita berada. File ini berisi perbedaan antar skema versi 1.0 dengan skema versi 2.0. Isinya seperti ini</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"></p>

<pre><code>&lt;changeSet author="endy (generated)" id="1380636706862-1"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="allowed_addresses" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-2"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-3"&gt;
    &lt;addColumn tableName="m_plan"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-4"&gt;
    &lt;addColumn tableName="m_provider"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-5"&gt;
    &lt;addColumn tableName="m_rate"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-6"&gt;
    &lt;addColumn tableName="m_routing"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-7"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_password" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-8"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_username" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
</code></pre>

<p></databaseChangeLog>
```</p>

<p>Kita lihat di atas bahwa antara skema versi <code>1.0</code> dan versi <code>2.0</code> terjadi perubahan sebagai berikut:</p>

<ul>
<li>penambahan kolom <code>allowed_address</code> di tabel <code>m_customer</code></li>
<li>penambahan kolom <code>deleted</code> di berbagai tabel lainnya</li>
<li>menghilangkan constraint <code>NOT NULL</code> di kolom <code>bind_username</code> dan <code>bind_password</code></li>
</ul>


<p>Kita bisa periksa file ini dan sesuaikan bila ada yang kurang tepat.</p>

<h2>Menjalankan Liquibase : Membuat script SQL</h2>

<p>File XML saja tentunya tidak bermanfaat banyak buat kita. Untuk bisa dieksekusi di database production, kita memerlukan script SQL. Untungnya Liquibase punya fitur untuk membuat script SQL. Berikut perintahnya</p>

<p><code>
java -jar liquibase-core-2.0.5.jar updateSQL
</code></p>

<p>Outputnya adalah sebagai berikut</p>

<p>```sql
--  <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>
--  Update Database Script
--  </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
--  Change Log: changelog.xml
--  Ran at: 10/1/13 9:18 PM
--  Against: root@localhost@jdbc:mysql://localhost/aplikasi_v_2_0
--  Liquibase version: 2.0.5
--  *********************************************************************</p>

<p>--  Lock Database
--  Changeset changelog.xml::1380636706862-1::endy (generated)::(Checksum: 3:87288bc453555824cb2e28ddafed9557)
ALTER TABLE <code>m_customer</code> ADD <code>allowed_addresses</code> VARCHAR(255) NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-1', '2.0.5', '3:87288bc453555824cb2e28ddafed9557', 5);</p>

<p>--  Changeset changelog.xml::1380636706862-2::endy (generated)::(Checksum: 3:27e1f8b069e4471400f3deff5034bca9)
ALTER TABLE <code>m_customer</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-2', '2.0.5', '3:27e1f8b069e4471400f3deff5034bca9', 6);</p>

<p>--  Changeset changelog.xml::1380636706862-3::endy (generated)::(Checksum: 3:14c13dec957537886d6035b32fd4c90c)
ALTER TABLE <code>m_plan</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-3', '2.0.5', '3:14c13dec957537886d6035b32fd4c90c', 7);</p>

<p>--  Changeset changelog.xml::1380636706862-4::endy (generated)::(Checksum: 3:b54952b6be5eb80caf649dc75f974f65)
ALTER TABLE <code>m_provider</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-4', '2.0.5', '3:b54952b6be5eb80caf649dc75f974f65', 8);</p>

<p>--  Changeset changelog.xml::1380636706862-5::endy (generated)::(Checksum: 3:6b840975b06488faa9ec0ed1d3e8d123)
ALTER TABLE <code>m_rate</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-5', '2.0.5', '3:6b840975b06488faa9ec0ed1d3e8d123', 9);</p>

<p>--  Changeset changelog.xml::1380636706862-6::endy (generated)::(Checksum: 3:909c459661aacc260b40971e4215a481)
ALTER TABLE <code>m_routing</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-6', '2.0.5', '3:909c459661aacc260b40971e4215a481', 10);</p>

<p>--  Changeset changelog.xml::1380636706862-7::endy (generated)::(Checksum: 3:ac26c24529898f4c1c2133225d3d5ee8)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_password</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-7', '2.0.5', '3:ac26c24529898f4c1c2133225d3d5ee8', 11);</p>

<p>--  Changeset changelog.xml::1380636706862-8::endy (generated)::(Checksum: 3:968da08768e83eaaa863f0a3cafc204e)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_username</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-8', '2.0.5', '3:968da08768e83eaaa863f0a3cafc204e', 12);</p>

<p>--  Release Database Lock
```</p>

<p>Output tersebut bisa kita periksa dulu kebenarannya, kemudian kita edit bila perlu, lalu tinggal dijalankan di skema database versi <code>1.0</code> ... voila ... dia akan berubah menjadi database dengan skema versi <code>2.0</code>.</p>

<p>Demikianlah cara mudah untuk melakukan migrasi. Jangan lupa simpan isi file <code>changelog.xml</code> ke dalam version control supaya segala perubahan terhadap skema database tercatat riwayatnya.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengobati OOM]]></title>
    <link href="http://software.endy.muhardin.com/java/mengobati-oom/"/>
    <updated>2013-06-08T22:25:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengobati-oom</id>
    <content type="html"><![CDATA[<p>Beberapa waktu belakangan ini, di milis mulai banyak bermunculan pertanyaan yang berkaitan dengan Out Of Memory Error (OOM).
Error ini biasanya terjadi bila data dalam aplikasi sudah besar (melebihi 2 GB), dan umumnya terjadi pada saat membuat report PDF/XLS/CSV, dsb.</p>

<p>Biasanya juga, <em>obat yang dikonsumsi</em> oleh penderita OOM ini ada dua:</p>

<ul>
<li>Mengatur alokasi memori dengan opsi <code>Xms</code> dan <code>Xmx</code></li>
<li>Menggunakan perintah <code>System.gc()</code></li>
</ul>


<p>Sayangnya, kedua <em>obat</em> ini tidak akan menyelesaikan masalah. Analoginya seperti kita kena infeksi otak, lalu minum Panadol. Sakit kepalanya mungkin akan hilang sementara waktu, tapi tidak lama kemudian justru akibatnya lebih fatal.</p>

<p>Lalu bagaimana solusinya?</p>

<!--more-->


<h1>Salah Kaprah tentang OOM</h1>

<p>Pertama, saya luruskan dulu mengenai <code>System.gc</code>.
Intinya begini</p>

<blockquote><p>System.gc() hanya boleh dipakai dengan satu (dan hanya satu-satunya) syarat:
Yaitu pada waktu sudah bisa menjelaskan ke orang lain bagaimana cara kerja garbage collector dan sudah paham apa itu JVM Ergonomics.</p></blockquote>

<p>Next time mau mengetik System.gc, tanyakan pada diri sendiri, apakah saya sudah paham JVM Ergonomics dan bisa menjelaskannya ke orang lain? Kalau jawabannya belum, jangan diteruskan mengetik System.gc().</p>

<blockquote><p>Lalu apa itu <code>System.gc</code> dan kapan digunakan?</p></blockquote>

<p>Kan sudah dijelaskan di atas, pelajari cara kerja garbage collector dan apa itu JVM ergonomics.</p>

<p>Satu lagi salah kaprah yang harus dibenahi :
opsi <code>Xms</code> dan <code>Xmx</code> itu gunanya adalah <strong>UNTUK MEMAKSIMALKAN PENGGUNAAN MEMORI</strong>.
<code>Xms</code> dan <code>Xms</code> <strong>BUKAN SOLUSI UNTUK MASALAH OOM</strong>.</p>

<p>Masalah OOM itu ada di kode program kita sendiri, jadi carilah solusinya di kode program kita sendiri.
Penyebab OOM itu juga cuma satu : aplikasi kita menggunakan memori lebih besar daripada yang tersedia.
Besar pasak daripada tiang.</p>

<ol>
<li>Memori tersedia 4 GB, aplikasi kita pakai 4.1 GB => OOM</li>
<li>Memori tersedia 2 GB, aplikasi kita pakai 1.5 GB => No OOM padahal lebih kecil dari #1</li>
<li>RAM fisik ada 16 GB, tapi aplikasi kita cuma bisa memanfaatkan 2 GB => gunakan <code>Xms</code> dan <code>Xmx</code>.</li>
</ol>


<h1>Penyebab OOM dan Solusinya</h1>

<p>Beberapa penyebab umum terjadinya OOM :</p>

<h2>Unbounded Query</h2>

<p>Unbounded query adalah query yang tidak kita batasi jumlahnya.
Contohnya <code>select * from tbl_penjualan</code>. Kalau data penjualan hanya 1000 transaksi, no problem. Kalau transaksinya ada 10 juta record dalam satu hari, ya pasti langsung kena OOM.</p>

<p>Solusinya : pastikan selalu menggunakan paging. Ganti querynya menjadi <code>select * from tbl_penjualan limit 0,20</code> sehingga cuma mengeluarkan 20 record, berapapun banyaknya data dalam tabel.</p>

<h2>Generate File</h2>

<p>Seringkali kita ingin menghasilkan file report. Misalnya laporan penjualan bulan ini, berapapun data yang ada di tabel untuk periode bulan ini, harus ditulis ke file. File ini bisa berupa PDF, XLS, XML, CSV, dan sebagainya.</p>

<p>Format file tidak masalah. Yang menjadi masalah adalah cara membuatnya. Ada beberapa kesalahan umum :</p>

<ul>
<li>mengumpulkan data di variabel sebelum menulis file</li>
<li>tidak melepas data yang sudah diproses</li>
<li>tidak paham cara kerja report engine</li>
</ul>


<h3>Mengumpulkan data di variabel</h3>

<p>Contoh pseudocode seperti ini</p>

<p>```java
List<Penjualan> data = new ArrayList<Penjualan>();</p>

<p>// resultset adalah cursor, dia hanya baca apa yang ditarik saja
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>while(rs.next()){</p>

<pre><code>Penjualan p = konversiResultSetJadiPenjualan(rs);
data.add(p);
</code></pre>

<p>}
```</p>

<p>Coding di atas akan mengumpulkan semua record di variabel <code>data</code>.
Bila ada 1 juta record yang dihasilkan oleh query dengan masing-masing record berukuran 1 KB,
maka variabel data tersebut akan berukuran 1 GB. Kalau Java VM kita berikan alokasi 2 GB, cuma butuh 3 user untuk menimbulkan OOM.
Menaikkan alokasi menjadi 8 GB melalui <code>Xms</code> dan <code>Xmx</code> tidak akan membantu banyak.</p>

<h3>Tidak melepas data yang sudah diproses</h3>

<p>Ini biasanya terjadi kalau kita menulis sendiri file output. Perhatikan contoh kode berikut:</p>

<p>```java
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>File output = new File("output.csv");
while(rs.next()){</p>

<pre><code>String baris = konversiResultSetJadiString(rs);
output.write(baris);
output.flush();
</code></pre>

<p>}
```</p>

<p>Menulis file ada bermacam-macam. Ada yang menggunakan buffer ada yang tidak. Pastikan kita mengosongkan buffer setiap kali iterasi supaya tidak penuh, biasanya dengan method <code>flush</code> atau sejenisnya.</p>

<h3>Tidak paham cara kerja report engine</h3>

<p>Dalam mendesain library yang dipakai orang banyak, biasanya si pembuat akan melakukan optimasi untuk penggunaan yang sering terjadi.
Misalnya 80% orang membuat PDF berukuran 10 halaman atau lebih sedikit, 20% sisanya membuat 1000 halaman atau lebih.
Pada situasi ini, pembuat library report yang baik pasti akan memudahkan pembuatan 10 halaman report karena itulah fitur yang paling sering digunakan.</p>

<p>Bila kita termasuk golongan yang 20%, kita harus belajar lebih giat supaya paham bagaimana mengatasi kondisi minoritas tersebut.</p>

<p>Sebagai contoh, kalau kita menggunakan Jasper Report, ada fitur yang disebut dengan <a href="http://community.jaspersoft.com/wiki/comparison-report-virtualizers">Virtualizer</a> untuk membuat report berukuran besar. Pastikan kita sudah memahami kasus-kasus khusus ini.</p>

<h2>Inisialisasi object besar di dalam loop</h2>

<p>Perhatikan contoh kode di bawah</p>

<p>```java
public void simpan(Produk p){</p>

<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext("konfig-spring.xml");
ProdukDao pd = ctx.getBean(ProdukDao.class);
pd.save(p);
</code></pre>

<p>}
```</p>

<p><code>ApplicationContext</code> merupakan object Spring Framework yang berisi seluruh konfigurasi aplikasi. Isinya :</p>

<ul>
<li>konfigurasi database</li>
<li>mapping ORM (kalau pakai ORM)</li>
<li>semua object yang dimanage Spring</li>
</ul>


<p>Intinya, ini adalah object yang besar sekali dan sangat kompleks. Object seperti ini biasanya hanya dibuat sekali saja sepanjang aplikasi dijalankan. Bila kita taruh dalam method seperti di atas, maka tiap kali ada user simpan data produk, object besar tersebut akan dibuat, sehingga menghabiskan memori.</p>

<p>Pesan moralnya, pahami library yang digunakan supaya tahu karakteristik dan cara kerjanya.</p>

<h2>Penggunaan collection yang kurang benar</h2>

<p>Collection (Set, Map, List) adalah object yang menampung object lain. Kita harus memastikan bahwa object ini berada dalam scope yang benar. Lihat kode program berikut</p>

<p>```java
public class Coba {</p>

<pre><code>private static List&lt;Integer&gt; noSurat = new ArrayList&lt;Integer&gt;();
private static Integer noTerakhir = 0;

public void bikinSuratBaru(){
    noTerakhir++;
    noSurat.add(noTerakhir);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Pada kode di atas, <code>noSurat</code> memiliki scope static, sehingga dia akan terus ada selama aplikasi berjalan. Bila aplikasi tidak mati dalam waktu yang lama, dan dalam sehari ada 1 juta surat baru, tinggal tunggu waktu saja sampai kena OOM.</p>

<h1>Panduan Solusi Umum</h1>

<p>Selain yang disebutkan di atas, masih banyak penyebab lain, yang paling sering terjadi adalah yang dibahas di atas. Kalau penyebab OOM tidak kita atasi, berapapun memori yang kita sediakan (melalui <code>Xms</code> dan <code>Xmx</code>) tidak akan cukup. Inilah sebabnya saya katakan bahwa <code>Xms</code> dan <code>Xmx</code> itu bukan solusi untuk OOM. Yang harus kita lakukan adalah <strong>mengendalikan pemakaian</strong> memori, bukan <strong>menambah</strong> memori.</p>

<p>Jadi kalau menemukan OOM, coba dicek lagi kode programnya.
Tidak perlu pakai VisualVM atau tools2 lain, cukup code review aja.</p>

<p>Dibaca satu2 source codenya, untuk tiap baris, tanyakan pertanyaan ini :</p>

<ol>
<li>Method/statement ini akan dipanggil seberapa sering?</li>
<li>Looping ini akan berputar maksimal berapa kali?</li>
<li>Berapa kira2 ukuran tiap row yang ditarik dalam query? Sekali tarik berapa row?</li>
<li>Setelah saya tarik row, kapan dia selesai digunakan? Apakah nunggu PDF jadi dulu baru selesai (inilah kandidat OOM), atau tiap selesai satu halaman PDF sudah bisa direlease?</li>
</ol>


<p>Mudah-mudahan dengan adanya artikel ini tidak ada lagi orang yang mengobati OOM dengan <code>System.gc</code> atau <code>Xmx</code>.</p>

<h2>Referensi</h2>

<ul>
<li><a href="http://java.dzone.com/news/how-fix-memory-leaks-java">How to fix memory leaks in Java</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
