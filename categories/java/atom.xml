<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-10-05T00:00:09+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Migrasi Database dengan Liquibase]]></title>
    <link href="http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase/"/>
    <updated>2013-10-01T21:22:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase</id>
    <content type="html"><![CDATA[<p>Salah satu kepuasan kita sebagai programmer adalah pada waktu aplikasi yang kita buat digunakan banyak user dan menghasilkan banyak manfaat bagi mereka. Sebagai konsekuensinya, akan banyak permintaan tambahan dari user untuk menambah fitur ataupun mengubah fitur yang sudah ada supaya makin nyaman digunakan.</p>

<p>Seringkali terjadi, perubahan yang diminta ini akan menyebabkan berubahnya skema database. Ini merupakan hal yang wajar dan umum terjadi, sehingga kita perlu menyiapkan mental untuk menerima kondisi ini sebagai sesuatu yang lumrah dan tidak mengerikan.</p>

<p>Tools yang sering saya gunakan untuk mengurus perubahan (evolusi) skema database adalah <a href="http://www.liquibase.org">Liquibase</a>. Pada <a href="http://software.endy.muhardin.com/java/membuat-changelog-liquibase/">artikel terdahulu</a>, kita sudah membahas cara menggunakan Liquibase untuk mengkonversi skema database menjadi XML supaya bisa dikelola di version control. Kali ini, kita akan menggunakan Liquibase untuk melakukan migrasi dari skema database antar versi aplikasi.</p>

<!--more-->


<p>Studi kasusnya sebagai berikut. Misalnya kita punya aplikasi versi <code>1.0</code> yang sudah berjalan di production (live) dan digunakan user. Aplikasi versi <code>1.0</code> ini kita kembangkan selama beberapa minggu --diberikan tambahan fitur, bug diperbaiki, tampilan diperindah, dan berbagai peningkatan lainnya-- menjadi versi <code>2.0</code>. Antar kedua versi ini terjadi perubahan skema database. Kita ingin membuat script SQL untuk mengkonversi (migrasi) skema database versi <code>1.0</code> menjadi skema versi <code>2.0</code>. Untuk keperluan itu, kita gunakan Liquibase.</p>

<p>Liquibase memiliki kemampuan untuk membandingkan (diff) dua database, kemudian membuatkan file untuk migrasi dari skema yang satu (versi <code>1.0</code>) menjadi skema lainnya (versi <code>2.0</code>).</p>

<h2>Menyiapkan kedua database</h2>

<p>Langkah pertama adalah menyiapkan kedua versi database. Biasanya saya membuat dump dari database production (skema versi <code>1.0</code>), kemudian di-restore di tempat lain (misalnya di laptop). Kemudian saya juga menyiapkan database development yang menggunakan skema versi <code>2.0</code>.</p>

<p>Agar lebih jelas, kita namakan saja database yang diambil dari production dengan nama <code>aplikasi_v_1_0</code> dan database baru dengan nama <code>aplikasi_v_2_0</code>. Berikut adalah informasi koneksi JDBC untuk kedua database</p>

<h3>aplikasi_v_1_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_1_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h3>aplikasi_v_2_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_2_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h2>Konfigurasi Liquibase</h2>

<p>Seperti di artikel terdahulu, kita membutuhkan tiga file yang kita letakkan di folder yang sama, yaitu:</p>

<ul>
<li><code>mysql-connector-java-5.1.25.jar</code> : driver database</li>
<li><code>liquibase-core-2.0.5.jar</code> : aplikasi liquibase</li>
<li><code>liquibase.properties</code> : konfigurasi liquibase</li>
</ul>


<p>Sesuaikan kedua file jar dengan versi yang terbaru.</p>

<p>File <code>liquibase.properties</code> berisi konfigurasi yang dibutuhkan oleh liquibase. Berikut isinya</p>

<p><code>
driver: com.mysql.jdbc.Driver
classpath: mysql-connector-java-5.1.25.jar
url: jdbc:mysql://localhost/aplikasi_v_2_0
username: root
password: admin
referenceUrl: jdbc:mysql://localhost/aplikasi_v_1_0
referenceUsername: root
referencePassword: admin
changeLogFile: changelog.xml
</code></p>

<p>Berikut penjelasan dari isi file:</p>

<ul>
<li>driver: JDBC driver sesuai merek database yang kita gunakan</li>
<li>classpath: lokasi file JDBC driver</li>
<li>url: JDBC url untuk database tujuan (versi <code>2.0</code>)</li>
<li>username: username untuk database tujuan (versi <code>2.0</code>)</li>
<li>password: password untuk database tujuan (versi <code>2.0</code>)</li>
<li>referenceUrl: JDBC url untuk database asal (versi <code>1.0</code>)</li>
<li>referenceUsername: username untuk database asal (versi <code>1.0</code>)</li>
<li>referencePassword: password untuk database asal (versi <code>1.0</code>)</li>
<li>changeLogFile: nama file tujuan untuk menulis hasil perbandingan kedua database</li>
</ul>


<h2>Menjalankan Liquibase : Membuat file changelog</h2>

<p>Pertama, kita buat dulu file changelog sesuai format Liquibase. Commandnya adalah sebagai berikut:</p>

<p><code>
java -jar liquibase-core-2.0.5.jar diffChangeLog
</code></p>

<p>Berikut output dari perintah di atas</p>

<p><code>
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: changelog.xml does not exist, creating
Liquibase 'diffChangeLog' Successful
</code></p>

<p>Perintah ini akan menghasilkan file <code>changelog.xml</code> di folder tempat kita berada. File ini berisi perbedaan antar skema versi 1.0 dengan skema versi 2.0. Isinya seperti ini</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"></p>

<pre><code>&lt;changeSet author="endy (generated)" id="1380636706862-1"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="allowed_addresses" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-2"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-3"&gt;
    &lt;addColumn tableName="m_plan"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-4"&gt;
    &lt;addColumn tableName="m_provider"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-5"&gt;
    &lt;addColumn tableName="m_rate"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-6"&gt;
    &lt;addColumn tableName="m_routing"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-7"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_password" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-8"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_username" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
</code></pre>

<p></databaseChangeLog>
```</p>

<p>Kita lihat di atas bahwa antara skema versi <code>1.0</code> dan versi <code>2.0</code> terjadi perubahan sebagai berikut:</p>

<ul>
<li>penambahan kolom <code>allowed_address</code> di tabel <code>m_customer</code></li>
<li>penambahan kolom <code>deleted</code> di berbagai tabel lainnya</li>
<li>menghilangkan constraint <code>NOT NULL</code> di kolom <code>bind_username</code> dan <code>bind_password</code></li>
</ul>


<p>Kita bisa periksa file ini dan sesuaikan bila ada yang kurang tepat.</p>

<h2>Menjalankan Liquibase : Membuat script SQL</h2>

<p>File XML saja tentunya tidak bermanfaat banyak buat kita. Untuk bisa dieksekusi di database production, kita memerlukan script SQL. Untungnya Liquibase punya fitur untuk membuat script SQL. Berikut perintahnya</p>

<p><code>
java -jar liquibase-core-2.0.5.jar updateSQL
</code></p>

<p>Outputnya adalah sebagai berikut</p>

<p>```sql
--  <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>
--  Update Database Script
--  </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
--  Change Log: changelog.xml
--  Ran at: 10/1/13 9:18 PM
--  Against: root@localhost@jdbc:mysql://localhost/aplikasi_v_2_0
--  Liquibase version: 2.0.5
--  *********************************************************************</p>

<p>--  Lock Database
--  Changeset changelog.xml::1380636706862-1::endy (generated)::(Checksum: 3:87288bc453555824cb2e28ddafed9557)
ALTER TABLE <code>m_customer</code> ADD <code>allowed_addresses</code> VARCHAR(255) NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-1', '2.0.5', '3:87288bc453555824cb2e28ddafed9557', 5);</p>

<p>--  Changeset changelog.xml::1380636706862-2::endy (generated)::(Checksum: 3:27e1f8b069e4471400f3deff5034bca9)
ALTER TABLE <code>m_customer</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-2', '2.0.5', '3:27e1f8b069e4471400f3deff5034bca9', 6);</p>

<p>--  Changeset changelog.xml::1380636706862-3::endy (generated)::(Checksum: 3:14c13dec957537886d6035b32fd4c90c)
ALTER TABLE <code>m_plan</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-3', '2.0.5', '3:14c13dec957537886d6035b32fd4c90c', 7);</p>

<p>--  Changeset changelog.xml::1380636706862-4::endy (generated)::(Checksum: 3:b54952b6be5eb80caf649dc75f974f65)
ALTER TABLE <code>m_provider</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-4', '2.0.5', '3:b54952b6be5eb80caf649dc75f974f65', 8);</p>

<p>--  Changeset changelog.xml::1380636706862-5::endy (generated)::(Checksum: 3:6b840975b06488faa9ec0ed1d3e8d123)
ALTER TABLE <code>m_rate</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-5', '2.0.5', '3:6b840975b06488faa9ec0ed1d3e8d123', 9);</p>

<p>--  Changeset changelog.xml::1380636706862-6::endy (generated)::(Checksum: 3:909c459661aacc260b40971e4215a481)
ALTER TABLE <code>m_routing</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-6', '2.0.5', '3:909c459661aacc260b40971e4215a481', 10);</p>

<p>--  Changeset changelog.xml::1380636706862-7::endy (generated)::(Checksum: 3:ac26c24529898f4c1c2133225d3d5ee8)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_password</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-7', '2.0.5', '3:ac26c24529898f4c1c2133225d3d5ee8', 11);</p>

<p>--  Changeset changelog.xml::1380636706862-8::endy (generated)::(Checksum: 3:968da08768e83eaaa863f0a3cafc204e)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_username</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-8', '2.0.5', '3:968da08768e83eaaa863f0a3cafc204e', 12);</p>

<p>--  Release Database Lock
```</p>

<p>Output tersebut bisa kita periksa dulu kebenarannya, kemudian kita edit bila perlu, lalu tinggal dijalankan di skema database versi <code>1.0</code> ... voila ... dia akan berubah menjadi database dengan skema versi <code>2.0</code>.</p>

<p>Demikianlah cara mudah untuk melakukan migrasi. Jangan lupa simpan isi file <code>changelog.xml</code> ke dalam version control supaya segala perubahan terhadap skema database tercatat riwayatnya.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengobati OOM]]></title>
    <link href="http://software.endy.muhardin.com/java/mengobati-oom/"/>
    <updated>2013-06-08T22:25:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengobati-oom</id>
    <content type="html"><![CDATA[<p>Beberapa waktu belakangan ini, di milis mulai banyak bermunculan pertanyaan yang berkaitan dengan Out Of Memory Error (OOM).
Error ini biasanya terjadi bila data dalam aplikasi sudah besar (melebihi 2 GB), dan umumnya terjadi pada saat membuat report PDF/XLS/CSV, dsb.</p>

<p>Biasanya juga, <em>obat yang dikonsumsi</em> oleh penderita OOM ini ada dua:</p>

<ul>
<li>Mengatur alokasi memori dengan opsi <code>Xms</code> dan <code>Xmx</code></li>
<li>Menggunakan perintah <code>System.gc()</code></li>
</ul>


<p>Sayangnya, kedua <em>obat</em> ini tidak akan menyelesaikan masalah. Analoginya seperti kita kena infeksi otak, lalu minum Panadol. Sakit kepalanya mungkin akan hilang sementara waktu, tapi tidak lama kemudian justru akibatnya lebih fatal.</p>

<p>Lalu bagaimana solusinya?</p>

<!--more-->


<h1>Salah Kaprah tentang OOM</h1>

<p>Pertama, saya luruskan dulu mengenai <code>System.gc</code>.
Intinya begini</p>

<blockquote><p>System.gc() hanya boleh dipakai dengan satu (dan hanya satu-satunya) syarat:
Yaitu pada waktu sudah bisa menjelaskan ke orang lain bagaimana cara kerja garbage collector dan sudah paham apa itu JVM Ergonomics.</p></blockquote>

<p>Next time mau mengetik System.gc, tanyakan pada diri sendiri, apakah saya sudah paham JVM Ergonomics dan bisa menjelaskannya ke orang lain? Kalau jawabannya belum, jangan diteruskan mengetik System.gc().</p>

<blockquote><p>Lalu apa itu <code>System.gc</code> dan kapan digunakan?</p></blockquote>

<p>Kan sudah dijelaskan di atas, pelajari cara kerja garbage collector dan apa itu JVM ergonomics.</p>

<p>Satu lagi salah kaprah yang harus dibenahi :
opsi <code>Xms</code> dan <code>Xmx</code> itu gunanya adalah <strong>UNTUK MEMAKSIMALKAN PENGGUNAAN MEMORI</strong>.
<code>Xms</code> dan <code>Xms</code> <strong>BUKAN SOLUSI UNTUK MASALAH OOM</strong>.</p>

<p>Masalah OOM itu ada di kode program kita sendiri, jadi carilah solusinya di kode program kita sendiri.
Penyebab OOM itu juga cuma satu : aplikasi kita menggunakan memori lebih besar daripada yang tersedia.
Besar pasak daripada tiang.</p>

<ol>
<li>Memori tersedia 4 GB, aplikasi kita pakai 4.1 GB => OOM</li>
<li>Memori tersedia 2 GB, aplikasi kita pakai 1.5 GB => No OOM padahal lebih kecil dari #1</li>
<li>RAM fisik ada 16 GB, tapi aplikasi kita cuma bisa memanfaatkan 2 GB => gunakan <code>Xms</code> dan <code>Xmx</code>.</li>
</ol>


<h1>Penyebab OOM dan Solusinya</h1>

<p>Beberapa penyebab umum terjadinya OOM :</p>

<h2>Unbounded Query</h2>

<p>Unbounded query adalah query yang tidak kita batasi jumlahnya.
Contohnya <code>select * from tbl_penjualan</code>. Kalau data penjualan hanya 1000 transaksi, no problem. Kalau transaksinya ada 10 juta record dalam satu hari, ya pasti langsung kena OOM.</p>

<p>Solusinya : pastikan selalu menggunakan paging. Ganti querynya menjadi <code>select * from tbl_penjualan limit 0,20</code> sehingga cuma mengeluarkan 20 record, berapapun banyaknya data dalam tabel.</p>

<h2>Generate File</h2>

<p>Seringkali kita ingin menghasilkan file report. Misalnya laporan penjualan bulan ini, berapapun data yang ada di tabel untuk periode bulan ini, harus ditulis ke file. File ini bisa berupa PDF, XLS, XML, CSV, dan sebagainya.</p>

<p>Format file tidak masalah. Yang menjadi masalah adalah cara membuatnya. Ada beberapa kesalahan umum :</p>

<ul>
<li>mengumpulkan data di variabel sebelum menulis file</li>
<li>tidak melepas data yang sudah diproses</li>
<li>tidak paham cara kerja report engine</li>
</ul>


<h3>Mengumpulkan data di variabel</h3>

<p>Contoh pseudocode seperti ini</p>

<p>```java
List<Penjualan> data = new ArrayList<Penjualan>();</p>

<p>// resultset adalah cursor, dia hanya baca apa yang ditarik saja
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>while(rs.next()){</p>

<pre><code>Penjualan p = konversiResultSetJadiPenjualan(rs);
data.add(p);
</code></pre>

<p>}
```</p>

<p>Coding di atas akan mengumpulkan semua record di variabel <code>data</code>.
Bila ada 1 juta record yang dihasilkan oleh query dengan masing-masing record berukuran 1 KB,
maka variabel data tersebut akan berukuran 1 GB. Kalau Java VM kita berikan alokasi 2 GB, cuma butuh 3 user untuk menimbulkan OOM.
Menaikkan alokasi menjadi 8 GB melalui <code>Xms</code> dan <code>Xmx</code> tidak akan membantu banyak.</p>

<h3>Tidak melepas data yang sudah diproses</h3>

<p>Ini biasanya terjadi kalau kita menulis sendiri file output. Perhatikan contoh kode berikut:</p>

<p>```java
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>File output = new File("output.csv");
while(rs.next()){</p>

<pre><code>String baris = konversiResultSetJadiString(rs);
output.write(baris);
output.flush();
</code></pre>

<p>}
```</p>

<p>Menulis file ada bermacam-macam. Ada yang menggunakan buffer ada yang tidak. Pastikan kita mengosongkan buffer setiap kali iterasi supaya tidak penuh, biasanya dengan method <code>flush</code> atau sejenisnya.</p>

<h3>Tidak paham cara kerja report engine</h3>

<p>Dalam mendesain library yang dipakai orang banyak, biasanya si pembuat akan melakukan optimasi untuk penggunaan yang sering terjadi.
Misalnya 80% orang membuat PDF berukuran 10 halaman atau lebih sedikit, 20% sisanya membuat 1000 halaman atau lebih.
Pada situasi ini, pembuat library report yang baik pasti akan memudahkan pembuatan 10 halaman report karena itulah fitur yang paling sering digunakan.</p>

<p>Bila kita termasuk golongan yang 20%, kita harus belajar lebih giat supaya paham bagaimana mengatasi kondisi minoritas tersebut.</p>

<p>Sebagai contoh, kalau kita menggunakan Jasper Report, ada fitur yang disebut dengan <a href="http://community.jaspersoft.com/wiki/comparison-report-virtualizers">Virtualizer</a> untuk membuat report berukuran besar. Pastikan kita sudah memahami kasus-kasus khusus ini.</p>

<h2>Inisialisasi object besar di dalam loop</h2>

<p>Perhatikan contoh kode di bawah</p>

<p>```java
public void simpan(Produk p){</p>

<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext("konfig-spring.xml");
ProdukDao pd = ctx.getBean(ProdukDao.class);
pd.save(p);
</code></pre>

<p>}
```</p>

<p><code>ApplicationContext</code> merupakan object Spring Framework yang berisi seluruh konfigurasi aplikasi. Isinya :</p>

<ul>
<li>konfigurasi database</li>
<li>mapping ORM (kalau pakai ORM)</li>
<li>semua object yang dimanage Spring</li>
</ul>


<p>Intinya, ini adalah object yang besar sekali dan sangat kompleks. Object seperti ini biasanya hanya dibuat sekali saja sepanjang aplikasi dijalankan. Bila kita taruh dalam method seperti di atas, maka tiap kali ada user simpan data produk, object besar tersebut akan dibuat, sehingga menghabiskan memori.</p>

<p>Pesan moralnya, pahami library yang digunakan supaya tahu karakteristik dan cara kerjanya.</p>

<h2>Penggunaan collection yang kurang benar</h2>

<p>Collection (Set, Map, List) adalah object yang menampung object lain. Kita harus memastikan bahwa object ini berada dalam scope yang benar. Lihat kode program berikut</p>

<p>```java
public class Coba {</p>

<pre><code>private static List&lt;Integer&gt; noSurat = new ArrayList&lt;Integer&gt;();
private static Integer noTerakhir = 0;

public void bikinSuratBaru(){
    noTerakhir++;
    noSurat.add(noTerakhir);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Pada kode di atas, <code>noSurat</code> memiliki scope static, sehingga dia akan terus ada selama aplikasi berjalan. Bila aplikasi tidak mati dalam waktu yang lama, dan dalam sehari ada 1 juta surat baru, tinggal tunggu waktu saja sampai kena OOM.</p>

<h1>Panduan Solusi Umum</h1>

<p>Selain yang disebutkan di atas, masih banyak penyebab lain, yang paling sering terjadi adalah yang dibahas di atas. Kalau penyebab OOM tidak kita atasi, berapapun memori yang kita sediakan (melalui <code>Xms</code> dan <code>Xmx</code>) tidak akan cukup. Inilah sebabnya saya katakan bahwa <code>Xms</code> dan <code>Xmx</code> itu bukan solusi untuk OOM. Yang harus kita lakukan adalah <strong>mengendalikan pemakaian</strong> memori, bukan <strong>menambah</strong> memori.</p>

<p>Jadi kalau menemukan OOM, coba dicek lagi kode programnya.
Tidak perlu pakai VisualVM atau tools2 lain, cukup code review aja.</p>

<p>Dibaca satu2 source codenya, untuk tiap baris, tanyakan pertanyaan ini :</p>

<ol>
<li>Method/statement ini akan dipanggil seberapa sering?</li>
<li>Looping ini akan berputar maksimal berapa kali?</li>
<li>Berapa kira2 ukuran tiap row yang ditarik dalam query? Sekali tarik berapa row?</li>
<li>Setelah saya tarik row, kapan dia selesai digunakan? Apakah nunggu PDF jadi dulu baru selesai (inilah kandidat OOM), atau tiap selesai satu halaman PDF sudah bisa direlease?</li>
</ol>


<p>Mudah-mudahan dengan adanya artikel ini tidak ada lagi orang yang mengobati OOM dengan <code>System.gc</code> atau <code>Xmx</code>.</p>

<h2>Referensi</h2>

<ul>
<li><a href="http://java.dzone.com/news/how-fix-memory-leaks-java">How to fix memory leaks in Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengetes Akses Database]]></title>
    <link href="http://software.endy.muhardin.com/java/mengetes-akses-database/"/>
    <updated>2013-06-05T11:49:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengetes-akses-database</id>
    <content type="html"><![CDATA[<p>Pada bagian ini, kita akan mempersiapkan seperangkat kode program untuk mengetes aplikasi yang telah kita buat.</p>

<p>Artikel ini merupakan bagian kelima dan terakhir dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h2>Setup Test</h2>

<p>Seperti telah dijelaskan sebelumnya, test class kita akan terdiri dari dua bagian:</p>

<ol>
<li>Abstract superclass : berisi seluruh kode program pengetesan aplikasi</li>
<li>Concrete subclass : berisi kode program untuk melakukan inisialisasi</li>
</ol>


<p>Berikut adalah kerangka abstract superclass test untuk <code>Produk</code></p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import statement, generate menggunakan IDE</p>

<p>public abstract class ProdukServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {

}

@Test
public void testSimpanUpdateHapusProduk() throws Exception {

}

// test method lain tidak ditampilkan
</code></pre>

<p>}
```</p>

<p>Dan berikut ini adalah concrete subclass yang berfungsi melakukan inisialisasi konfigurasi Spring JDBC</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import statement generate menggunakan IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class ProdukServiceSpringJdbcTest extends ProdukServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>Database Reset</h2>

<p>Pada kode program abstract superclass di atas, kita melihat ada method untuk membersihkan data test. Method ini diberikan annotation <code>@Before</code> supaya dia dijalankan <strong>sebelum masing-masing test</strong>.</p>

<p>Berikut adalah isi method tersebut</p>

<p>```java
@Before
public void bersihkanDataTest() throws Exception {</p>

<pre><code>DataSource ds = getDataSource();
Connection conn = ds.getConnection();

String sql = "delete from m_produk where kode like ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setString(1,"T-001%");
ps.executeUpdate();
conn.close();
</code></pre>

<p>}
```</p>

<p>Di method tersebut, kita menghapus semua produk yang kodenya diawali <code>T-001</code>. Ini adalah data yang kita insert selama proses tes. Agar tidak mengganggu tes lainnya, kita hapus data percobaan tersebut.</p>

<h2>Test Insert Update Delete</h2>

<p>Proses insert, update, dan delete mengubah data yang ada dalam database. Supaya kita tidak repot mengurus data sample yang sudah ada di database, ketiga proses ini kita tes dalam satu kesatuan. Dengan demikian, setelah selesai dijalankan, datanya kembali bersih seperti sebelumnya. Berikut kode programnya.</p>

<p>```java
@Test
public void testSimpanUpdateHapusProduk() throws Exception{</p>

<pre><code>Produk p = new Produk();
p.setHarga(new BigDecimal(125000));
p.setKode("T-001");
p.setNama("Produk Test 001");

PenjualanService service = getPenjualanService();
service.simpan(p);
assertNotNull(p.getId());

Connection conn = getDataSource().getConnection();
PreparedStatement psCariById 
        = conn.prepareStatement
            ("select * from m_produk where id = ?");
psCariById.setInt(1, p.getId());
ResultSet rs = psCariById.executeQuery();

// test nilai awal
assertTrue(rs.next());
assertEquals("T-001",rs.getString("kode"));

// update record
p.setKode("T-001x");
service.simpan(p);

// test query setelah update
rs = psCariById.executeQuery();

assertTrue(rs.next());
assertEquals("T-001x",rs.getString("kode"));

// test delete
service.hapus(p);

// test query setelah hapus
rs = psCariById.executeQuery();

assertFalse(rs.next());
</code></pre>

<p>}
```</p>

<p>Dari komentar yang ada dalam kode program, sudah jelas apa maksud dari masing-masing bagian.</p>

<h2>Test Query</h2>

<p>Selanjutnya kita melakukan tes terhadap query. Kita mulai dari yang sederhana dulu, yaitu tabel produk.
Berikut kode program pengetesannya.</p>

<p>```java
@Test
public void testCariProdukById() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukById(1));
assertNull(service.cariProdukById(99));
</code></pre>

<p>}</p>

<p>@Test
public void testCariProdukByKode() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukByKode("K-001"));
assertNull(service.cariProdukByKode("X-001"));
</code></pre>

<p>}</p>

<p>@Test
public void testHitungSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertEquals(Long.valueOf(3), 
    Long.valueOf(service.hitungSemuaProduk()));
</code></pre>

<p>}</p>

<p>@Test
public void testCariSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
List&lt;Produk&gt; hasil = service.cariSemuaProduk(1, 100);
assertNotNull(hasil);
assertTrue(hasil.size() == 3);
for (Produk produk : hasil) {
    assertNotNull(produk.getId());
    assertNotNull(produk.getKode());
    assertNotNull(produk.getNama());
    assertNotNull(produk.getHarga());
}
</code></pre>

<p>}
```</p>

<p>Logika pengetesan tidak kompleks. Kita query datanya menggunakan method di <code>ProdukDao</code> yang telah kita buat,
lalu kita bandingkan dengan kondisi yang seharusnya. Perbandingan dilakukan menggunakan method yang telah disediakan JUnit, yaitu method berawalan <code>assert</code>, misalnya <code>assertNotNull</code>, <code>assertEquals</code>, dan lainnya.</p>

<p>Yang harus diperhatikan di sini adalah, kita harus benar-benar tahu persis isi database supaya test ini bisa berjalan dengan baik. Ada banyak teknik yang bisa digunakan untuk memastikan isi database sebelum tes dijalankan, salah satunya menggunakan tools yang bernama <a href="http://www.dbunit.org/">DBUnit</a>. Lebih lanjut tentang cara menggunakan DBUnit bisa dibaca di <a href="http://software.endy.muhardin.com/java/ruthless-testing-4/">artikel ini</a>.</p>

<h2>Test Relasi</h2>

<p>Pengetesan terhadap relasi pada prinsipnya tidak berbeda. Hanya ada sedikit tambahan yaitu kita juga harus memastikan apakah relasinya berhasil terisi dengan sempurna. Berikut pengetesannya.</p>

<p>```java
@Test</p>

<pre><code>public void testCariPenjualanDetailByProdukDanPeriode(){
Produk p = new Produk();
p.setId(1);

Date mulai = new DateTime(2013,1,1,0,0,0,0).toDate();
Date sampai = new DateTime(2013,2,1,0,0,0,0).toDate();

List&lt;PenjualanDetail&gt; hasil = getPenjualanService()
        .cariPenjualanDetailByProdukDanPeriode(p, 
            mulai, sampai, 1, 100);

assertNotNull(hasil);
assertTrue(hasil.size() == 2);

for (PenjualanDetail penjualanDetail : hasil) {
    verifikasiPenjualanDetail(penjualanDetail);
}
</code></pre>

<p>}
```</p>

<p>Pada kode program di atas, terlihat bahwa kita melakukan looping yang di dalamnya ada verifikasi <code>PenjualanDetail</code>. Berikut isi methodnya.</p>

<p>```java
private void verifikasiPenjualanDetail</p>

<pre><code>    (PenjualanDetail penjualanDetail) {
assertNotNull(penjualanDetail.getProduk().getHarga());
assertNotNull(penjualanDetail.getPenjualan().getWaktuTransaksi());
</code></pre>

<p>}
```</p>

<p>Kita cukup memastikan bahwa relasi yang dimiliki <code>PenjualanDetail</code> yaitu <code>Produk</code> dan <code>Penjualan</code> tidak null. Demikian juga variabel yang ada di dalam objectnya yaitu <code>harga</code> dan <code>waktuTransaksi</code>.</p>

<p>Demikianlah rangkaian artikel tentang penggunaan Spring JDBC. Kode program selengkapnya dapat diambil <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc">di Github</a>.
Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Query dengan Spring JDBC]]></title>
    <link href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/"/>
    <updated>2013-06-03T20:08:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/query-dengan-spring-jdbc</id>
    <content type="html"><![CDATA[<p>Pada artikel sebelumnya kita telah bisa mengubah data dalam database, baik menambah (insert), mengubah (update), maupun menghapus (data). Kali ini kita akan membahas tentang cara pengambilan data (select) dari dalam database.</p>

<p>Artikel ini merupakan bagian keempat dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<p>Pada dasarnya, untuk mengambil data dari database hanya ada dua varian yang kita gunakan, yaitu:</p>

<ul>
<li>mengambil data tunggal, gunakan method <code>queryForObject</code></li>
<li>mengambil data banyak, gunakan method <code>queryForList</code> atau <code>query</code> saja</li>
</ul>


<p>Kita lihat dulu implementasi yang paling mendasar, ambil semua data produk dari database. Berikut deklarasi SQLnya.</p>

<p>```java
private static final String SQL_CARI_SEMUA</p>

<pre><code>= "select * from m_produk limit ?,?";
</code></pre>

<p>```</p>

<p>Perintah SQL di atas akan dipakai dalam method <code>cariSemua</code> sebagai berikut</p>

<p>```java
public List<Produk> cariSemua(Integer halaman, Integer baris) {</p>

<pre><code>return jdbcTemplate.query(SQL_CARI_SEMUA,
        new ResultSetJadiProduk(),
        PagingHelper.halamanJadiStart(halaman, baris),
        baris);
</code></pre>

<p>}
```</p>

<p>Pada contoh di atas, kita menggunakan method <code>query</code> yang menerima tiga argumen, yaitu:</p>

<ul>
<li>SQL yang akan dijalankan, berupa String</li>
<li>Class yang bertugas mengubah ResultSet menjadi object yang kita inginkan, dalam hal ini object <code>Produk</code>. Class ini akan kita buat sendiri, yaitu class <code>ResultSetJadiProduk</code>.</li>
<li>argumen lain-lain (varargs). Ini merupakan fitur Java sejak versi 5 yang artinya kita bisa memasukkan argumen sebanyak-banyaknya dalam method. Argumen ini akan dikonversi menjadi List untuk diproses oleh method <code>query</code></li>
</ul>


<p>Jadi, bukan salah ketik kalau di atas saya sebut tiga argumen padahal kita memasukkan empat variabel ke dalamnya.</p>

<p>SQL select tentu tidak perlu kita bahas lagi, mari masuk ke class <code>ResultSetJadiProduk</code></p>

<h2>Membuat Mapper</h2>

<p>Class <code>ResultSetJadiProduk</code> bertugas mengkonversi hasil query ke database yang ada dalam class <code>ResultSet</code> menjadi object <code>Produk</code>. Implementasinya tidak rumit, ini dia.</p>

<p>```java
private class ResultSetJadiProduk implements RowMapper<Produk> {</p>

<pre><code>@Override
public Produk mapRow(ResultSet rs, int i) throws SQLException {
    Produk p = new Produk();
    p.setId((Integer) rs.getObject("id"));
    p.setKode(rs.getString("kode"));
    p.setNama(rs.getString("nama"));
    p.setHarga(rs.getBigDecimal("harga"));
    return p;
}
</code></pre>

<p>}
```</p>

<p>Kita membuatnya sebagai class di dalam class (inner class). Kalau lupa dengan strukturnya, silahkan baca lagi bab dua tentang Struktur Aplikasi.</p>

<p>Class ini harus implement interface <code>RowMapper&lt;T&gt;</code> milik Spring. <code>T</code> diganti dengan class yang menjadi tujuan konversi. Interface <code>RowMapper&lt;T&gt;</code> ini mewajibkan kita membuat method <code>mapRow</code>. Isi method tersebut sudah cukup jelas sehingga tidak perlu dijelaskan.</p>

<p>Class ini nantinya bisa kita gunakan juga di query yang menghasilkan satu object <code>Produk</code> seperti <code>cariById</code> dan <code>cariByKode</code>. Berikut implementasinya</p>

<p>```java
public Produk cariById(Integer id) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiProduk(), id);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}</p>

<p>public Produk cariByKode(String kode) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_KODE, 
        new ResultSetJadiProduk(), kode);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Kedua method ini sama saja prinsipnya dengan <code>cariSemua</code> yang sudah kita bahas sebelumnya.</p>

<h2>Mengambil data berelasi</h2>

<p>Setelah berhasil mengambil data dari satu produk, mari kita coba untuk berurusan dengan data berelasi. Sebetulnya prinsipnya sama saja, yaitu membuatkan class konversi. Bedanya hanya terletak pada query SQL yang menggunakan join, tidak ada hubungannya dengan Spring JDBC.</p>

<p>Pada service interface, kita memiliki fitur rekap transaksi untuk satu produk tertentu, yang dimuat dalam method <code>cariPenjualanDetailByProdukDanPeriode</code>. Method tersebut memanggil method <code>cariByProdukDanPeriode</code> dalam class <code>PenjualanDetailDao</code>. Berikut implementasinya.</p>

<p>```java
public class PenjualanDetailDao {</p>

<pre><code>private static final String SQL_CARI_BY_PRODUK_DAN_PERIODE 
        = "select pd.*, p.waktu_transaksi, "
        + "produk.kode as kode_produk, produk.nama as nama_produk,"
        + "produk.harga as harga_produk "
        + "from t_penjualan_detail pd "
        + "inner join t_penjualan p on pd.id_penjualan = p.id "
        + "inner join m_produk produk on pd.id_produk = produk.id " 
        + "where pd.id_produk = ? " +
        + "and (p.waktu_transaksi between ? and ?) " +
        + "limit ?,?";

public List&lt;PenjualanDetail&gt; cariByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai, Integer halaman, Integer baris) {
    return jdbcTemplate.query(SQL_CARI_BY_PRODUK_DAN_PERIODE, 
            new ResultSetJadiPenjualanDetail(), 
            p.getId(), 
            mulai, 
            sampai, 
            PagingHelper.halamanJadiStart(halaman, baris), 
            baris);
}
</code></pre>

<p>}
```</p>

<p>Konversi dari <code>ResultSet</code> menjadi <code>PenjualanDetail</code> dilakukan dalam class <code>ResultSetJadiPenjualanDetail</code> berikut</p>

<p>```java
private class ResultSetJadiPenjualanDetail</p>

<pre><code>    implements RowMapper&lt;PenjualanDetail&gt; {

@Override
public PenjualanDetail mapRow(ResultSet rs, int i) 
        throws SQLException {
    PenjualanDetail p = new PenjualanDetail();
    p.setId((Integer) rs.getObject("id"));
    p.setHarga(rs.getBigDecimal("harga"));
    p.setJumlah((Integer) rs.getObject("jumlah"));

    // relasi ke produk
    Produk px = new Produk();
    px.setId((Integer) rs.getObject("id_produk"));
    px.setKode(rs.getString("kode_produk"));
    px.setNama(rs.getString("nama_produk"));
    px.setHarga(rs.getBigDecimal("harga_produk"));
    p.setProduk(px);

    // relasi ke penjualan
    Penjualan jual = new Penjualan();
    jual.setId((Integer) rs.getObject("id_penjualan"));
    jual.setWaktuTransaksi(rs.getDate("waktu_transaksi"));
    p.setPenjualan(jual);

    return p;
}
</code></pre>

<p>}
```</p>

<p>Selain class <code>PenjualanDetail</code> itu sendiri, kita juga membuatkan object <code>Produk</code> dan <code>Penjualan</code> yang kemudian akan dipasang pada object <code>PenjualanDetail</code>.</p>

<h2>Pagination</h2>

<p>Dalam mengambil data yang berjumlah banyak seperti data transaksi, biasanya kita akan melakukan <em>pagination</em>, yaitu membagi data menjadi beberapa halaman. Di MySQL, kita menggunakan keyword <code>LIMIT</code> untuk melakukan hal ini. Keyword <code>LIMIT</code> menerima dua argumen, yaitu nomer record pertama yang mau diambil dan jumlah record yang mau diambil. Jadi bila kita ingin mengambil record 11 - 15, kita menggunakan keyword <code>LIMIT 11, 5</code>.</p>

<p>Ini agak berbeda dengan argumen yang diterima dalam method pencarian kita. Yang diminta di situ adalah nomer halaman dan jumlah record per halaman. Jadi kalau misalnya data kita berjumlah 56 record dan kita ingin setiap halaman berisi 10 record, maka data tersebut akan terbagi menjadi 6 halaman. Bila kita ingin mengambil halaman terakhir, kita memberikan argumen <code>6</code> dan <code>10</code> ke dalam method pencarian.</p>

<p>Tentunya harus ada konversi dari nomer halaman menjadi nomer baris. Ini kita lakukan di class <code>PagingHelper</code> yang isinya sebagai berikut.</p>

<p>```java
public class PagingHelper {</p>

<pre><code>public static Integer halamanJadiStart(Integer halaman, 
        Integer baris){
    if (halaman &lt; 1) {
        return 0;
    }
    return (halaman - 1) * baris;
}
</code></pre>

<p>}
```</p>

<h2>Header Detail</h2>

<p>Dalam aplikasi, pasti ada fitur untuk menampilkan daftar transaksi dalam periode tertentu.
Seperti sudah kita bahas, satu transaksi terdiri dari satu header dan beberapa detail.
Data ini tentu ingin kita ambil semua.</p>

<p>Caranya sederhana :</p>

<ol>
<li>Query dulu headernya: <code>select * from t_penjualan where id = ?</code></li>
<li>Query detailnya: <code>select * from t_penjualan_detail where id_penjualan = ?</code></li>
<li>Gabungkan keduanya</li>
</ol>


<p>Berikut contohnya, pada waktu kita ingin mencari <code>Penjualan</code> berdasarkan <code>id</code></p>

<p>```java
public Penjualan cariById(Integer id) {</p>

<pre><code>try {
    Penjualan p = jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiPenjualan(), id);
    List&lt;PenjualanDetail&gt; daftarDetail = penjualanDetailDao
        .cariByPenjualan(p);
    p.setDaftarPenjualanDetail(daftarDetail);
    return p;
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Di sana, kita memanggil method <code>cariByPenjualan</code> yang ada di class <code>PenjualanDetailDao</code>. Berikut kode programnya</p>

<p>```java
public List<PenjualanDetail> cariByPenjualan(Penjualan p){</p>

<pre><code>List&lt;PenjualanDetail&gt; hasil 
    = jdbcTemplate.query(SQL_CARI_BY_ID_PENJUALAN, 
        new ResultSetJadiPenjualanDetail(), p.getId());

// set relasi ke penjualan
for (PenjualanDetail penjualanDetail : hasil) {
    penjualanDetail.setPenjualan(p);
}

return hasil;
</code></pre>

<p>}
```</p>

<p>Kembali ke <code>PenjualanDao</code>, setelah kita mendapatkan <code>List&lt;PenjualanDetail&gt;</code> dari method di atas, kita pasang di object penjualan yang sudah kita dapatkan di baris ini</p>

<p><code>java
p.setDaftarPenjualanDetail(daftarDetail);
</code></p>

<p>Demikianlah cara kita mengambil data dari database menggunakan Spring JDBC.
Hal ini tentu tidak rumit asalkan kita sudah paham dasar-dasar SQL termasuk cara melakukan join antar tabel.
Jadi kesimpulannya, untuk mengambil data menggunakan Spring JDBC, yang perlu kita lakukan hanyalah:</p>

<ol>
<li>Membuat SQL, lengkap dengan join bila perlu. Contohnya bisa dilihat di class <code>PenjualanDetailDao</code> yang memiliki banyak join.</li>
<li>Membuat class untuk mengkonversi dari <code>ResultSet</code> menjadi object yang kita inginkan, misalnya <code>Produk</code> atau <code>Penjualan</code></li>
</ol>


<p>Pada bagian selanjutnya, kita tinggal <a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">mengetes kode program</a> yang telah kita buat ini.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert Update Delete dengan Spring JDBC]]></title>
    <link href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/"/>
    <updated>2013-05-31T13:26:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc</id>
    <content type="html"><![CDATA[<p>Setelah pada artikel sebelumnya kita membuat konfigurasi database dan membuat kerangka aplikasi, kali ini kita akan membuat implementasi akses database menggunakan Spring JDBC.</p>

<p>Artikel ini merupakan bagian ketiga dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h1>Setup DAO</h1>

<p>Supaya bisa diinisialisasi oleh Spring Framework, kita harus menambahkan annotation <code>@Repository</code> di class <code>ProdukDao</code> dan juga class DAO lainnya. Pembahasan lebih detail tentang cara kerja Spring Framework dan fungsinya annotation <code>@Repository</code> dapat dibaca <a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">di artikel ini</a>.</p>

<p>Selanjutnya, kita akan menambahkan beberapa variabel yang nantinya akan kita butuhkan, yaitu <code>JdbcTemplate</code> dan perintah SQL yang ingin dijalankan.</p>

<h2>JDBC Template</h2>

<p><code>JdbcTemplate</code> adalah class utama dalam Spring JDBC. Semua operasi database dilakukan melalui JdbcTemplate. Kita juga butuh rekannya yang bernama <code>NamedParameterJdbcTemplate</code>. Kelebihan dari <code>NamedParameterJdbcTemplate</code> ini, dia bisa menerima SQL dengan variabel yang diberi nama. Tanpa dia, kita cuma bisa menjalankan SQL yang variabelnya ditandai dengan <code>?</code>, sehingga membingungkan dan rawan terjadi kesalahan kalau jumlah variabelnya banyak.</p>

<p>Kedua object ini kita deklarasikan menjadi object/instance variable, supaya bisa digunakan oleh semua method. Inisialisasinya membutuhkan object <code>DataSource</code>, sehingga sebaiknya kita lakukan inisialisasi di dalam setter injection. Bagi yang belum paham apa itu setter injection silahkan baca dulu <a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">artikel ini</a>.</p>

<p>Berikut adalah kode programnya.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private JdbcTemplate jdbcTemplate;
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}
</code></pre>

<p>}
```</p>

<h2>SQL</h2>

<p>Agar lebih rapi, semua perintah SQL yang kita akan gunakan di dalam method sebaiknya kita deklarasikan sebagai konstanta. Berikut adalah berbagai SQL yang kita gunakan.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private static final String SQL_INSERT = "insert into m_produk (kode,nama,harga) values (:kode,:nama,:harga)";
private static final String SQL_CARI_BY_ID = "select * from m_produk where id = ?";
private static final String SQL_CARI_BY_KODE = "select * from m_produk where kode = ?";
private static final String SQL_HITUNG_SEMUA = "select count(*) from m_produk";
private static final String SQL_CARI_SEMUA = "select * from m_produk limit ?,?";
private static final String SQL_HITUNG_BY_NAMA = "select count(*) from m_produk where lower(nama) like ?";
private static final String SQL_CARI_BY_NAMA = "select * from m_produk where lower(nama) like ? limit ?,?";
</code></pre>

<p>}
```</p>

<p>Harap diperhatikan bahwa saya hanya menampilkan potongan kode program yang berkaitan dengan penjelasan saat ini saja, berikut sedikit tambahan supaya jelas di mana penempatannya. Untuk isi kode program yang lengkap silahkan lihat <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc/src/main/java/com/muhardin/endy/training/java/aksesdb/dao/springjdbc">di Github</a>.</p>

<h1>Insert Data</h1>

<p>Setelah kita punya <code>JdbcTemplate</code> dan perintah SQL, kita bisa gunakan untuk menyimpan data ke database.
Mari kita implement method <code>simpan</code>.</p>

<h2>Menggunakan parameter domain object</h2>

<p>Class <code>Produk</code> memiliki properti yang bernama <code>kode</code>, <code>nama</code>, dan <code>harga</code>. Karena kita mengikuti aturan penamaan yang baku, maka kita buatkan method getter dan setter. Class yang dibuat mengikuti standar ini bisa langsung diproses oleh Spring JDBC. Dia akan secara otomatis memasangkan properti yang namanya sama dengan yang ada di perintah SQL. Jadi perintah SQL seperti ini</p>

<p><code>sql
insert into m_produk (kode,nama,harga) values (:kode,:nama,:harga)
</code></p>

<p>Akan diisikan dengan nilai yang didapat dari pemanggilan method berikut:</p>

<p>```java
Produk p; // nantinya p diisi dari method parameter</p>

<p>p.getKode();
p.getNama();
p.getHarga();
```</p>

<p>Spring JDBC juga akan secara otomatis mendeteksi tipe data baik itu <code>Integer</code>, <code>String</code>, <code>BigDecimal</code>, dan sebagainya.</p>

<p>Berikut adalah implementasi method <code>simpan</code> yang menggunakan konsep di atas.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(p);
KeyHolder keyHolder = new GeneratedKeyHolder();
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></pre>

<p>}
```</p>

<p><code>BeanPropertySqlParameterSource</code> adalah class dari Spring JDBC yang berfungsi mengambil parameter dari Java object seperti telah dijelaskan di atas. Selain mengambil dari object dengan getter dan setter, ada lagi class lain yang bernama <code>MapSqlParameterSource</code>, digunakan untuk mengambil parameter dari object bertipe <code>java.util.Map</code>.</p>

<h2>Mendapatkan nilai yang auto generated</h2>

<p>Di tabel <code>m_produk</code>, primary key ada di kolom <code>id</code>. Nilainya digenerate otomatis oleh database pada saat kita melakukan insert. Kita perlu mengetahui nilai berapa yang dibuatkan database untuk data yang barusan kita insert agar bisa dipasang di object <code>Produk</code> yang kita insert. Untuk menampung nilai yang otomatis dibuatkan database, kita menggunakan class <code>GeneratedKeyHolder</code>.</p>

<p>Setelah kita melakukan insert, <code>keyHolder</code> akan menampung nilai. Nilai inilah yang kita pasang di object produk dengan kode program berikut.</p>

<p><code>java
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></p>

<h2>Menggunakan SimpleJdbcInsert</h2>

<p>Object <code>produk</code> di atas hanya memiliki 4 property di Java dan 4 kolom di database. Bila propertynya banyak, tentu kita akan kerepotan menulis variabel dalam perintah SQL. Untuk membantu kita, Spring JDBC menyediakan fitur <code>SimpleJdbcInsert</code>. Cara kerjanya, dia akan <em>menanyakan</em> ke database kolom apa saja yang ada di tabel tertentu berikut tipe data untuk masing-masing kolom. Setelah itu, informasi tersebut digunakan untuk membuatkan SQL insert buat kita, sehingga kita tidak perlu membuat sendiri.</p>

<p>Berikut adalah cara inisialisasi <code>SimpleJdbcInsert</code>, dilakukan di setter injection.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private SimpleJdbcInsert insertProduk;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.insertProduk = new SimpleJdbcInsert(dataSource)
            .withTableName("m_produk")
            .usingGeneratedKeyColumns("id");
}
</code></pre>

<p>}
```</p>

<p>Kita menyebutkan juga kolom mana yang nilainya digenerate database, sehingga dia bisa mengambilkannya. Selanjutnya, mari kita ganti implementasi method <code>simpan</code> dengan memanfaatkan <code>SimpleJdbcInsert</code>.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>SqlParameterSource produkParameter = new BeanPropertySqlParameterSource(p);
Number idBaru = insertProduk.executeAndReturnKey(produkParameter);
p.setId(idBaru.intValue());
</code></pre>

<p>}
```</p>

<h2>Insert Data Header dan Detail</h2>

<p><blockquote><p>Kenapa kita perlu mengambil primary key yang digenerate database?</p></blockquote></p>

<p>Jawabannya karena kita membutuhkannya dalam skenario header dan detail. Di tabel detail, ada relasi foreign key ke tabel header. Sehingga untuk mengisi foreign key tersebut, kita harus mengetahui dulu primary key header.</p>

<p>Selain masalah foreign key ini, sisanya sama dengan pembahasan insert sebelumnya. Berikut implementasi method <code>simpan(Penjualan p)</code></p>

<p>```java
public void simpan(Penjualan p) {</p>

<pre><code>SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(p);
KeyHolder keyHolder = new GeneratedKeyHolder();
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());

for (PenjualanDetail detail : p.getDaftarPenjualanDetail()) {
    detail.setPenjualan(p);
    penjualanDetailDao.simpan(detail);
}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat pada kode program di atas, kita insert ke tabel <code>t_penjualan</code>, kemudian kita ambil nilai <code>id</code>. Nilai tersebut kita isikan ke tiap object detail untuk selanjutnya kita insert juga menggunakan method <code>simpan(PenjualanDetail pd)</code> di class <code>PenjualanDetailDao</code>. Berikut implementasinya.</p>

<p>```java
public void simpan(final PenjualanDetail p) {</p>

<pre><code>KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(new PreparedStatementCreator() {

    @Override
    public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {
        PreparedStatement ps = conn.prepareStatement(SQL_INSERT, new String[]{"id"});
        ps.setInt(1, p.getPenjualan().getId());
        ps.setInt(2, p.getProduk().getId());
        ps.setBigDecimal(3, p.getHarga());
        ps.setInt(4, p.getJumlah());
        return ps;
    }
}, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></pre>

<p>}
```</p>

<p>Pada waktu menyimpan <code>PenjualanDetail</code>, kita menggunakan teknik yang agak berbeda, tidak menggunakan <code>SimpleJdbcInsert</code> maupun <code>NamedParameterJdbcTemplate</code>. Ini disebabkan karena banyak kolom yang namanya tidak mengikuti aturan penamaan, yaitu <code>id_penjualan</code> dan <code>id_produk</code>. Karena itu kita menggunakan cara yang lebih manual, membuat sendiri <code>PreparedStatement</code> dan kemudian mengisi parameternya.</p>

<p>Walaupun demikian, kita tidak mengeksekusi <code>PreparedStatement</code> tersebut, karena urusan mengeksekusi akan ditangani Spring JDBC supaya bisa dibungkus dalam transaction. Kenapa harus dibungkus dalam transaction? Jawabannya bisa dibaca di <a href="http://software.endy.muhardin.com/java/database-transaction/">artikel ini</a>.</p>

<h1>Update Data</h1>

<p>Pada prinsipnya, update data tidak berbeda dengan insert data. Kita dapat melakukannya dengan cara yang sama seperti insert data di atas. Tapi karena kita ingin melihat fitur-fitur Spring JDBC, baiklah kita lakukan dengan cara yang sedikit berbeda.</p>

<h2>Menggunakan parameter bertipe Map</h2>

<p>Kalau di atas kita sudah menggunakan parameter menggunakan <code>?</code> dan domain object, kali ini kita akan menggunakan <code>Map</code>. Cara ini digunakan bila nama variabel di SQL berbeda dengan nama variabel di domain object, sehingga kita tidak bisa menggunakan <code>BeanPropertySqlParameterSource</code>. Kita juga tidak mau menggunakan <code>?</code> karena rawan terjadi salah ketik.</p>

<p>Kita ubah sedikit method <code>simpan(Produk p )</code> agar bisa menangani penyimpanan data produk baru (insert) maupun penyimpanan data produk lama (update). Berikut kode program method <code>simpan(Produk p )</code> yang baru.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>if (p.getId() == null) {
    SqlParameterSource produkParameter = new BeanPropertySqlParameterSource(p);
    Number idBaru = insertProduk.executeAndReturnKey(produkParameter);
    p.setId(idBaru.intValue());
} else {
    SqlParameterSource produkParameter = new MapSqlParameterSource()
            .addValue("id_produk", p.getId())
            .addValue("kode_produk", p.getKode())
            .addValue("nama_produk", p.getNama())
            .addValue("harga_produk", p.getHarga());
    namedParameterJdbcTemplate.update(SQL_UPDATE_PRODUK, produkParameter);
}
</code></pre>

<p>}
```</p>

<p>Agar lebih jelas, kita tampilkan juga deklarasi <code>SQL_UPDATE_PRODUK</code>.</p>

<p>```java
private static final String SQL_UPDATE_PRODUK</p>

<pre><code>= "update m_produk set kode = :kode_produk, nama = :nama_produk, harga = :harga_produk where id = :id_produk";
</code></pre>

<p>```</p>

<p>Penggunaan <code>MapSqlParameterSource</code> dapat dilihat di blok <code>else</code>. Argumen kiri dari method <code>addValue</code> adalah nama variabel dalam <code>SQL_UPDATE_PRODUK</code>, sedangkan argumen kanan adalah nilai yang ingin diisikan.</p>

<h1>Delete Data</h1>

<p>Bila kita sudah menguasai insert dan update, maka delete seharusnya tidak menjadi masalah. Berikut kode program untuk menghapus data produk.</p>

<p>```java
public void hapus(Produk p) {</p>

<pre><code>jdbcTemplate.update(SQL_HAPUS, p.getId());
</code></pre>

<p>}
```</p>

<p>Berikut deklarasi <code>SQL_HAPUS</code></p>

<p><code>java
private static final String SQL_HAPUS = "delete from m_produk where id = ?";
</code></p>

<p>Menghapus <code>penjualan</code> yang memiliki relasi header detail juga tidak sulit. Pastikan kita menghapus detailnya dulu sebelum menghapus headernya agar tidak terjadi pelanggaran <a href="http://en.wikipedia.org/wiki/Referential_integrity">referential integrity</a>.</p>

<p>Berikut contoh pesan error bila kita menghapus data produk yang sudah dipakai dalam transaksi.</p>

<p><code>
org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback;
SQL [delete from m_produk where id = ?];
Cannot delete or update a parent row:
a foreign key constraint fails (`belajar`.`t_penjualan_detail`,
CONSTRAINT `t_penjualan_detail_ibfk_2` FOREIGN KEY (`id_produk`)
REFERENCES `m_produk` (`id`));
nested exception is
com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException:
Cannot delete or update a parent row:
a foreign key constraint fails (`belajar`.`t_penjualan_detail`,
CONSTRAINT `t_penjualan_detail_ibfk_2` FOREIGN KEY (`id_produk`)
REFERENCES `m_produk` (`id`))
</code></p>

<p>Pada pesan error di atas, data <code>produk</code> tidak bisa dihapus karena sudah digunakan sebagai relasi foreign key dari <code>penjualan detail</code>.</p>

<p>Demikianlah penjelasan tentang insert, update, dan delete data. Nantikan <a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">bagian selanjutnya</a> yang membahas tentang query select.</p>
]]></content>
  </entry>
  
</feed>
