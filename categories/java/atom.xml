<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2014-10-25T09:49:22+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tips Meletakkan File Konfigurasi Aplikasi]]></title>
    <link href="http://software.endy.muhardin.com/java/tips-meletakkan-file-konfigurasi-aplikasi/"/>
    <updated>2014-09-08T14:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/tips-meletakkan-file-konfigurasi-aplikasi</id>
    <content type="html"><![CDATA[<p>Dalam membuat aplikasi, biasanya ada nilai variabel yang ingin kita simpan di file konfigurasi, supaya pada saat isinya berubah tidak perlu melakukan kompilasi ulang. Misalnya konfigurasi koneksi database. Alamat database server, username, dan password biasanya sering berubah, tergantung tempat di mana aplikasi dideploy.</p>

<p>Ada beberapa hal yang biasanya menjadi pertanyaan, yaitu:</p>

<ol>
<li>Di mana sebaiknya kita menyimpan file tersebut?</li>
<li>Bagaimana caranya supaya aplikasi kita portable? Portable artinya bisa dicopy paste ke berbagai komputer dengan lokasi folder berbeda-beda.</li>
<li>Bagaimana cara membaca file konfigurasi tersebut?</li>
</ol>


<p>Pertanyaan ini diajukan salah satu member di grup <a href="https://www.facebook.com/groups/netbeans.id/?fref=nf">Netbeans Indonesia</a></p>

<p>Berikut screenshot kode program yang sudah dia buat</p>

<p><img src="https://lh4.googleusercontent.com/-5j9PxOw3oUM/VA1UZR2oPRI/AAAAAAAAGpM/FxnUMInN8ME/w660-h312-no/error-load-file.jpg"></p>

<!--more-->


<h2>Lokasi File Konfigurasi</h2>

<p>Kita jawab dulu tentang tempat menaruh file konfigurasi. Ada tiga lokasi utama yang umum digunakan orang, yaitu:</p>

<ul>
<li><p>folder konfigurasi global. Kalau di Linux biasanya di folder <code>/etc</code>. Di Windows biasanya dalam folder <code>system32</code>. Konfigurasi yang disimpan di sini biasanya berlaku global dalam satu komputer. Nilainya terlihat dan digunakan oleh semua user komputer.</p></li>
<li><p>folder tempat aplikasi terinstal. Di Linux orang biasanya menginstal aplikasi di <code>/opt</code>, <code>/usr/local</code>, atau di home foldernya. Di Windows biasanya dalam <code>C:\Program Files</code></p></li>
<li><p>folder home masing-masing user. Di Linux biasanya <code>/home/namauser</code>, misalnya <code>/home/endy</code>. Di Windows, tergantung versinya. Windows 7 ke atas ada di <code>C:\Users\namauser</code>. Windows XP ada di <code>C:\Documents and Settings\namauser</code></p></li>
</ul>


<blockquote><p>Wuah banyak sekali.. Lalu kita pilih yang mana?</p></blockquote>

<p><a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">Aplikasi yang baik</a>, menggunakan tiga-tiganya dengan urutan prioritas yang berbeda-beda. Pertama dia akan mencari ke folder konfigurasi global. Kalau ada, maka nilainya akan digunakan. Selanjutnya, dia lihat ke folder tempat aplikasi terinstal. Terakhir, baru dia lihat ke folder home usernya.</p>

<blockquote><p>Lalu bagaimana kalau di ketiga tempat konfigurasi diisi dengan nilai berbeda?</p></blockquote>

<p>Misalnya username database, nilainya terisi di ketiga tempat tersebut. Username mana yang dipakai aplikasi?</p>

<p>Kebiasaan yang berlaku adalah, yang lebih spesifik lebih diutamakan daripada yang umum. Dalam hal ini, setting username di home lebih menang daripada setting username di folder aplikasi. Bila ada setting username di folder aplikasi dan folder konfigurasi global, maka yang dipakai adalah yang di folder aplikasi.</p>

<h2>Cara Membaca Konfigurasi</h2>

<p>Karena ada tiga tempat:</p>

<ul>
<li>folder global</li>
<li>folder instalasi</li>
<li>folder home</li>
</ul>


<p>Maka cara membacanya juga berbeda-beda. Sebagai ilustrasi, misalnya nama filenya sama, yaitu <code>config.txt</code>. Cuma lokasinya saja yang berbeda.</p>

<h3>Folder Global</h3>

<p>Folder global biasanya sama antar komputer. Dia hanya akan berbeda kalau sistem operasinya berbeda (Windows vs Linux). Tapi dalam sesama sistem operasi, biasanya tetap sama, misalnya folder <code>/etc</code> ada di seluruh Linux. Demikian juga dengan folder <code>C:\Windows\System32</code>.</p>

<p>Karena nama foldernya sama, kita bisa langsung load menggunakan absolute path seperti ini</p>

<p><code>java
File konfig = new File("/etc/config.txt");
</code></p>

<p>atau di Windows</p>

<p><code>java
File konfig = new File("C:\\Windows\\System32\\config.txt");
</code></p>

<p>Jangan lupa menggunakan escape character, karena karakter backslash (\) memiliki arti khusus.</p>

<h3>Folder Aplikasi</h3>

<p>Kalau di Java, biasanya file konfigurasi akan disimpan di dalam file jar atau dalam folder yang terdaftar dalam <code>CLASSPATH</code> seperti misalnya <code>WEB-INF/classes</code> dalam aplikasi web.</p>

<p>Folder atau jar yang terdaftar dalam CLASSPATH memiliki keistimewaan, yaitu bisa diakses dengan mengacu pada class yang memanggilnya. Misalnya kita memiliki deklarasi class seperti ini</p>

<p>```java
package belajar.java;</p>

<p>public class BacaKonfig {</p>

<pre><code>public static void main(String[] xx){

}
</code></pre>

<p>}
```</p>

<p>Bila file <code>config.txt</code> ada dalam folder <code>belajar</code> dalam jar atau CLASSPATH, maka kita bisa akses sebagai berikut</p>

<p>```java
package belajar.java;</p>

<p>public class BacaKonfig {</p>

<pre><code>public static void main(String[] xx){
    InputStream konfig = BacaKonfig.class.getResourceAsStream("/belajar/config.txt");
}
</code></pre>

<p>}
```</p>

<p>Dengan method <code>getResourceAsStream</code>, di manapun lokasi file atau foldernya tidak masalah. Yang penting terdaftar dalam CLASSPATH. Metode ini biasa saya gunakan untuk membaca file-file template cetakan dan laporan (misalnya file jrxml-nya Jasper Report).</p>

<h3>Folder Home</h3>

<p>Sebagai ilustrasi, file <code>config.txt</code> kita taruh dalam folder aplikasi dalam home user. Di Linux ini artinya <code>/home/endy/aplikasi-saya/config.txt</code>. Di Windows 7 namanya adalah <code>C:\Users\endy\aplikasi-saya\config.txt</code>.</p>

<p>Untuk membaca file tersebut, pertama kita harus dapatkan dulu lokasi sebenarnya dari home user</p>

<p><code>java
String lokasiHome = System.getProperty("user.home");
</code></p>

<p>Setelah itu, baru kita load filenya. Pastikan kita menggunakan konstanta <code>File.separator</code> untuk mengatasi perbedaan separator folder di Linux (<code>/</code>) dan Windows (<code>\</code>).</p>

<p><code>java
File konfig = new File(lokasiHome + File.separator + "config.txt");
</code></p>

<h2>Kesimpulan</h2>

<p>Demikianlah <em>best-practices</em> dalam menaruh dan membaca file konfigurasi. Jangan lupa tujuan utamanya adalah supaya aplikasi kita portable (bisa berjalan di berbagai kondisi dan lokasi).</p>

<p>Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memahami Authentication]]></title>
    <link href="http://software.endy.muhardin.com/java/memahami-authentication/"/>
    <updated>2014-07-26T23:49:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/memahami-authentication</id>
    <content type="html"><![CDATA[<p>Menjelang penghujung bulan Ramadhan, ada yang <a href="https://groups.yahoo.com/neo/groups/jug-indonesia/conversations/messages/92685">bertanya di milis JUG</a>. Alhamdulillah, ada kesempatan bersedekah di detik-detik terakhir bulan puasa ;) Karena pertanyaannya membutuhkan jawaban yang cukup panjang, baiklah kita jawab di blog saja.</p>

<p>Berikut pertanyaannya.</p>

<blockquote><p>Saya pernah menggunakan Spring Security Framework. Tapi kalau cuma pakai, tanpa ngerti konsep dasar dan cara kerjanya dasarnya sakit kepala juga akhirnya kalau semua terjadi secara automagically.</p>

<p>Jadi kalau murni tanpa menggunakan Framework apapun :</p>

<ul>
<li>Bagaimana membuat proses loginnya? dari beberapa artikel yang saya baca (saya baru tahu) katanya login username dan passwordnya dimasukan kedalam HTTP Header.</li>
</ul>


<p>Contohnya :</p>

<p><code>Authorization:Basic c2VzdWF0dUB5YWhvby5jb206YmlzbWlsbGFo</code></p>

<p>dimana <code>c2VzdWF0dUB5YWhvby5jb206YmlzbWlsbGFo</code> adalah Base64 encoding dari <code>sesuatu@yahoo.com:bismillah</code> (username:password)</p>

<p>benarkah begitu?</p>

<ul>
<li><p>Bagaimana server mengenali client jika kita menggunakan method GET? (ini pertanyaan konsep sangat mendasar sekali). Mungkin jawabannya ya dengan token.</p></li>
<li><p>Tapi ditaruh dimana? apakah dengan saya tempelkan saja di URL? misal</p></li>
</ul>


<p><code>GET /thewebapp/category/324?token=abcde1234</code></p>

<p>atau saya masukkan dalam HTTP header? tapi dengan header apa?</p></blockquote>

<p>Dan berikut jawaban saya</p>

<!--more-->


<p>Yang ditanyakan ini dinamakan proses authentication, artinya memastikan bahwa seseorang/sesuatu yang datang (principal) sesuai dengan yang diakuinya.
Konkretnya, kalau ada request datang dari user <code>endy</code>, harus diverifikasi bahwa yang request benar-benar <code>endy</code> yang asli.</p>

<p>Bagaimana caranya? Biasanya dengan cara menanyakan sesuatu yang hanya dimiliki oleh principal. Sesuatu ini disebut dengan istilah credential.</p>

<p><a name="principal-credential"></a></p>

<h2>Principal dan Credential</h2>

<p>Principal dan credential itu macam-macam bentuknya. Yang paling umum ditemui : principal = username, credential = password.</p>

<p>Ini kalau principalnya manusia. Bagaimana kalau principalnya aplikasi lain? Ada beberapa credential yang biasa digunakan, misalnya:</p>

<ul>
<li>digital certificate</li>
<li>secret shared key</li>
<li>private key</li>
<li>dsb</li>
</ul>


<p>Bahkan walaupun usernya manusia, credential tidak cuma password. Bisa juga random number yang digenerate menggunakan algoritma. Dikenal juga dengan istilah <a href="http://en.wikipedia.org/wiki/One-time_password">One Time Password (OTP)</a>. Generatornya bisa software dan bisa juga hardware. Contoh hardwarenya seperti token internet banking yang biasa kita gunakan</p>

<p><img src="https://farm4.staticflickr.com/3670/12361262404_50b4ab650e_z.jpg"></p>

<p>Sedangkan contoh software yang populer antara lain <a href="http://code.google.com/p/google-authenticator/">Google Authenticator</a> dan <a href="https://www.wikidsystems.com/community-edition">WiKiD</a></p>

<p>Mekanisme OTP ini biasanya digunakan bersama-sama dengan password, sehingga disebut juga dengan <a href="http://en.wikipedia.org/wiki/Two_factor_authentication">2 Factor Authentication</a>. Kenapa 2 Factor? Karena untuk bisa mengakses aplikasi, kita akan dimintai 2 hal : <em>what you know</em> dan <em>what you have</em>. What you know adalah password, karena hanya kita yang tahu. What you have adalah generator token, karena tiap generator akan menghasilkan nilai yang berbeda.</p>

<p>Kalau mau lebih canggih lagi, kita bisa menambahkan berbagai lain sehingga menjadi <a href="http://en.wikipedia.org/wiki/Multi-factor_authentication">Multi Factor Authentication</a> yaitu <em>who you are</em> atau biometrik (scan mata, sidik jari, DNA, suara, dsb)</p>

<p><a name="protokol-authentication"></a></p>

<h2>Protokol Authentication</h2>

<p>Setelah kita bicara principal dan credential, selanjutnya bicara protokol. Bagaimana cara principal dan credential disajikan?</p>

<p>Ada beberapa cara:</p>

<ul>
<li>form login. Aplikasi yang mau diakses menampilkan form, principal mengisi credential. Setelah itu diperiksa valid atau tidak</li>
<li>basic authentication. Informasi principal dan credential diencode (bukan encrypt ya) dengan algoritma Base64, kemudian ditaruh di HTTP Header.</li>
<li>digest. Principal mengirim data yang diencode menggunakan credential. Kemudian data ini dikirim ke aplikasi yang mau diakses. Aplikasi (dengan mekanisme yang sama) membuat data yang sama dan diencode dengan proses yang sama. Kalau klop, berarti credential yang tersimpan di aplikasi sama dengan yang dimiliki principal.</li>
<li><a href="http://en.wikipedia.org/wiki/Mutual_authentication">Mutual / Two-way SSL</a> Handshake. Principal mengirim digital signature yang kemudian akan divalidasi oleh aplikasi yang ingin diakses</li>
</ul>


<p>Untuk alasan efisiensi dan keamanan, proses authentication biasanya dilakukan sekali saja. Setelah proses selesai, principal akan diberikan token yang memiliki masa berlaku singkat. Request selanjutnya akan menggunakan token ini. Dengan demikian, credential tidak terus menerus dikirim melalui jaringan sehingga meningkatkan resiko dicuri.</p>

<p>Jadi, token ini harus disimpan oleh principal dan disertakan pada setiap request.</p>

<p>Bagaimana menyimpannya? Ada beberapa cara :</p>

<ul>
<li>cookie</li>
<li>browser storage (ada local storage dan session storage)</li>
</ul>


<p>Bagaimana menyertakannya pada tiap request? Ada beberapa cara:</p>

<ul>
<li>ditaruh di URL (teknik URL rewrite). Request yang tadinya <code>http://aplikasi.com/halo</code> menjadi <code>http://aplikasi.com/halo?token=abcd</code></li>
<li>dikirim dalam cookie</li>
<li>ditaruh di form data (biasanya menggunakan <code>input type=hidden</code>)</li>
</ul>


<p>Jangan lupa bahwa semua informasi yang berlalu-lintas ini harus berjalan dalam jalur yang aman. Selalu <a href="http://software.endy.muhardin.com/aplikasi/apa-itu-ssl/">gunakan HTTPS/SSL</a>.</p>

<p><a name="verifikasi-credential"></a></p>

<h2>Verifikasi Credential</h2>

<p>Selanjutnya, kita bicara di sisi aplikasi yang menerima request. Dia harus melakukan verifikasi principal dan credential. Bagaimana cara verifikasinya? Ada beberapa cara:</p>

<ul>
<li>in memory data. Username dan password dihardcode di aplikasi. Request authentication akan dicek ke data dalam memori ini. Berguna kalau aplikasinya kecil atau masih dalam fase development.</li>
<li>database relasional. Simpan username dan password dalam database. Password biasanya dihash (bukan encrypt ya) menggunakan berbagai algoritma seperti MD5, SHA, atau BCrypt. Lengkapi dengan salt untuk menambah keamanan.</li>
<li>database hirarkis (LDAP). Sama seperti database relasional, bentuknya saja yang berbeda.</li>
<li>delegasikan ke pihak ketiga (single sign on)</li>
</ul>


<p>Di jaman sekarang ini, mekanisme authentication dengan cara delegasi seperti ini semakin ngetren. Ada beberapa protokol standar yang populer :</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/OpenID">OpenID</a></li>
<li><a href="http://en.wikipedia.org/wiki/OAuth">OAuth</a> (versi 1 dan versi 2). Contoh siklus authentication dengan OAuth versi 2 bisa dilihat di <a href="https://github.com/endymuhardin/belajar-springoauth2">contoh yang saya buatkan di Github</a>. Kalau ada waktu lowong, di lain hari akan saya jelaskan dengan lebih rinci di sini.</li>
</ul>


<p>Selain itu, ada juga protokol proprietary yang disediakan berbagai aplikasi single-sign-on, seperti:</p>

<ul>
<li><a href="http://www.jasig.org/cas">Jasig CAS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Oracle_Identity_Management">Oracle Identity Management</a></li>
<li><a href="http://en.wikipedia.org/wiki/Active_Directory">Microsoft Active Directory</a></li>
<li>dsb</li>
</ul>


<p>Lalu apa kaitannya dengan Spring Security?</p>

<p>Singkat saja. Intinya semua hal di atas harus kita implementasikan dalam aplikasi yang kita buat. Kalau kita pakai Spring Security, sebagian besar (90%) sudah dibuatkan, tinggal pasang saja. 10% sisanya sudah disediakan titik-titik extension di mana kita bisa buat implementasinya dan pasang sehingga klop dengan 90% yang sudah disediakan Spring Security.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desain Skema Database]]></title>
    <link href="http://software.endy.muhardin.com/java/desain-skema-database/"/>
    <updated>2014-05-06T10:42:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/desain-skema-database</id>
    <content type="html"><![CDATA[<p>Pada <a href="http://software.endy.muhardin.com/manajemen/tahapan-membuat-aplikasi/">artikel sebelumnya</a>, kita telah belajar bagaimana memulai membuat aplikasi, yaitu dengan cara:</p>

<ul>
<li>membuat daftar fitur</li>
<li>membuat UI Mockup</li>
</ul>


<p>Kedua langkah di atas membantu kita untuk memvisualisasikan apa yang ada di imajinasi kita menjadi bentuk yang bisa dilihat oleh banyak orang. Ada beberapa keuntungan dari proses visualisasi ini, yaitu:</p>

<ul>
<li>mengurangi kepusingan, karena apa yang sebelumnya cuma dibayangkan, sekarang terlihat bentuknya</li>
<li>menunjukkan kekurangan dalam imajinasi kita. Seringkali saya mendapati ada informasi yang kurang sehingga harus ditanyakan lagi ke user. Kali lain, saya mendapati ternyata perpindahan antar screen tidak sistematis sehingga membingungkan user. Atau saya terlalu kompleks mendesain tampilan yang seharusnya bisa lebih sederhana.</li>
<li>menjadi bahan diskusi dengan user, menghindarkan kita dari membuat sesuatu yang tidak dibutuhkan user.</li>
<li>sebagai pedoman kita untuk merancang skema database</li>
</ul>


<p>Poin terakhir tersebut akan menjadi bahasan kita pada artikel kali ini.</p>

<p>Saya tidak akan membahas tentang teori normal form. Seharusnya para mahasiswa informatika sudah mempelajarinya di mata kuliah Basis Data yang biasanya diberikan di semester 3. Silahkan ambil lagi mata kuliah tersebut di tahun/semester depan kalau ternyata Anda ketiduran waktu dosennya menerangkan. Sedangkan pembaca yang tidak kuliah di informatika (seperti saya), bisa baca-baca <a href="http://en.wikipedia.org/wiki/Database_normalization">referensi dari Wikipedia</a> atau <a href="http://www.bkent.net/Doc/simple5.htm">tutorial di sini</a>.</p>

<p>Artikel ini ditulis dengan asumsi pembaca sudah paham apa itu normal form. Silahkan belajar dulu kalau belum paham, baru kembali lagi ke sini.</p>

<!--more-->


<p>Sebelum kita mulai mendesain skema database, ada satu hal penting yang kita perlu camkan baik-baik</p>

<blockquote><p>Hasil desain, baik itu skema database, class diagram, flowchart, dan lainnya, bukanlah merupakan hasil sekali pukul. Dia adalah suatu produk yang harus terus disempurnakan bahkan sampai setelah aplikasinya go live.</p></blockquote>

<p>Dengan demikian, adalah lumrah kalau kita merevisi skema database berkali-kali. Setelah go-live saja bisa berubah, apalagi pada saat development.</p>

<h2>Desain tabel master</h2>

<p>Dalam mendesain skema database, kita mulai dulu dengan yang paling sederhana, yaitu tabel master. Tabel master biasanya tidak berelasi ke tabel lain. Kalaupun ada relasi, biasanya relasi dengan tabel master lainnya. Contohnya, master pegawai berelasi ke master kabupaten, kecamatan, kodepos, tingkat pendidikan, dan lainnya. Karena dia sederhana, maka dalam membuat aplikasi, biasanya tabel-tabel master ini didefinisikan duluan.</p>

<p>Ada pola yang biasa saya gunakan dalam mendesain tabel database (baik master data maupun transaksi), yaitu:</p>

<ul>
<li>harus ada primary key yang berupa surrogate key</li>
<li>karena pakai surrogate key, maka kandidat natural key menjadi kolom biasa yang diberikan <em>unique constraint</em></li>
<li>buat kolom lain sesuai yang ada di UI mockup</li>
<li>untuk menyimpan nilai uang, gunakan DECIMAL, bukan FLOAT atau DOUBLE, supaya kita bisa mengontrol pembulatan dan tingkat presisi</li>
</ul>


<blockquote><p>Whoa, apa itu surrogate key dan natural key?</p></blockquote>

<p>Mari kita bahas.</p>

<h2>Menentukan Primary Key</h2>

<p>Misalnya kita akan menyimpan data pegawai dalam tabel <code>m_pegawai</code>. Informasi pegawai memiliki beberapa data sebagai berikut:</p>

<ul>
<li>nip (nomor induk pegawai), dijamin unik karena tiap pegawai pasti beda.</li>
<li>nama,  tidak unik. Agus, Budi, Cahyo biasanya banyak yang pakai.</li>
<li>email, juga unik. Tidak mungkin satu email dipake rame-rame.</li>
</ul>


<p>Dari ketiga data di atas, hanya dua yang bisa jadi primary key yaitu <code>nip</code> dan <code>email</code>, karena secara proses bisnis, nilainya harus unik di tiap record pegawai. Kedua data ini, bila kita pilih salah satunya menjadi primary key, maka disebut dengan istilah <a href="http://en.wikipedia.org/wiki/Natural_key">natural key</a>, artinya primary key yang diambil dari data yang memang sudah ada.</p>

<p>Selain natural key, kita juga bisa membuat data lain yang tidak berkaitan dengan proses bisnis. Misalnya menambahkan primary key berupa kolom <code>id</code> di tabel pegawai yang nilainya kita konfigurasi supaya bertambah satu (increment) tiap ada record baru yang dimasukkan ke tabel. Kolom <code>id</code> ini disebut dengan istilah <a href="http://en.wikipedia.org/wiki/Surrogate_key">surrogate key</a>.</p>

<h3>Natural vs Surrogate</h3>

<p>Keuntungan kita menggunakan natural key adalah, datanya sudah ada. Dengan demikian kita tidak perlu menambah kapasitas penyimpanan untuk satu kolom khusus primary key.</p>

<p>Kerugian dari natural key adalah nilainya bisa berubah. Sebagai contoh, bila perusahaan merger, maka nilai <code>nip</code> bisa dipastikan akan menyesuaikan dengan perusahaan lain yang dimerger. Bisa formatnya ikut perusahaan lain tersebut, dan bisa juga membuat format baru sesuai kesepakatan bersama.</p>

<blockquote><p>Kalau gitu, email saja yang jadi primary key.</p></blockquote>

<p>Email justru lebih sering berubah. Gak perlu merger, cukup ada layanan yang menawarkan kapasitas lebih besar, orang langsung bikin akun email baru.</p>

<blockquote><p>Lalu memangnya kenapa kalau berubah?</p></blockquote>

<p>Yang namanya primary key, akan digunakan di tabel lain sebagai <em>foreign key</em>. Apalagi untuk tabel master, pasti dia akan direlasikan di berbagai tabel lainnya. Jika primary key berubah, maka semua tabel lain harus ikut diupdate isi foreign key-nya. Ini akan membutuhkan <em>locking</em> yang luas karena harus meliputi banyak tabel sekaligus. Semakin luas <em>locking</em>, semakin lemot performance, karena proses lain harus antri mendapatkan <em>lock</em>.</p>

<p>Masalah kedua, penggunaan natural key cenderung akan mengarah pada penggunaan <a href="http://en.wikipedia.org/wiki/Compound_key">compound/composite key</a>, yaitu primary key yang terdiri dari dua atau lebih kolom. Ini akan lebih merepotkan lagi, karena foreign key dari composite key juga akan terdiri dari dua/lebih kolom.</p>

<p>Kekurangan dari surrogate key adalah ada tambahan space harddisk untuk menyimpan data kolom tambahan. Juga tambahan space untuk membuat index dari natural key (yang seharusnya otomatis terindex bila dia menjadi primary key).</p>

<blockquote><p>Lalu, sebaiknya pakai natural key atau surrogate key?</p></blockquote>

<p>Saya selalu pakai surrogate key. Sebabnya karena space harddisk semakin lama semakin murah, sedangkan locking problem dan composite key akan memakan mandays programmer yang semakin lama semakin mahal.</p>

<h3>Strategi Key Generator</h3>

<p>Karena nilai dari surrogate key tidak berhubungan dengan data yang diwakilinya, maka kita bisa melakukan optimasi dalam pemilihan algoritma untuk menghasilkan nilai baru. Ada beberapa strategi yang biasa digunakan:</p>

<ul>
<li>Auto increment / sequence. Cara ini disebut dengan berbagai istilah, misalnya AUTO_INCREMENT (MySQL), SEQUENCE (Oracle), SERIAL (PostgreSQL), IDENTITY (MS SQL Server), AutoNumber (MS Access), dan lainnnya. Intinya adalah penggunaan tipe data integer yang nilainya bertambah terus.</li>
<li><a href="http://en.wikipedia.org/wiki/Universally_Unique_Identifier">UUID</a> / <a href="http://en.wikipedia.org/wiki/Globally_Unique_Identifier">GUID</a>. Tipe datanya 32 karakter alfanumerik, bisa diwakili di database dengan CHAR atau VARCHAR.</li>
</ul>


<blockquote><p>Pilih yang mana?</p></blockquote>

<p>Saya biasa pakai UUID, karena dia dijamin unik siapapun yang menjalankan generator. Ini akan sangat berguna dalam skenario database terdistribusi seperti ini.</p>

<p>Misalnya database kita split menjadi database kantor pusat dan kantor cabang. Masing-masing cabang insert data transaksi ke database yang ada di kantor cabang. Pada sore hari, database cabang diupload ke kantor pusat dan digabungkan ke database pusat, bersama-sama dengan data transaksi dari cabang lain.</p>

<p>Bila kita menggunakan sequence, akan terjadi duplikasi primary key, karena masing-masing cabang memulai sequence dari angka 1. Cabang A akan punya data 1 - 100, demikian juga cabang-cabang lain.</p>

<p>Lain halnya bila kita menggunakan UUID. Nilai yang dihasilkan oleh cabang A dijamin berbeda dengan nilai yang dihasilkan cabang B. Dengan demikian, kita tinggal insert data cabang A dan cabang B ke database pusat tanpa ada primary key yang bentrokan.</p>

<h2>Tabel Transaksi</h2>

<p>Sekarang kita beranjak ke tabel untuk menyimpan data transaksi.</p>

<p>Pola yang umum dipakai adalah relasi <code>master-detail-header</code> seperti ini</p>

<p><img src="https://lh3.googleusercontent.com/-B_icVAf77dg/U2b9zeQw8FI/AAAAAAAAFvk/D7q35jK7U7Y/w915-h221-no/skema-master-header-detail.png"></p>

<p>Pola ini bisa kita gunakan untuk aplikasi perpustakaan seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-k1DUCU0X4K8/U2b9zUQq0yI/AAAAAAAAFvo/7saKCOClC0U/w876-h484-no/skema-perpustakaan.png"></p>

<p>Ataupun untuk aplikasi bengkel, dimana detailnya ada dua (part dan jasa)</p>

<p><img src="https://lh6.googleusercontent.com/-GDtsnS1_9gE/U2b9zQlqgII/AAAAAAAAFvs/afAswqUErzg/w873-h500-no/skema-bengkel.png"></p>

<p>Pola yang sama bisa digunakan dalam pencatatan transaksi lain, misalnya:</p>

<ul>
<li>jurnal akuntansi : jurnal_header berisi tanggal dan keterangan, jurnal_detail berisi id_akun, debet/kredit, dan nilai nominal</li>
<li>transaksi di minimarket : transaksi_header berisi tanggal dan nama kasir, transaksi_detail berisi id_produk, qty, harga_satuan</li>
<li>keluar/masuk barang di gudang : transaksi_header berisi tanggal, transaksi_detail berisi id_barang, qty</li>
<li>dan sebagainya</li>
</ul>


<h3>Identifying Relationship</h3>

<p>Pembaca yang teliti akan melihat bahwa garis penghubung relasi antara <code>header</code> dan <code>detail</code> berbeda dengan <code>detail</code> dan <code>master</code>. <code>Header-detail</code> garisnya menyambung sedangkan <code>detail-master</code> putus-putus. Garis tersambung disebut dengan istilah <a href="http://stackoverflow.com/a/762994">identifying relationship</a>, yaitu hubungan parent-child. Artinya, kalau induknya (record di tabel header) dihapus, maka anaknya (record di tabel detail) juga harus dihapus karena sudah tidak relevan lagi.</p>

<p>Berbeda dengan master-detail. Kalau masternya dihapus, belum tentu data transaksinya juga ikut dihapus. Bisa jadi relasinya cuma diset menjadi <code>NULL</code> saja, tapi datanya tetap ada dan tetap bisa dihitung.</p>

<h2>Tabel Akumulasi</h2>

<p>Terakhir, kita bahas tentang tabel akumulasi. Tabel ini sebetulnya tidak wajib dibuat. Kita membuat tabel ini terutama untuk alasan performance.</p>

<p>Misalnya kita ingin menampilkan data jumlah stok buku di satu hari tertentu. Atau kita ingin mencari berapa jumlah barang yang tersisa untuk satu jenis barang tertentu.</p>

<p>Tanpa tabel akumulasi, kita harus mencari dulu saldo awalnya, kemudian kita melakukan penjumlahan berapa penambahan dan pengurangan selama periode bisnis berjalan. Kalau bisnisnya baru jalan 3 hari tidak masalah, tapi bagaimana kalau sudah jalan 3 tahun? Tentu ada jutaan record yang harus dijumlahkan oleh database dalam sekali request. Bagaimana kalau usernya banyak?</p>

<p>Untuk mengatasinya, kita buat tabel untuk akumulasi. Berikut skemanya</p>

<p><img src="https://lh6.googleusercontent.com/-ZKiD_6GBDig/U2hUO-HearI/AAAAAAAAFwM/SJgzkIeJU9E/w619-h625-no/skema-akumulasi.png"></p>

<p>Penjelasan kolomnya sebagai berikut:</p>

<ul>
<li>id : surrogate key</li>
<li>id_xx : relasi ke tabel master barang/akun/produk/dsb</li>
<li>tanggal : supaya memudahkan, kita buat satu record per hari</li>
<li>saldo_awal : nilai di awal hari</li>
<li>debet : penambahan nilai dalam hari itu</li>
<li>kredit : pengurangan nilai dalam hari itu</li>
</ul>


<blockquote><p>Kok gak ada saldo akhir?</p></blockquote>

<p>Ya kan tinggal dihitung saja. Saldo akhir = saldo awal + debet - kredit. Gampang kan?</p>

<p>Ada dua pilihan metode dalam mengisi tabel akumulasi ini:</p>

<ol>
<li>Diupdate setiap insert transaksi. Jika menggunakan metode ini, jangan lupa menggunakan <a href="http://software.endy.muhardin.com/java/database-transaction/">database transaction</a> untuk menjaga konsistensi data.</li>
<li>Diupdate secara batch di akhir hari. Jika menggunakan metode ini, jangan lupa memasang lock supaya tidak ada orang yang insert record baru pada saat kita sedang menghitung akumulasi. Biasanya kalau trafiknya tinggi dan harus selalu online (seperti ATM bank), perlu menggunakan teknik shadow balance supaya transaksi bisa terus jalan walaupun batch update sedang berjalan.</li>
</ol>


<h2>Kesimpulan</h2>

<p>Poin penting yang bisa diambil dari artikel ini:</p>

<ul>
<li>natural key vs surrogate key</li>
<li>pola master-detail-header</li>
<li>pola master-akumulasi</li>
</ul>


<p>Skema database dibuat menggunakan aplikasi <a href="http://www.mysql.com/products/workbench/">MySQL Workbench</a>. Desain skema pada contoh di atas bisa <a href="../../downloads/skema-database-aplikasi.mwb">diunduh di sini</a></p>

<p>Demikianlah pola desain skema database yang biasa saya gunakan untuk membuat aplikasi bisnis. Pada posting selanjutnya, kita akan bahas apa saja class dan package yang harus kita buat pada waktu coding. Stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Membuat subreport Jasper dalam SpringMVC]]></title>
    <link href="http://software.endy.muhardin.com/java/membuat-subreport-jasper-dalam-springmvc/"/>
    <updated>2014-04-12T12:26:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/membuat-subreport-jasper-dalam-springmvc</id>
    <content type="html"><![CDATA[<p>Pada artikel ini, kita akan membuat implementasi download file PDF/XLS dari aplikasi web. Fitur ini akan kita implementasi menggunakan library <a href="http://community.jaspersoft.com/project/jasperreports-library">Jasper Report</a> dan framework <a href="http://docs.spring.io/spring/docs/4.0.2.RELEASE/spring-framework-reference/html/view.html#view-jasper-reports">Spring MVC</a>.</p>

<p>Projectnya akan kita buat menggunakan Maven, supaya bisa dibuka dengan baik (portable) di berbagai IDE. Untuk bisa memahami artikel ini dengan baik, pembaca harus sudah paham tentang Spring Framework dan Spring MVC. Yang belum paham Spring Framework bisa membaca <a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">artikel terdahulu tentang Dependency Injection</a>. Sedangkan pembahasan tentang Spring MVC bisa dibaca di <a href="https://www.google.com/search?q=site%3Asoftware.endy.muhardin.com&amp;q=aplikasi+web+dengan+spring">rangkaian artikel berseri tentang membuat aplikasi web dengan Spring MVC</a>.</p>

<p>Source code lengkap dapat diakses di <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports">repository Github</a>. Bagi yang ingin tahu urutan langkah-langkah implementasinya, bisa lihat <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/commits/master">commit history</a>.</p>

<!--more-->


<h2>Setup Project</h2>

<p>Pertama, kita setup dulu projectnya menggunakan Maven Archetype dengan perintah berikut</p>

<p><code>
mvn archetype:create -DgroupId=com.muhardin.endy.belajar -DartifactId=belajar-springmvc-jasper
</code></p>

<p>Kemudian konversi menjadi aplikasi web dengan cara:</p>

<ul>
<li>edit <code>pom.xml</code>, ganti <code>&lt;packaging&gt;jar&lt;/packaging&gt;</code> menjadi <code>&lt;packaging&gt;war&lt;/packaging&gt;</code></li>
<li>tambahkan file <code>src/main/webapp/WEB-INF/web.xml</code></li>
<li>ini langkah opsional, tambahkan <code>src/main/webapp/index.html</code> supaya ada halaman Hello World</li>
</ul>


<p>Kondisi project pada tahap ini bisa dilihat di <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/tree/1fa6134d10b2816b40367d1fc2cc4302ddcb9a02">commit 1fa6134d10</a></p>

<p>Setelah selesai di tahap ini, kita bisa buka projectnya menggunakan Netbeans atau Eclipse.</p>

<h2>Aktivasi Spring MVC</h2>

<p>Mulai dari yang mudah dulu, kita buat controller yang menampilkan Hello World dengan Spring MVC. Ini sekedar memastikan bahwa konfigurasi Spring MVC kita sudah benar, sehingga pada waktu implementasi Jasper Report nanti kita tidak perlu lagi memusingkan error Spring MVC.</p>

<p>Tambahkan dependensi Spring MVC di <code>pom.xml</code></p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
&lt;version&gt;${org.springframework.version}&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>Saya menggunakan Maven properties untuk mendeklarasikan versi library. Ini akan memudahkan kalau di kemudian hari kita ingin mengupgrade versinya.</p>

<p>```xml
<properties></p>

<pre><code>&lt;org.springframework.version&gt;4.0.2.RELEASE&lt;/org.springframework.version&gt;
</code></pre>

<p></properties>
```</p>

<p>Agar bisa memproses file JSP, kita tambahkan juga library <code>jstl</code>.</p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
&lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;version&gt;${jstl.version}&lt;/version&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Selanjutnya, deklarasikan <code>DispatcherServlet</code> milik Spring di <code>web.xml</code></p>

<p>```xml
<servlet></p>

<pre><code>&lt;servlet-name&gt;belajar&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
</code></pre>

<p></servlet></p>

<p><servlet-mapping></p>

<pre><code>&lt;servlet-name&gt;belajar&lt;/servlet-name&gt;
&lt;url-pattern&gt;/&lt;/url-pattern&gt;
</code></pre>

<p></servlet-mapping>
```</p>

<p>Kita harus membuat file konfigurasi sesuai dengan nama servlet. Karena namanya <code>belajar</code>, maka file yang harus dibuat adalah <code>belajar-servlet.xml</code>. Isinya tidak banyak, seperti ini:</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>   xmlns:mvc="http://www.springframework.org/schema/mvc"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

&lt;mvc:annotation-driven/&gt;
&lt;mvc:default-servlet-handler /&gt;

&lt;context:component-scan base-package="com.muhardin.endy.belajar.springmvcjasper.controller" /&gt;

&lt;bean id="jstlViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
    &lt;property name="prefix" value="/WEB-INF/templates/jsp/"/&gt;
    &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>Sediakan file <code>halo.jsp</code> dalam folder <code>WEB-INF/templates/jsp</code>. Isinya tidak saya pasang di sini, silahkan lihat sendiri <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/blob/5e5eed120ab0a58e91a5c130fa2957b82acfebb0/src/main/webapp/WEB-INF/templates/jsp/halo.jsp">di Github</a>.</p>

<p>Buat controller dalam package <code>com.muhardin.endy.belajar.springmvcjasper.controller</code>, sesuai konfigurasi dalam <code>belajar-servlet.xml</code>. Isi file bisa dilihat <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/blob/5e5eed120ab0a58e91a5c130fa2957b82acfebb0/src/main/java/com/muhardin/endy/belajar/springmvcjasper/controller/HaloController.java">di Github</a>.</p>

<p>Pada tahap ini, kita bisa menjalankan aplikasinya dengan perintah <code>mvn clean package tomcat:run</code> dan browse ke <code>http://localhost:8080/belajar-springmvc-jasper/halo</code></p>

<p>Kondisi folder project pada tahap ini bisa dilihat <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/tree/5e5eed120ab0a58e91a5c130fa2957b82acfebb0">di sini</a>.</p>

<h2>Aktivasi Jasper Report</h2>

<p>Kita harus membuat dulu template reportnya. Gunakan <a href="http://community.jaspersoft.com/project/ireport-designer">iReport</a> untuk mendesain template secara visual, supaya lebih mudah. Berikut screenshot report yang saya buat</p>

<p><img src="https://lh4.googleusercontent.com/-j44Qm1BUa70/U0jWOO7SwOI/AAAAAAAAFlM/vReeJlxCI3E/w916-h574-no/01-report-induk.png" title="" ></p>

<p>Semua template Jasper Report kita simpan dalam folder <code>src/main/webapp/WEB-INF/templates/jrxml</code>.</p>

<p>Agar bisa memproses template report tersebut, kita tambahkan dulu library Jasper Report di <code>pom.xml</code></p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;net.sf.jasperreports&lt;/groupId&gt;
&lt;artifactId&gt;jasperreports&lt;/artifactId&gt;
&lt;version&gt;${jasperreports.version}&lt;/version&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Cukup gunakan scope <code>runtime</code> karena kita tidak perlu import class Jasper di kode program kita. Tambahkan juga dependensi <code>javax.servlet.http</code> supaya kita bisa menggunakan class <code>HttpServletRequest</code> nantinya. Scopenya kita gunakan <code>provided</code>, karena sudah disediakan dalam application server (misal: Tomcat).</p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;javax&lt;/groupId&gt;
&lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;
&lt;version&gt;7.0&lt;/version&gt;
&lt;scope&gt;provided&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Selanjutnya, kita tinggal isi data yang akan ditampilkan dalam dokumen PDF/XLS. Ini kita lakukan di kode program Java dalam class <code>HaloController</code>. Berikut methodnya</p>

<p>```java
@RequestMapping(value = "/anggota/export*", method = RequestMethod.GET)
public ModelMap exportDataAnggota(HttpServletRequest request) {</p>

<pre><code>String uri = request.getRequestURI();
String format = uri.substring(uri.lastIndexOf(".") + 1);

return new ModelMap()
        .addAttribute("format", format)
        .addAttribute("tanggal", new Date())
        .addAttribute("dataSource", service.semuaAnggota());
</code></pre>

<p>}
```</p>

<p>Pada kode program di atas, pertama kita ambil dulu akhiran di URL yang diakses user. Contohnya, bila user mengakses <code>http://localhost:8080/belajar-springmvc-jasper/anggota/export.pdf</code>, maka variabel <code>format</code> akan berisi <code>pdf</code>. Variabel <code>format</code> ini akan digunakan Spring untuk menentukan jenis outputnya, apakah PDF, XLS, CSV, dsb.</p>

<p>Kita isi variabel apapun yang kita butuhkan dalam report. Pada contoh di atas, kita kirim dua variabel yaitu <code>tanggal</code> dan <code>dataSource</code>. Variabel <code>tanggal</code> akan menjadi parameter dalam Jasper Report, sedangkan <code>dataSource</code> akan menjadi sumber data yang akan ditampilkan dalam <em>band</em> <code>detail</code>. Untuk lebih jelasnya, silahkan <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/blob/17dd0806ccf41d5edbcf646aa50458cfbd130d8f/src/main/webapp/WEB-INF/templates/jrxml/daftar-anggota.jrxml">buka file templatenya</a> dengan menggunakan iReport.</p>

<p>Selanjutnya, kita konfigurasi Spring agar request ke url <code>http://localhost:8080/belajar-springmvc-jasper/anggota/export.pdf</code> diteruskan ke Jasper Report. Kita buat deklarasi resolver untuk Jasper Report dalam <code>belajar-servlet.xml</code> sebagai berikut</p>

<p>```xml
<bean id="jasperViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"></p>

<pre><code>&lt;property name="location" value="classpath:jasper-views.xml"/&gt;
&lt;property name="order" value="0"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Tambahkan juga property <code>order</code> di konfigurasi JSP supaya dia dijalankan setelah Jasper Report.</p>

<p>```xml
<bean id="jstlViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"></p>

<pre><code>&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
&lt;property name="prefix" value="/WEB-INF/templates/jsp/"/&gt;
&lt;property name="suffix" value=".jsp"/&gt;
&lt;property name="order" value="1"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Ini kita lakukan karena resolver JSP tidak bisa mengecek apakah templatenya ditemukan atau tidak. Dia akan langsung mengeluarkan pesan error. Dengan resolver Jasper dieksekusi duluan, maka flownya akan seperti ini:</p>

<ol>
<li>Dari controller terima nama view <code>/anggota/export.pdf</code></li>
<li>Cari view dengan nama tersebut dalam <code>jasperViewResolver</code></li>
<li>Kalau tidak ketemu lanjutkan cari dalam <code>jstlViewResolver</code></li>
<li>Kalau tidak ketemu juga, keluarkan pesan error</li>
</ol>


<p>Kondisi folder project pada tahap ini bisa dilihat <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/tree/bce02983b044e80a97db7dc95689b643afbdea8a">di sini</a></p>

<p>Pada tahap ini kita sudah bisa menghasilkan file PDF ataupun XLS menggunakan Jasper Report dan Spring MVC. Tentunya pada aplikasi sebenarnya data diambil dari database. Tapi untuk menyederhanakan masalah agar kita bisa fokus ke konfigurasi Jasper dan Spring, maka data yang ditampilkan kita hardcode saja.</p>

<p>Selanjutnya, kita akan mencoba konfigurasi yang lebih sulit, yaitu sub report.</p>

<h2>Sub Report</h2>

<p>Subreport adalah report di dalam report. Ini adalah fitur canggih dari Jasper Report. Kita tidak akan membahas detail tentang apa itu subreport. Silahkan baca artikel <a href="http://www.richardnichols.net/2010/02/simple-guide-to-sub-reports-in-jasperreports-ireport/">ini</a> dan <a href="http://bytecoded.blogspot.com/2009/12/jasperreports-370demosamplessubreport.html">ini</a> untuk memahami apa itu subreport.</p>

<p>Satu report induk bisa menampung banyak subreport. Masing-masing subreport memiliki template dan <code>dataSource</code> sendiri. Untuk itu, kita perlu memberitahukan pada semua pihak tentang lokasi / nama file template subreport dan nama variabel <code>dataSource</code> yang digunakan di subreport.</p>

<p>Kita mulai dari desain template induk terlebih dulu. Ini kita lakukan di iReport. Drag and drop icon subreport di Palette ke template. iReport akan menampilkan wizard untuk membantu kita.</p>

<p><img src="https://lh5.googleusercontent.com/-gqIBrrd0qeg/U0jWNjg4bSI/AAAAAAAAFk4/XzTxNcCIyOU/w667-h435-no/02-membuat-subreport.png"></p>

<p>Saya lebih suka membuat templatenya secara terpisah, kemudian menyatukannya secara manual. Oleh karena itu, kita pilih <em>Just create subreport element</em>.</p>

<p>Hasilnya sebagai berikut.</p>

<p><img src="https://lh5.googleusercontent.com/-3ig57Gmr68A/U0jWOcc-8hI/AAAAAAAAFlI/49LtLA6TDFk/w916-h574-no/03-layout-subreport.png"></p>

<p>Sebetulnya di dokumentasi Spring MVC ada penjelasan tentang cara menggunakan subreport.</p>

<p><img src="https://lh6.googleusercontent.com/-j7vN6jiyKIs/U0jWOktav7I/AAAAAAAAFlU/Qs8BbyjvYro/w917-h478-no/04-docs-springmvc-jasper-subreport.png"></p>

<p>Tapi sayangnya, isinya tidak nyambung sama penjelasan di atasnya. Penjelasan report sederhana dibuat menggunakan konfigurasi file properties, sedangkan penjelasan subreport dibuat menggunakan konfigurasi file XML. Perbedaannya bisa dilihat <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/commit/bce02983b044e80a97db7dc95689b643afbdea8a">di sini</a> atau pada gambar di bawah.</p>

<p><img src="https://lh4.googleusercontent.com/-7xWAHJ6UnL0/U0jdR--3THI/AAAAAAAAFmI/1ZiMYLibtpM/w916-h617-no/09-properties-vs-xml.png"></p>

<p>Selanjutnya, kita tambahkan parameter di desain report induk kita. Bisa menggunakan GUI ataupun langsung edit XMLnya. Kali ini saya pakai XML saja supaya bisa copy-paste</p>

<p><img src="https://lh3.googleusercontent.com/-hCvlDw6HmAE/U0jWPcwj3iI/AAAAAAAAFlc/njZlxs_0lNI/w834-h383-no/05-subreport-params.png"></p>

<p>Kita tambahkan dua parameter, yaitu <code>SubReportKantor</code> dan <code>dataSourceSubreport</code>. Kedua parameter ini kita gunakan pada deklarasi subreport yang sudah ditambahkan iReport pada waktu kita drag and drop tadi.</p>

<p><img src="https://lh3.googleusercontent.com/-zqWFEblHxvo/U0jWPXhcBVI/AAAAAAAAFlk/r5q5WZw3BlI/w917-h265-no/06-subreport-declaration.png"></p>

<p>Perhatikan label <code>X</code> dan <code>Y</code>. Itu akan kita gunakan pada konfigurasi lainnya.</p>

<p>Nama variabel <code>dataSourceSubreport</code> yang ditandai dengan label <code>X</code> kita gunakan untuk menyuplai data yang dibutuhkan subreport dari dalam kode program Java.</p>

<p><img src="https://lh3.googleusercontent.com/-FE5T4GfnzBE/U0jWPTUvL7I/AAAAAAAAFlo/Rl8SG7IZjkI/w672-h217-no/07-spring-controller.png"></p>

<p>Selanjutnya kita edit konfigurasi Jasper Report di file <code>jasper-views.xml</code>. Tambahkan lokasi template subreport dan nama variabel yang digunakan untuk <code>dataSource</code>nya.</p>

<p><img src="https://lh6.googleusercontent.com/-qBxNAJ_nqsU/U0jWQwV3gAI/AAAAAAAAFlw/cqnz8eiWWd0/w917-h285-no/08-konfigurasi-jasperview.png"></p>

<p>Selesai sudah. Silahkan coba akses lagi <code>http://localhost:8080/belajar-springmvc-jasper/anggota/export.pdf</code> untuk melihat hasil akhirnya.</p>

<p><img src="https://lh6.googleusercontent.com/-8-GCJgtp70I/U0jgW78hxnI/AAAAAAAAFmY/2jJIFCNeB6g/w917-h485-no/10-final-result.png"></p>

<h2>FAQ</h2>

<p>Pada umumnya, kita semua menggunakan konfigurasi Jasper yang berbasis file properties, karena itulah yang dicontohkan di dokumentasi Spring Framework. Pada waktu muncul kebutuhan subreport, ternyata file konfigurasinya XML.</p>

<blockquote><p>Apakah saya harus konversi semua konfigurasi properties menjadi XML ??</p></blockquote>

<p>Jangan khawatir. Kita bisa menggunakan dua-duanya sekaligus. Tidak perlu pilih salah satu. Konfigurasi report yang lama tidak perlu dibuang/ditulis ulang menjadi xml. Cukup deklarasikan dua <code>view resolver</code>, yang satu properties, satu lagi XML. Begini contohnya</p>

<p>```xml
<bean id="propertiesJasperViewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"></p>

<pre><code>&lt;property name="basename" value="views"/&gt;
&lt;property name="order" value="0"/&gt;
</code></pre>

<p></bean></p>

<p><bean id="xmlJasperViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"></p>

<pre><code>&lt;property name="location" value="classpath:jasper-views.xml"/&gt;
&lt;property name="order" value="1"/&gt;
</code></pre>

<p></bean></p>

<p><bean id="jstlViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"></p>

<pre><code>&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
&lt;property name="prefix" value="/WEB-INF/templates/jsp/"/&gt;
&lt;property name="suffix" value=".jsp"/&gt;
&lt;property name="order" value="2"/&gt;
</code></pre>

<p></bean>
```</p>

<p>Dengan cara di atas, berikut flow Spring MVC dalam mencari template yang sesuai:</p>

<ol>
<li>Dari controller terima nama view <code>/anggota/export.pdf</code></li>
<li>Cari view dengan nama tersebut dalam <code>propertiesJasperViewResolver</code></li>
<li>Kalau tidak ketemu lanjutkan cari dalam <code>xmlJasperViewResolver</code></li>
<li>Kalau masih tidak ketemu juga lanjutkan cari dalam <code>jstlViewResolver</code></li>
<li>Kalau tidak ketemu juga, keluarkan pesan error</li>
</ol>


<p>Demikian penjelasan tentang integrasi Spring MVC dan Jasper Report. Source code lengkap bisa diambil <a href="https://github.com/endymuhardin/belajar-springmvc-jasperreports/">di Github</a></p>

<p>Semoga bermanfaat</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Silabus Kuliah Pemrograman]]></title>
    <link href="http://software.endy.muhardin.com/java/silabus-kuliah-pemrograman/"/>
    <updated>2014-03-05T12:11:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/silabus-kuliah-pemrograman</id>
    <content type="html"><![CDATA[<p>Melanjutkan rutinitas 2 tahun terakhir, minggu ini musim perkuliahan semester genap di Universitas Pancasila dimulai. Saya kebagian pegang Pemrograman 2 di kelas reguler, dan Pemrograman 4 di kelas karyawan. Buat para fans yang pengen ketemu dipersilahkan cari saya di Fakultas Teknik Universitas Pancasila setiap Kamis jam 18-21 dan Jumat jam 09-11.</p>

<p>Berikut adalah silabus perkuliahan dari Pemrograman 1 sampai Pemrograman 4. Silabus ini akan sering saya update mengikuti perkembangan jaman.</p>

<!--more-->


<p><a name="pemrograman-1"></a></p>

<h1>Pemrograman 1 : Fundamental</h1>

<h2>Tujuan</h2>

<ul>
<li>Paham dasar-dasar pemrograman dengan Java</li>
<li>Paham cara implementasi OOP dengan Java</li>
<li>Paham cara menggunakan class-class penting dalam Java SDK</li>
</ul>


<h2>Batasan</h2>

<ul>
<li>Hanya menggunakan library standar bawaan Java SDK</li>
<li>Tidak membahas konsep OOP (karena ada mata kuliahnya sendiri)</li>
</ul>


<h2>Referensi</h2>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/index.html">Official Java Tutorial, Oracle Corp</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/api/index.html">SDK Documentation, Oracle Corp</a></li>
<li><a href="http://project-template.googlecode.com/files/Java%20Desktop%20-%20Ifnu%20Bima.pdf">Java Desktop, Ifnu Bima</a></li>
</ul>


<h2>Kebutuhan Software Lab</h2>

<ul>
<li>Java SDK 1.6</li>
<li><a href="http://www.sublimetext.com/">Sublime Text 3</a></li>
</ul>


<h2>Materi Kuliah</h2>

<ul>
<li>Penjelasan Silabus</li>
<li>Setup / Instalasi Java</li>
<li>Version Control (Git)</li>
<li>Github</li>
<li>Anatomi Aplikasi Java</li>
<li>Classpath</li>
<li>Variabel dan Tipe Data</li>
<li>Operator</li>
<li>Control Flow (if-else, for/while)</li>
<li>Class &amp; Object</li>
<li>Method</li>
<li>Exception</li>
<li>Konsep OOP</li>
<li>Inheritance</li>
<li>Encapsulation</li>
<li>Polymorphism</li>
<li>Abstract Class &amp; Interface</li>
<li>Composition &amp; Aggregation</li>
<li>Studi Kasus / Tugas</li>
<li>Presentasi Kasus</li>
</ul>


<p><a name="pemrograman-2"></a></p>

<h1>Pemrograman 2 : Essential Library</h1>

<h2>Tujuan</h2>

<ul>
<li>Mahir menggunakan library tambahan dari dunia open source</li>
<li>Mahir menggunakan development tools Java</li>
</ul>


<h2>Batasan</h2>

<ul>
<li>Belum membuat user interface</li>
</ul>


<h2>Kebutuhan Software Lab</h2>

<ul>
<li>Semua requirement dari Pemrograman 1</li>
<li><a href="http://maven.apache.org/">Apache Maven 3</a></li>
<li>MySQL Server</li>
</ul>


<h2>Materi Kuliah</h2>

<ul>
<li>Build Tools</li>
<li>Automated Test</li>
<li>Date &amp; Time</li>
<li>Collections</li>
<li>JDBC</li>
<li>String</li>
<li>Regular Expression</li>
<li>Multithreading / Concurrency</li>
<li>File I/O</li>
<li>Network I/O</li>
<li>Popular Network Protocol (HTTP, FTP, SMTP, POP, IMAP)</li>
<li>Studi Kasus</li>
</ul>


<p><a name="pemrograman-3"></a></p>

<h1>Pemrograman 3 : Desktop</h1>

<h2>Tujuan</h2>

<ul>
<li>Bisa membuat aplikasi lengkap dengan UI Desktop</li>
</ul>


<h2>Batasan</h2>

<ul>
<li>Aplikasi berjalan lokal</li>
<li>Penyimpanan data dilakukan lokal</li>
<li>Interaksi dengan server dilakukan dengan menggunakan service yang sudah tersedia (tidak membuat sendiri)</li>
</ul>


<h2>Referensi</h2>

<ul>
<li><a href="http://project-template.googlecode.com/files/Java%20Desktop%20-%20Ifnu%20Bima.pdf">Java Desktop, Ifnu Bima</a></li>
</ul>


<h2>Kebutuhan Software Lab</h2>

<ul>
<li>Sama seperti Pemrograman 2</li>
</ul>


<h2>Materi Kuliah</h2>

<ul>
<li><p>Arsitektur Aplikasi Desktop</p>

<ul>
<li>Container</li>
<li>Simple Widget</li>
<li>Event Handling</li>
<li>Data backed Widget</li>
</ul>
</li>
<li><p>Hello Swing</p></li>
<li><p>Container</p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/components/frame.html">Frame</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html">Dialog</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/components/applet.html">Applet</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html">Panel</a></li>
</ul>
</li>
<li><p><a href="http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html">Menu</a></p></li>
<li><p><a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html">Layout Manager</a></p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/border.html">Border Layout</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/grid.html">Grid Layout</a></li>
<li>Flow Layout</li>
</ul>
</li>
<li><p>Simple Component</p>

<ul>
<li>Text Field</li>
<li>Button</li>
<li>Checkbox</li>
<li>Radio Button</li>
</ul>
</li>
<li><p><a href="http://docs.oracle.com/javase/tutorial/uiswing/events/index.html">Event Handling</a></p>

<ul>
<li>ActionEvent</li>
<li>MouseEvent</li>
</ul>
</li>
<li><p>Complex Component</p>

<ul>
<li>Combo/Select</li>
<li>List</li>
</ul>
</li>
<li><p>Swing Table</p>

<ul>
<li>JTable</li>
<li>TableModel</li>
</ul>
</li>
<li><p><a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html">Concurrent Execution</a></p>

<ul>
<li>Swing Worker</li>
<li>Progress Bar</li>
</ul>
</li>
<li><p>Internationalization</p></li>
<li><p>Jasper Report</p>

<ul>
<li>Parameter</li>
<li>Variable</li>
<li>Report Datasource</li>
</ul>
</li>
<li><p>iReport</p></li>
<li><p>Studi Kasus</p></li>
<li><p>Requirement Specification</p>

<ul>
<li>Daftar Fitur</li>
<li>Arsitektur</li>
<li>Desain UI</li>
<li>Desain Database</li>
</ul>
</li>
<li><p>Implementasi Frame dan Menu</p></li>
<li>Implementasi Dummy Screen</li>
<li>Implementasi Proses Bisnis</li>
<li>Implementasi Akses Database</li>
<li>Implementasi Report</li>
</ul>


<p><a name="pemrograman-4"></a></p>

<h1>Pemrograman 4 : Aplikasi Web</h1>

<h2>Tujuan</h2>

<ul>
<li>Bisa membuat aplikasi web dengan arsitektur REST</li>
<li>Bisa menggunakan penyimpanan data non-relasional</li>
</ul>


<h2>Referensi</h2>

<ul>
<li><a href="http://software.endy.muhardin.com/java/development-stack-2014/">Development Stack ArtiVisi</a></li>
</ul>


<h2>Kebutuhan Software Lab</h2>

<ul>
<li>Sama seperti Pemrograman 2</li>
<li><a href="http://software.endy.muhardin.com/javascript/persiapan-coding-nodejs/">NodeJS dan Yeoman</a></li>
</ul>


<h2>Materi Kuliah</h2>

<ul>
<li>Java Web Application</li>
<li>Servlet, Filter, Listener</li>
<li>JSP &amp; JSTL</li>
<li>Security</li>
<li>REST</li>
<li>AngularJS dan Twitter Bootstrap</li>
<li>Redis</li>
<li>MongoDB</li>
<li>Case Study</li>
</ul>

]]></content>
  </entry>
  
</feed>
