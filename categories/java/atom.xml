<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-07-12T13:45:42+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mengobati OOM]]></title>
    <link href="http://software.endy.muhardin.com/java/mengobati-oom/"/>
    <updated>2013-06-08T22:25:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengobati-oom</id>
    <content type="html"><![CDATA[<p>Beberapa waktu belakangan ini, di milis mulai banyak bermunculan pertanyaan yang berkaitan dengan Out Of Memory Error (OOM).
Error ini biasanya terjadi bila data dalam aplikasi sudah besar (melebihi 2 GB), dan umumnya terjadi pada saat membuat report PDF/XLS/CSV, dsb.</p>

<p>Biasanya juga, <em>obat yang dikonsumsi</em> oleh penderita OOM ini ada dua:</p>

<ul>
<li>Mengatur alokasi memori dengan opsi <code>Xms</code> dan <code>Xmx</code></li>
<li>Menggunakan perintah <code>System.gc()</code></li>
</ul>


<p>Sayangnya, kedua <em>obat</em> ini tidak akan menyelesaikan masalah. Analoginya seperti kita kena infeksi otak, lalu minum Panadol. Sakit kepalanya mungkin akan hilang sementara waktu, tapi tidak lama kemudian justru akibatnya lebih fatal.</p>

<p>Lalu bagaimana solusinya?</p>

<!--more-->


<h1>Salah Kaprah tentang OOM</h1>

<p>Pertama, saya luruskan dulu mengenai <code>System.gc</code>.
Intinya begini</p>

<blockquote><p>System.gc() hanya boleh dipakai dengan satu (dan hanya satu-satunya) syarat:
Yaitu pada waktu sudah bisa menjelaskan ke orang lain bagaimana cara kerja garbage collector dan sudah paham apa itu JVM Ergonomics.</p></blockquote>

<p>Next time mau mengetik System.gc, tanyakan pada diri sendiri, apakah saya sudah paham JVM Ergonomics dan bisa menjelaskannya ke orang lain? Kalau jawabannya belum, jangan diteruskan mengetik System.gc().</p>

<blockquote><p>Lalu apa itu <code>System.gc</code> dan kapan digunakan?</p></blockquote>

<p>Kan sudah dijelaskan di atas, pelajari cara kerja garbage collector dan apa itu JVM ergonomics.</p>

<p>Satu lagi salah kaprah yang harus dibenahi :
opsi <code>Xms</code> dan <code>Xmx</code> itu gunanya adalah <strong>UNTUK MEMAKSIMALKAN PENGGUNAAN MEMORI</strong>.
<code>Xms</code> dan <code>Xms</code> <strong>BUKAN SOLUSI UNTUK MASALAH OOM</strong>.</p>

<p>Masalah OOM itu ada di kode program kita sendiri, jadi carilah solusinya di kode program kita sendiri.
Penyebab OOM itu juga cuma satu : aplikasi kita menggunakan memori lebih besar daripada yang tersedia.
Besar pasak daripada tiang.</p>

<ol>
<li>Memori tersedia 4 GB, aplikasi kita pakai 4.1 GB => OOM</li>
<li>Memori tersedia 2 GB, aplikasi kita pakai 1.5 GB => No OOM padahal lebih kecil dari #1</li>
<li>RAM fisik ada 16 GB, tapi aplikasi kita cuma bisa memanfaatkan 2 GB => gunakan <code>Xms</code> dan <code>Xmx</code>.</li>
</ol>


<h1>Penyebab OOM dan Solusinya</h1>

<p>Beberapa penyebab umum terjadinya OOM :</p>

<h2>Unbounded Query</h2>

<p>Unbounded query adalah query yang tidak kita batasi jumlahnya.
Contohnya <code>select * from tbl_penjualan</code>. Kalau data penjualan hanya 1000 transaksi, no problem. Kalau transaksinya ada 10 juta record dalam satu hari, ya pasti langsung kena OOM.</p>

<p>Solusinya : pastikan selalu menggunakan paging. Ganti querynya menjadi <code>select * from tbl_penjualan limit 0,20</code> sehingga cuma mengeluarkan 20 record, berapapun banyaknya data dalam tabel.</p>

<h2>Generate File</h2>

<p>Seringkali kita ingin menghasilkan file report. Misalnya laporan penjualan bulan ini, berapapun data yang ada di tabel untuk periode bulan ini, harus ditulis ke file. File ini bisa berupa PDF, XLS, XML, CSV, dan sebagainya.</p>

<p>Format file tidak masalah. Yang menjadi masalah adalah cara membuatnya. Ada beberapa kesalahan umum :</p>

<ul>
<li>mengumpulkan data di variabel sebelum menulis file</li>
<li>tidak melepas data yang sudah diproses</li>
<li>tidak paham cara kerja report engine</li>
</ul>


<h3>Mengumpulkan data di variabel</h3>

<p>Contoh pseudocode seperti ini</p>

<p>```java
List<Penjualan> data = new ArrayList<Penjualan>();</p>

<p>// resultset adalah cursor, dia hanya baca apa yang ditarik saja
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>while(rs.next()){</p>

<pre><code>Penjualan p = konversiResultSetJadiPenjualan(rs);
data.add(p);
</code></pre>

<p>}
```</p>

<p>Coding di atas akan mengumpulkan semua record di variabel <code>data</code>.
Bila ada 1 juta record yang dihasilkan oleh query dengan masing-masing record berukuran 1 KB,
maka variabel data tersebut akan berukuran 1 GB. Kalau Java VM kita berikan alokasi 2 GB, cuma butuh 3 user untuk menimbulkan OOM.
Menaikkan alokasi menjadi 8 GB melalui <code>Xms</code> dan <code>Xmx</code> tidak akan membantu banyak.</p>

<h3>Tidak melepas data yang sudah diproses</h3>

<p>Ini biasanya terjadi kalau kita menulis sendiri file output. Perhatikan contoh kode berikut:</p>

<p>```java
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>File output = new File("output.csv");
while(rs.next()){</p>

<pre><code>String baris = konversiResultSetJadiString(rs);
output.write(baris);
output.flush();
</code></pre>

<p>}
```</p>

<p>Menulis file ada bermacam-macam. Ada yang menggunakan buffer ada yang tidak. Pastikan kita mengosongkan buffer setiap kali iterasi supaya tidak penuh, biasanya dengan method <code>flush</code> atau sejenisnya.</p>

<h3>Tidak paham cara kerja report engine</h3>

<p>Dalam mendesain library yang dipakai orang banyak, biasanya si pembuat akan melakukan optimasi untuk penggunaan yang sering terjadi.
Misalnya 80% orang membuat PDF berukuran 10 halaman atau lebih sedikit, 20% sisanya membuat 1000 halaman atau lebih.
Pada situasi ini, pembuat library report yang baik pasti akan memudahkan pembuatan 10 halaman report karena itulah fitur yang paling sering digunakan.</p>

<p>Bila kita termasuk golongan yang 20%, kita harus belajar lebih giat supaya paham bagaimana mengatasi kondisi minoritas tersebut.</p>

<p>Sebagai contoh, kalau kita menggunakan Jasper Report, ada fitur yang disebut dengan <a href="http://community.jaspersoft.com/wiki/comparison-report-virtualizers">Virtualizer</a> untuk membuat report berukuran besar. Pastikan kita sudah memahami kasus-kasus khusus ini.</p>

<h2>Inisialisasi object besar di dalam loop</h2>

<p>Perhatikan contoh kode di bawah</p>

<p>```java
public void simpan(Produk p){</p>

<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext("konfig-spring.xml");
ProdukDao pd = ctx.getBean(ProdukDao.class);
pd.save(p);
</code></pre>

<p>}
```</p>

<p><code>ApplicationContext</code> merupakan object Spring Framework yang berisi seluruh konfigurasi aplikasi. Isinya :</p>

<ul>
<li>konfigurasi database</li>
<li>mapping ORM (kalau pakai ORM)</li>
<li>semua object yang dimanage Spring</li>
</ul>


<p>Intinya, ini adalah object yang besar sekali dan sangat kompleks. Object seperti ini biasanya hanya dibuat sekali saja sepanjang aplikasi dijalankan. Bila kita taruh dalam method seperti di atas, maka tiap kali ada user simpan data produk, object besar tersebut akan dibuat, sehingga menghabiskan memori.</p>

<p>Pesan moralnya, pahami library yang digunakan supaya tahu karakteristik dan cara kerjanya.</p>

<h2>Penggunaan collection yang kurang benar</h2>

<p>Collection (Set, Map, List) adalah object yang menampung object lain. Kita harus memastikan bahwa object ini berada dalam scope yang benar. Lihat kode program berikut</p>

<p>```java
public class Coba {</p>

<pre><code>private static List&lt;Integer&gt; noSurat = new ArrayList&lt;Integer&gt;();
private static Integer noTerakhir = 0;

public void bikinSuratBaru(){
    noTerakhir++;
    noSurat.add(noTerakhir);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Pada kode di atas, <code>noSurat</code> memiliki scope static, sehingga dia akan terus ada selama aplikasi berjalan. Bila aplikasi tidak mati dalam waktu yang lama, dan dalam sehari ada 1 juta surat baru, tinggal tunggu waktu saja sampai kena OOM.</p>

<h1>Panduan Solusi Umum</h1>

<p>Selain yang disebutkan di atas, masih banyak penyebab lain, yang paling sering terjadi adalah yang dibahas di atas. Kalau penyebab OOM tidak kita atasi, berapapun memori yang kita sediakan (melalui <code>Xms</code> dan <code>Xmx</code>) tidak akan cukup. Inilah sebabnya saya katakan bahwa <code>Xms</code> dan <code>Xmx</code> itu bukan solusi untuk OOM. Yang harus kita lakukan adalah <strong>mengendalikan pemakaian</strong> memori, bukan <strong>menambah</strong> memori.</p>

<p>Jadi kalau menemukan OOM, coba dicek lagi kode programnya.
Tidak perlu pakai VisualVM atau tools2 lain, cukup code review aja.</p>

<p>Dibaca satu2 source codenya, untuk tiap baris, tanyakan pertanyaan ini :</p>

<ol>
<li>Method/statement ini akan dipanggil seberapa sering?</li>
<li>Looping ini akan berputar maksimal berapa kali?</li>
<li>Berapa kira2 ukuran tiap row yang ditarik dalam query? Sekali tarik berapa row?</li>
<li>Setelah saya tarik row, kapan dia selesai digunakan? Apakah nunggu PDF jadi dulu baru selesai (inilah kandidat OOM), atau tiap selesai satu halaman PDF sudah bisa direlease?</li>
</ol>


<p>Mudah-mudahan dengan adanya artikel ini tidak ada lagi orang yang mengobati OOM dengan <code>System.gc</code> atau <code>Xmx</code>.</p>

<h2>Referensi</h2>

<ul>
<li><a href="http://java.dzone.com/news/how-fix-memory-leaks-java">How to fix memory leaks in Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengetes Akses Database]]></title>
    <link href="http://software.endy.muhardin.com/java/mengetes-akses-database/"/>
    <updated>2013-06-05T11:49:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengetes-akses-database</id>
    <content type="html"><![CDATA[<p>Pada bagian ini, kita akan mempersiapkan seperangkat kode program untuk mengetes aplikasi yang telah kita buat.</p>

<p>Artikel ini merupakan bagian kelima dan terakhir dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h2>Setup Test</h2>

<p>Seperti telah dijelaskan sebelumnya, test class kita akan terdiri dari dua bagian:</p>

<ol>
<li>Abstract superclass : berisi seluruh kode program pengetesan aplikasi</li>
<li>Concrete subclass : berisi kode program untuk melakukan inisialisasi</li>
</ol>


<p>Berikut adalah kerangka abstract superclass test untuk <code>Produk</code></p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import statement, generate menggunakan IDE</p>

<p>public abstract class ProdukServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {

}

@Test
public void testSimpanUpdateHapusProduk() throws Exception {

}

// test method lain tidak ditampilkan
</code></pre>

<p>}
```</p>

<p>Dan berikut ini adalah concrete subclass yang berfungsi melakukan inisialisasi konfigurasi Spring JDBC</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import statement generate menggunakan IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class ProdukServiceSpringJdbcTest extends ProdukServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>Database Reset</h2>

<p>Pada kode program abstract superclass di atas, kita melihat ada method untuk membersihkan data test. Method ini diberikan annotation <code>@Before</code> supaya dia dijalankan <strong>sebelum masing-masing test</strong>.</p>

<p>Berikut adalah isi method tersebut</p>

<p>```java
@Before
public void bersihkanDataTest() throws Exception {</p>

<pre><code>DataSource ds = getDataSource();
Connection conn = ds.getConnection();

String sql = "delete from m_produk where kode like ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setString(1,"T-001%");
ps.executeUpdate();
conn.close();
</code></pre>

<p>}
```</p>

<p>Di method tersebut, kita menghapus semua produk yang kodenya diawali <code>T-001</code>. Ini adalah data yang kita insert selama proses tes. Agar tidak mengganggu tes lainnya, kita hapus data percobaan tersebut.</p>

<h2>Test Insert Update Delete</h2>

<p>Proses insert, update, dan delete mengubah data yang ada dalam database. Supaya kita tidak repot mengurus data sample yang sudah ada di database, ketiga proses ini kita tes dalam satu kesatuan. Dengan demikian, setelah selesai dijalankan, datanya kembali bersih seperti sebelumnya. Berikut kode programnya.</p>

<p>```java
@Test
public void testSimpanUpdateHapusProduk() throws Exception{</p>

<pre><code>Produk p = new Produk();
p.setHarga(new BigDecimal(125000));
p.setKode("T-001");
p.setNama("Produk Test 001");

PenjualanService service = getPenjualanService();
service.simpan(p);
assertNotNull(p.getId());

Connection conn = getDataSource().getConnection();
PreparedStatement psCariById 
        = conn.prepareStatement
            ("select * from m_produk where id = ?");
psCariById.setInt(1, p.getId());
ResultSet rs = psCariById.executeQuery();

// test nilai awal
assertTrue(rs.next());
assertEquals("T-001",rs.getString("kode"));

// update record
p.setKode("T-001x");
service.simpan(p);

// test query setelah update
rs = psCariById.executeQuery();

assertTrue(rs.next());
assertEquals("T-001x",rs.getString("kode"));

// test delete
service.hapus(p);

// test query setelah hapus
rs = psCariById.executeQuery();

assertFalse(rs.next());
</code></pre>

<p>}
```</p>

<p>Dari komentar yang ada dalam kode program, sudah jelas apa maksud dari masing-masing bagian.</p>

<h2>Test Query</h2>

<p>Selanjutnya kita melakukan tes terhadap query. Kita mulai dari yang sederhana dulu, yaitu tabel produk.
Berikut kode program pengetesannya.</p>

<p>```java
@Test
public void testCariProdukById() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukById(1));
assertNull(service.cariProdukById(99));
</code></pre>

<p>}</p>

<p>@Test
public void testCariProdukByKode() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukByKode("K-001"));
assertNull(service.cariProdukByKode("X-001"));
</code></pre>

<p>}</p>

<p>@Test
public void testHitungSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertEquals(Long.valueOf(3), 
    Long.valueOf(service.hitungSemuaProduk()));
</code></pre>

<p>}</p>

<p>@Test
public void testCariSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
List&lt;Produk&gt; hasil = service.cariSemuaProduk(1, 100);
assertNotNull(hasil);
assertTrue(hasil.size() == 3);
for (Produk produk : hasil) {
    assertNotNull(produk.getId());
    assertNotNull(produk.getKode());
    assertNotNull(produk.getNama());
    assertNotNull(produk.getHarga());
}
</code></pre>

<p>}
```</p>

<p>Logika pengetesan tidak kompleks. Kita query datanya menggunakan method di <code>ProdukDao</code> yang telah kita buat,
lalu kita bandingkan dengan kondisi yang seharusnya. Perbandingan dilakukan menggunakan method yang telah disediakan JUnit, yaitu method berawalan <code>assert</code>, misalnya <code>assertNotNull</code>, <code>assertEquals</code>, dan lainnya.</p>

<p>Yang harus diperhatikan di sini adalah, kita harus benar-benar tahu persis isi database supaya test ini bisa berjalan dengan baik. Ada banyak teknik yang bisa digunakan untuk memastikan isi database sebelum tes dijalankan, salah satunya menggunakan tools yang bernama <a href="http://www.dbunit.org/">DBUnit</a>. Lebih lanjut tentang cara menggunakan DBUnit bisa dibaca di <a href="http://software.endy.muhardin.com/java/ruthless-testing-4/">artikel ini</a>.</p>

<h2>Test Relasi</h2>

<p>Pengetesan terhadap relasi pada prinsipnya tidak berbeda. Hanya ada sedikit tambahan yaitu kita juga harus memastikan apakah relasinya berhasil terisi dengan sempurna. Berikut pengetesannya.</p>

<p>```java
@Test</p>

<pre><code>public void testCariPenjualanDetailByProdukDanPeriode(){
Produk p = new Produk();
p.setId(1);

Date mulai = new DateTime(2013,1,1,0,0,0,0).toDate();
Date sampai = new DateTime(2013,2,1,0,0,0,0).toDate();

List&lt;PenjualanDetail&gt; hasil = getPenjualanService()
        .cariPenjualanDetailByProdukDanPeriode(p, 
            mulai, sampai, 1, 100);

assertNotNull(hasil);
assertTrue(hasil.size() == 2);

for (PenjualanDetail penjualanDetail : hasil) {
    verifikasiPenjualanDetail(penjualanDetail);
}
</code></pre>

<p>}
```</p>

<p>Pada kode program di atas, terlihat bahwa kita melakukan looping yang di dalamnya ada verifikasi <code>PenjualanDetail</code>. Berikut isi methodnya.</p>

<p>```java
private void verifikasiPenjualanDetail</p>

<pre><code>    (PenjualanDetail penjualanDetail) {
assertNotNull(penjualanDetail.getProduk().getHarga());
assertNotNull(penjualanDetail.getPenjualan().getWaktuTransaksi());
</code></pre>

<p>}
```</p>

<p>Kita cukup memastikan bahwa relasi yang dimiliki <code>PenjualanDetail</code> yaitu <code>Produk</code> dan <code>Penjualan</code> tidak null. Demikian juga variabel yang ada di dalam objectnya yaitu <code>harga</code> dan <code>waktuTransaksi</code>.</p>

<p>Demikianlah rangkaian artikel tentang penggunaan Spring JDBC. Kode program selengkapnya dapat diambil <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc">di Github</a>.
Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Query dengan Spring JDBC]]></title>
    <link href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/"/>
    <updated>2013-06-03T20:08:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/query-dengan-spring-jdbc</id>
    <content type="html"><![CDATA[<p>Pada artikel sebelumnya kita telah bisa mengubah data dalam database, baik menambah (insert), mengubah (update), maupun menghapus (data). Kali ini kita akan membahas tentang cara pengambilan data (select) dari dalam database.</p>

<p>Artikel ini merupakan bagian keempat dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<p>Pada dasarnya, untuk mengambil data dari database hanya ada dua varian yang kita gunakan, yaitu:</p>

<ul>
<li>mengambil data tunggal, gunakan method <code>queryForObject</code></li>
<li>mengambil data banyak, gunakan method <code>queryForList</code> atau <code>query</code> saja</li>
</ul>


<p>Kita lihat dulu implementasi yang paling mendasar, ambil semua data produk dari database. Berikut deklarasi SQLnya.</p>

<p>```java
private static final String SQL_CARI_SEMUA</p>

<pre><code>= "select * from m_produk limit ?,?";
</code></pre>

<p>```</p>

<p>Perintah SQL di atas akan dipakai dalam method <code>cariSemua</code> sebagai berikut</p>

<p>```java
public List<Produk> cariSemua(Integer halaman, Integer baris) {</p>

<pre><code>return jdbcTemplate.query(SQL_CARI_SEMUA,
        new ResultSetJadiProduk(),
        PagingHelper.halamanJadiStart(halaman, baris),
        baris);
</code></pre>

<p>}
```</p>

<p>Pada contoh di atas, kita menggunakan method <code>query</code> yang menerima tiga argumen, yaitu:</p>

<ul>
<li>SQL yang akan dijalankan, berupa String</li>
<li>Class yang bertugas mengubah ResultSet menjadi object yang kita inginkan, dalam hal ini object <code>Produk</code>. Class ini akan kita buat sendiri, yaitu class <code>ResultSetJadiProduk</code>.</li>
<li>argumen lain-lain (varargs). Ini merupakan fitur Java sejak versi 5 yang artinya kita bisa memasukkan argumen sebanyak-banyaknya dalam method. Argumen ini akan dikonversi menjadi List untuk diproses oleh method <code>query</code></li>
</ul>


<p>Jadi, bukan salah ketik kalau di atas saya sebut tiga argumen padahal kita memasukkan empat variabel ke dalamnya.</p>

<p>SQL select tentu tidak perlu kita bahas lagi, mari masuk ke class <code>ResultSetJadiProduk</code></p>

<h2>Membuat Mapper</h2>

<p>Class <code>ResultSetJadiProduk</code> bertugas mengkonversi hasil query ke database yang ada dalam class <code>ResultSet</code> menjadi object <code>Produk</code>. Implementasinya tidak rumit, ini dia.</p>

<p>```java
private class ResultSetJadiProduk implements RowMapper<Produk> {</p>

<pre><code>@Override
public Produk mapRow(ResultSet rs, int i) throws SQLException {
    Produk p = new Produk();
    p.setId((Integer) rs.getObject("id"));
    p.setKode(rs.getString("kode"));
    p.setNama(rs.getString("nama"));
    p.setHarga(rs.getBigDecimal("harga"));
    return p;
}
</code></pre>

<p>}
```</p>

<p>Kita membuatnya sebagai class di dalam class (inner class). Kalau lupa dengan strukturnya, silahkan baca lagi bab dua tentang Struktur Aplikasi.</p>

<p>Class ini harus implement interface <code>RowMapper&lt;T&gt;</code> milik Spring. <code>T</code> diganti dengan class yang menjadi tujuan konversi. Interface <code>RowMapper&lt;T&gt;</code> ini mewajibkan kita membuat method <code>mapRow</code>. Isi method tersebut sudah cukup jelas sehingga tidak perlu dijelaskan.</p>

<p>Class ini nantinya bisa kita gunakan juga di query yang menghasilkan satu object <code>Produk</code> seperti <code>cariById</code> dan <code>cariByKode</code>. Berikut implementasinya</p>

<p>```java
public Produk cariById(Integer id) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiProduk(), id);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}</p>

<p>public Produk cariByKode(String kode) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_KODE, 
        new ResultSetJadiProduk(), kode);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Kedua method ini sama saja prinsipnya dengan <code>cariSemua</code> yang sudah kita bahas sebelumnya.</p>

<h2>Mengambil data berelasi</h2>

<p>Setelah berhasil mengambil data dari satu produk, mari kita coba untuk berurusan dengan data berelasi. Sebetulnya prinsipnya sama saja, yaitu membuatkan class konversi. Bedanya hanya terletak pada query SQL yang menggunakan join, tidak ada hubungannya dengan Spring JDBC.</p>

<p>Pada service interface, kita memiliki fitur rekap transaksi untuk satu produk tertentu, yang dimuat dalam method <code>cariPenjualanDetailByProdukDanPeriode</code>. Method tersebut memanggil method <code>cariByProdukDanPeriode</code> dalam class <code>PenjualanDetailDao</code>. Berikut implementasinya.</p>

<p>```java
public class PenjualanDetailDao {</p>

<pre><code>private static final String SQL_CARI_BY_PRODUK_DAN_PERIODE 
        = "select pd.*, p.waktu_transaksi, "
        + "produk.kode as kode_produk, produk.nama as nama_produk,"
        + "produk.harga as harga_produk "
        + "from t_penjualan_detail pd "
        + "inner join t_penjualan p on pd.id_penjualan = p.id "
        + "inner join m_produk produk on pd.id_produk = produk.id " 
        + "where pd.id_produk = ? " +
        + "and (p.waktu_transaksi between ? and ?) " +
        + "limit ?,?";

public List&lt;PenjualanDetail&gt; cariByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai, Integer halaman, Integer baris) {
    return jdbcTemplate.query(SQL_CARI_BY_PRODUK_DAN_PERIODE, 
            new ResultSetJadiPenjualanDetail(), 
            p.getId(), 
            mulai, 
            sampai, 
            PagingHelper.halamanJadiStart(halaman, baris), 
            baris);
}
</code></pre>

<p>}
```</p>

<p>Konversi dari <code>ResultSet</code> menjadi <code>PenjualanDetail</code> dilakukan dalam class <code>ResultSetJadiPenjualanDetail</code> berikut</p>

<p>```java
private class ResultSetJadiPenjualanDetail</p>

<pre><code>    implements RowMapper&lt;PenjualanDetail&gt; {

@Override
public PenjualanDetail mapRow(ResultSet rs, int i) 
        throws SQLException {
    PenjualanDetail p = new PenjualanDetail();
    p.setId((Integer) rs.getObject("id"));
    p.setHarga(rs.getBigDecimal("harga"));
    p.setJumlah((Integer) rs.getObject("jumlah"));

    // relasi ke produk
    Produk px = new Produk();
    px.setId((Integer) rs.getObject("id_produk"));
    px.setKode(rs.getString("kode_produk"));
    px.setNama(rs.getString("nama_produk"));
    px.setHarga(rs.getBigDecimal("harga_produk"));
    p.setProduk(px);

    // relasi ke penjualan
    Penjualan jual = new Penjualan();
    jual.setId((Integer) rs.getObject("id_penjualan"));
    jual.setWaktuTransaksi(rs.getDate("waktu_transaksi"));
    p.setPenjualan(jual);

    return p;
}
</code></pre>

<p>}
```</p>

<p>Selain class <code>PenjualanDetail</code> itu sendiri, kita juga membuatkan object <code>Produk</code> dan <code>Penjualan</code> yang kemudian akan dipasang pada object <code>PenjualanDetail</code>.</p>

<h2>Pagination</h2>

<p>Dalam mengambil data yang berjumlah banyak seperti data transaksi, biasanya kita akan melakukan <em>pagination</em>, yaitu membagi data menjadi beberapa halaman. Di MySQL, kita menggunakan keyword <code>LIMIT</code> untuk melakukan hal ini. Keyword <code>LIMIT</code> menerima dua argumen, yaitu nomer record pertama yang mau diambil dan jumlah record yang mau diambil. Jadi bila kita ingin mengambil record 11 - 15, kita menggunakan keyword <code>LIMIT 11, 5</code>.</p>

<p>Ini agak berbeda dengan argumen yang diterima dalam method pencarian kita. Yang diminta di situ adalah nomer halaman dan jumlah record per halaman. Jadi kalau misalnya data kita berjumlah 56 record dan kita ingin setiap halaman berisi 10 record, maka data tersebut akan terbagi menjadi 6 halaman. Bila kita ingin mengambil halaman terakhir, kita memberikan argumen <code>6</code> dan <code>10</code> ke dalam method pencarian.</p>

<p>Tentunya harus ada konversi dari nomer halaman menjadi nomer baris. Ini kita lakukan di class <code>PagingHelper</code> yang isinya sebagai berikut.</p>

<p>```java
public class PagingHelper {</p>

<pre><code>public static Integer halamanJadiStart(Integer halaman, 
        Integer baris){
    if (halaman &lt; 1) {
        return 0;
    }
    return (halaman - 1) * baris;
}
</code></pre>

<p>}
```</p>

<h2>Header Detail</h2>

<p>Dalam aplikasi, pasti ada fitur untuk menampilkan daftar transaksi dalam periode tertentu.
Seperti sudah kita bahas, satu transaksi terdiri dari satu header dan beberapa detail.
Data ini tentu ingin kita ambil semua.</p>

<p>Caranya sederhana :</p>

<ol>
<li>Query dulu headernya: <code>select * from t_penjualan where id = ?</code></li>
<li>Query detailnya: <code>select * from t_penjualan_detail where id_penjualan = ?</code></li>
<li>Gabungkan keduanya</li>
</ol>


<p>Berikut contohnya, pada waktu kita ingin mencari <code>Penjualan</code> berdasarkan <code>id</code></p>

<p>```java
public Penjualan cariById(Integer id) {</p>

<pre><code>try {
    Penjualan p = jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiPenjualan(), id);
    List&lt;PenjualanDetail&gt; daftarDetail = penjualanDetailDao
        .cariByPenjualan(p);
    p.setDaftarPenjualanDetail(daftarDetail);
    return p;
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Di sana, kita memanggil method <code>cariByPenjualan</code> yang ada di class <code>PenjualanDetailDao</code>. Berikut kode programnya</p>

<p>```java
public List<PenjualanDetail> cariByPenjualan(Penjualan p){</p>

<pre><code>List&lt;PenjualanDetail&gt; hasil 
    = jdbcTemplate.query(SQL_CARI_BY_ID_PENJUALAN, 
        new ResultSetJadiPenjualanDetail(), p.getId());

// set relasi ke penjualan
for (PenjualanDetail penjualanDetail : hasil) {
    penjualanDetail.setPenjualan(p);
}

return hasil;
</code></pre>

<p>}
```</p>

<p>Kembali ke <code>PenjualanDao</code>, setelah kita mendapatkan <code>List&lt;PenjualanDetail&gt;</code> dari method di atas, kita pasang di object penjualan yang sudah kita dapatkan di baris ini</p>

<p><code>java
p.setDaftarPenjualanDetail(daftarDetail);
</code></p>

<p>Demikianlah cara kita mengambil data dari database menggunakan Spring JDBC.
Hal ini tentu tidak rumit asalkan kita sudah paham dasar-dasar SQL termasuk cara melakukan join antar tabel.
Jadi kesimpulannya, untuk mengambil data menggunakan Spring JDBC, yang perlu kita lakukan hanyalah:</p>

<ol>
<li>Membuat SQL, lengkap dengan join bila perlu. Contohnya bisa dilihat di class <code>PenjualanDetailDao</code> yang memiliki banyak join.</li>
<li>Membuat class untuk mengkonversi dari <code>ResultSet</code> menjadi object yang kita inginkan, misalnya <code>Produk</code> atau <code>Penjualan</code></li>
</ol>


<p>Pada bagian selanjutnya, kita tinggal <a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">mengetes kode program</a> yang telah kita buat ini.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert Update Delete dengan Spring JDBC]]></title>
    <link href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/"/>
    <updated>2013-05-31T13:26:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc</id>
    <content type="html"><![CDATA[<p>Setelah pada artikel sebelumnya kita membuat konfigurasi database dan membuat kerangka aplikasi, kali ini kita akan membuat implementasi akses database menggunakan Spring JDBC.</p>

<p>Artikel ini merupakan bagian ketiga dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h1>Setup DAO</h1>

<p>Supaya bisa diinisialisasi oleh Spring Framework, kita harus menambahkan annotation <code>@Repository</code> di class <code>ProdukDao</code> dan juga class DAO lainnya. Pembahasan lebih detail tentang cara kerja Spring Framework dan fungsinya annotation <code>@Repository</code> dapat dibaca <a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">di artikel ini</a>.</p>

<p>Selanjutnya, kita akan menambahkan beberapa variabel yang nantinya akan kita butuhkan, yaitu <code>JdbcTemplate</code> dan perintah SQL yang ingin dijalankan.</p>

<h2>JDBC Template</h2>

<p><code>JdbcTemplate</code> adalah class utama dalam Spring JDBC. Semua operasi database dilakukan melalui JdbcTemplate. Kita juga butuh rekannya yang bernama <code>NamedParameterJdbcTemplate</code>. Kelebihan dari <code>NamedParameterJdbcTemplate</code> ini, dia bisa menerima SQL dengan variabel yang diberi nama. Tanpa dia, kita cuma bisa menjalankan SQL yang variabelnya ditandai dengan <code>?</code>, sehingga membingungkan dan rawan terjadi kesalahan kalau jumlah variabelnya banyak.</p>

<p>Kedua object ini kita deklarasikan menjadi object/instance variable, supaya bisa digunakan oleh semua method. Inisialisasinya membutuhkan object <code>DataSource</code>, sehingga sebaiknya kita lakukan inisialisasi di dalam setter injection. Bagi yang belum paham apa itu setter injection silahkan baca dulu <a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">artikel ini</a>.</p>

<p>Berikut adalah kode programnya.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private JdbcTemplate jdbcTemplate;
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}
</code></pre>

<p>}
```</p>

<h2>SQL</h2>

<p>Agar lebih rapi, semua perintah SQL yang kita akan gunakan di dalam method sebaiknya kita deklarasikan sebagai konstanta. Berikut adalah berbagai SQL yang kita gunakan.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private static final String SQL_INSERT = "insert into m_produk (kode,nama,harga) values (:kode,:nama,:harga)";
private static final String SQL_CARI_BY_ID = "select * from m_produk where id = ?";
private static final String SQL_CARI_BY_KODE = "select * from m_produk where kode = ?";
private static final String SQL_HITUNG_SEMUA = "select count(*) from m_produk";
private static final String SQL_CARI_SEMUA = "select * from m_produk limit ?,?";
private static final String SQL_HITUNG_BY_NAMA = "select count(*) from m_produk where lower(nama) like ?";
private static final String SQL_CARI_BY_NAMA = "select * from m_produk where lower(nama) like ? limit ?,?";
</code></pre>

<p>}
```</p>

<p>Harap diperhatikan bahwa saya hanya menampilkan potongan kode program yang berkaitan dengan penjelasan saat ini saja, berikut sedikit tambahan supaya jelas di mana penempatannya. Untuk isi kode program yang lengkap silahkan lihat <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc/src/main/java/com/muhardin/endy/training/java/aksesdb/dao/springjdbc">di Github</a>.</p>

<h1>Insert Data</h1>

<p>Setelah kita punya <code>JdbcTemplate</code> dan perintah SQL, kita bisa gunakan untuk menyimpan data ke database.
Mari kita implement method <code>simpan</code>.</p>

<h2>Menggunakan parameter domain object</h2>

<p>Class <code>Produk</code> memiliki properti yang bernama <code>kode</code>, <code>nama</code>, dan <code>harga</code>. Karena kita mengikuti aturan penamaan yang baku, maka kita buatkan method getter dan setter. Class yang dibuat mengikuti standar ini bisa langsung diproses oleh Spring JDBC. Dia akan secara otomatis memasangkan properti yang namanya sama dengan yang ada di perintah SQL. Jadi perintah SQL seperti ini</p>

<p><code>sql
insert into m_produk (kode,nama,harga) values (:kode,:nama,:harga)
</code></p>

<p>Akan diisikan dengan nilai yang didapat dari pemanggilan method berikut:</p>

<p>```java
Produk p; // nantinya p diisi dari method parameter</p>

<p>p.getKode();
p.getNama();
p.getHarga();
```</p>

<p>Spring JDBC juga akan secara otomatis mendeteksi tipe data baik itu <code>Integer</code>, <code>String</code>, <code>BigDecimal</code>, dan sebagainya.</p>

<p>Berikut adalah implementasi method <code>simpan</code> yang menggunakan konsep di atas.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(p);
KeyHolder keyHolder = new GeneratedKeyHolder();
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></pre>

<p>}
```</p>

<p><code>BeanPropertySqlParameterSource</code> adalah class dari Spring JDBC yang berfungsi mengambil parameter dari Java object seperti telah dijelaskan di atas. Selain mengambil dari object dengan getter dan setter, ada lagi class lain yang bernama <code>MapSqlParameterSource</code>, digunakan untuk mengambil parameter dari object bertipe <code>java.util.Map</code>.</p>

<h2>Mendapatkan nilai yang auto generated</h2>

<p>Di tabel <code>m_produk</code>, primary key ada di kolom <code>id</code>. Nilainya digenerate otomatis oleh database pada saat kita melakukan insert. Kita perlu mengetahui nilai berapa yang dibuatkan database untuk data yang barusan kita insert agar bisa dipasang di object <code>Produk</code> yang kita insert. Untuk menampung nilai yang otomatis dibuatkan database, kita menggunakan class <code>GeneratedKeyHolder</code>.</p>

<p>Setelah kita melakukan insert, <code>keyHolder</code> akan menampung nilai. Nilai inilah yang kita pasang di object produk dengan kode program berikut.</p>

<p><code>java
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></p>

<h2>Menggunakan SimpleJdbcInsert</h2>

<p>Object <code>produk</code> di atas hanya memiliki 4 property di Java dan 4 kolom di database. Bila propertynya banyak, tentu kita akan kerepotan menulis variabel dalam perintah SQL. Untuk membantu kita, Spring JDBC menyediakan fitur <code>SimpleJdbcInsert</code>. Cara kerjanya, dia akan <em>menanyakan</em> ke database kolom apa saja yang ada di tabel tertentu berikut tipe data untuk masing-masing kolom. Setelah itu, informasi tersebut digunakan untuk membuatkan SQL insert buat kita, sehingga kita tidak perlu membuat sendiri.</p>

<p>Berikut adalah cara inisialisasi <code>SimpleJdbcInsert</code>, dilakukan di setter injection.</p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>private SimpleJdbcInsert insertProduk;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.insertProduk = new SimpleJdbcInsert(dataSource)
            .withTableName("m_produk")
            .usingGeneratedKeyColumns("id");
}
</code></pre>

<p>}
```</p>

<p>Kita menyebutkan juga kolom mana yang nilainya digenerate database, sehingga dia bisa mengambilkannya. Selanjutnya, mari kita ganti implementasi method <code>simpan</code> dengan memanfaatkan <code>SimpleJdbcInsert</code>.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>SqlParameterSource produkParameter = new BeanPropertySqlParameterSource(p);
Number idBaru = insertProduk.executeAndReturnKey(produkParameter);
p.setId(idBaru.intValue());
</code></pre>

<p>}
```</p>

<h2>Insert Data Header dan Detail</h2>

<p><blockquote><p>Kenapa kita perlu mengambil primary key yang digenerate database?</p></blockquote></p>

<p>Jawabannya karena kita membutuhkannya dalam skenario header dan detail. Di tabel detail, ada relasi foreign key ke tabel header. Sehingga untuk mengisi foreign key tersebut, kita harus mengetahui dulu primary key header.</p>

<p>Selain masalah foreign key ini, sisanya sama dengan pembahasan insert sebelumnya. Berikut implementasi method <code>simpan(Penjualan p)</code></p>

<p>```java
public void simpan(Penjualan p) {</p>

<pre><code>SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(p);
KeyHolder keyHolder = new GeneratedKeyHolder();
namedParameterJdbcTemplate.update(SQL_INSERT, namedParameters, keyHolder);
p.setId(keyHolder.getKey().intValue());

for (PenjualanDetail detail : p.getDaftarPenjualanDetail()) {
    detail.setPenjualan(p);
    penjualanDetailDao.simpan(detail);
}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat pada kode program di atas, kita insert ke tabel <code>t_penjualan</code>, kemudian kita ambil nilai <code>id</code>. Nilai tersebut kita isikan ke tiap object detail untuk selanjutnya kita insert juga menggunakan method <code>simpan(PenjualanDetail pd)</code> di class <code>PenjualanDetailDao</code>. Berikut implementasinya.</p>

<p>```java
public void simpan(final PenjualanDetail p) {</p>

<pre><code>KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(new PreparedStatementCreator() {

    @Override
    public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {
        PreparedStatement ps = conn.prepareStatement(SQL_INSERT, new String[]{"id"});
        ps.setInt(1, p.getPenjualan().getId());
        ps.setInt(2, p.getProduk().getId());
        ps.setBigDecimal(3, p.getHarga());
        ps.setInt(4, p.getJumlah());
        return ps;
    }
}, keyHolder);
p.setId(keyHolder.getKey().intValue());
</code></pre>

<p>}
```</p>

<p>Pada waktu menyimpan <code>PenjualanDetail</code>, kita menggunakan teknik yang agak berbeda, tidak menggunakan <code>SimpleJdbcInsert</code> maupun <code>NamedParameterJdbcTemplate</code>. Ini disebabkan karena banyak kolom yang namanya tidak mengikuti aturan penamaan, yaitu <code>id_penjualan</code> dan <code>id_produk</code>. Karena itu kita menggunakan cara yang lebih manual, membuat sendiri <code>PreparedStatement</code> dan kemudian mengisi parameternya.</p>

<p>Walaupun demikian, kita tidak mengeksekusi <code>PreparedStatement</code> tersebut, karena urusan mengeksekusi akan ditangani Spring JDBC supaya bisa dibungkus dalam transaction. Kenapa harus dibungkus dalam transaction? Jawabannya bisa dibaca di <a href="http://software.endy.muhardin.com/java/database-transaction/">artikel ini</a>.</p>

<h1>Update Data</h1>

<p>Pada prinsipnya, update data tidak berbeda dengan insert data. Kita dapat melakukannya dengan cara yang sama seperti insert data di atas. Tapi karena kita ingin melihat fitur-fitur Spring JDBC, baiklah kita lakukan dengan cara yang sedikit berbeda.</p>

<h2>Menggunakan parameter bertipe Map</h2>

<p>Kalau di atas kita sudah menggunakan parameter menggunakan <code>?</code> dan domain object, kali ini kita akan menggunakan <code>Map</code>. Cara ini digunakan bila nama variabel di SQL berbeda dengan nama variabel di domain object, sehingga kita tidak bisa menggunakan <code>BeanPropertySqlParameterSource</code>. Kita juga tidak mau menggunakan <code>?</code> karena rawan terjadi salah ketik.</p>

<p>Kita ubah sedikit method <code>simpan(Produk p )</code> agar bisa menangani penyimpanan data produk baru (insert) maupun penyimpanan data produk lama (update). Berikut kode program method <code>simpan(Produk p )</code> yang baru.</p>

<p>```java
public void simpan(Produk p) {</p>

<pre><code>if (p.getId() == null) {
    SqlParameterSource produkParameter = new BeanPropertySqlParameterSource(p);
    Number idBaru = insertProduk.executeAndReturnKey(produkParameter);
    p.setId(idBaru.intValue());
} else {
    SqlParameterSource produkParameter = new MapSqlParameterSource()
            .addValue("id_produk", p.getId())
            .addValue("kode_produk", p.getKode())
            .addValue("nama_produk", p.getNama())
            .addValue("harga_produk", p.getHarga());
    namedParameterJdbcTemplate.update(SQL_UPDATE_PRODUK, produkParameter);
}
</code></pre>

<p>}
```</p>

<p>Agar lebih jelas, kita tampilkan juga deklarasi <code>SQL_UPDATE_PRODUK</code>.</p>

<p>```java
private static final String SQL_UPDATE_PRODUK</p>

<pre><code>= "update m_produk set kode = :kode_produk, nama = :nama_produk, harga = :harga_produk where id = :id_produk";
</code></pre>

<p>```</p>

<p>Penggunaan <code>MapSqlParameterSource</code> dapat dilihat di blok <code>else</code>. Argumen kiri dari method <code>addValue</code> adalah nama variabel dalam <code>SQL_UPDATE_PRODUK</code>, sedangkan argumen kanan adalah nilai yang ingin diisikan.</p>

<h1>Delete Data</h1>

<p>Bila kita sudah menguasai insert dan update, maka delete seharusnya tidak menjadi masalah. Berikut kode program untuk menghapus data produk.</p>

<p>```java
public void hapus(Produk p) {</p>

<pre><code>jdbcTemplate.update(SQL_HAPUS, p.getId());
</code></pre>

<p>}
```</p>

<p>Berikut deklarasi <code>SQL_HAPUS</code></p>

<p><code>java
private static final String SQL_HAPUS = "delete from m_produk where id = ?";
</code></p>

<p>Menghapus <code>penjualan</code> yang memiliki relasi header detail juga tidak sulit. Pastikan kita menghapus detailnya dulu sebelum menghapus headernya agar tidak terjadi pelanggaran <a href="http://en.wikipedia.org/wiki/Referential_integrity">referential integrity</a>.</p>

<p>Berikut contoh pesan error bila kita menghapus data produk yang sudah dipakai dalam transaksi.</p>

<p><code>
org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback;
SQL [delete from m_produk where id = ?];
Cannot delete or update a parent row:
a foreign key constraint fails (`belajar`.`t_penjualan_detail`,
CONSTRAINT `t_penjualan_detail_ibfk_2` FOREIGN KEY (`id_produk`)
REFERENCES `m_produk` (`id`));
nested exception is
com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException:
Cannot delete or update a parent row:
a foreign key constraint fails (`belajar`.`t_penjualan_detail`,
CONSTRAINT `t_penjualan_detail_ibfk_2` FOREIGN KEY (`id_produk`)
REFERENCES `m_produk` (`id`))
</code></p>

<p>Pada pesan error di atas, data <code>produk</code> tidak bisa dihapus karena sudah digunakan sebagai relasi foreign key dari <code>penjualan detail</code>.</p>

<p>Demikianlah penjelasan tentang insert, update, dan delete data. Nantikan <a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">bagian selanjutnya</a> yang membahas tentang query select.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struktur Aplikasi Java dengan Spring dan Maven]]></title>
    <link href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/"/>
    <updated>2013-05-28T15:06:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven</id>
    <content type="html"><![CDATA[<p>Pada <a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">bagian sebelumnya</a> kita telah membahas konfigurasi awal
dan studi kasus yang akan digunakan untuk menunjukkan fitur Spring JDBC.</p>

<p>Di artikel bagian kedua ini, kita akan membahas tentang kerangka aplikasi yang akan dibuat.
Sebelum membuat implementasi detail, sangat penting kita buat dulu kerangkanya supaya jelas
apa saja bagian-bagian dalam aplikasi dan bagaimana mereka saling terhubung.</p>

<p>Artikel ini merupakan bagian kedua dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h2>Daftar class yang akan dibuat</h2>

<p>Class yang akan dibuat kita bagi menjadi empat fungsi utama, yaitu:</p>

<ul>
<li>domain object : class yang mewakili struktur data dalam aplikasi kita</li>
<li>interface business service : class yang mendefinisikan daftar fitur-fitur dalam aplikasi</li>
<li>implementasi business service : implementasi dari interface business service. Kalau di interface hanya ada nama method, argumen, dan tipe data kembalian (return value), di sini sudah ada implementasi konkritnya, yaitu bagaimana query database, logika perhitungan, dan sebagainya.</li>
<li>automated test : memeriksa apakah method kita berjalan benar itu melelahkan. Jadi kita buatkan kode program untuk mengetesnya, sehingga tes yang sama bisa dijalankan berulang-ulang tanpa membuat kita lelah. Lebih lanjut tentang automated test bisa dibaca di <a href="http://software.endy.muhardin.com/java/ruthless-testing-1/">artikel lain yang membahas masalah ini</a>.</li>
</ul>


<h3>Domain Object</h3>

<p>Sesuai dengan skema database, kita akan membuat tiga class, yaitu:</p>

<ul>
<li>Produk</li>
<li>Penjualan</li>
<li>PenjualanDetail</li>
</ul>


<p>Buat yang sudah pernah coding JDBC biasanya akan bertanya,</p>

<p><blockquote><p>Kenapa repot-repot membuat domain class, kemudian harus konversi bolak balik?<br/>Kan bisa saja kita kirim <code>ResultSet</code> ke tampilan, ataupun insert langsung dari array ke <code>PreparedStatement</code>.</p></blockquote></p>

<p>Pertanyaan ini biasanya muncul dari programmer PHP yang terbiasa langsung menampilkan kembalian <code>mysql_fetch_array</code> dalam looping tabel.</p>

<p>Ada beberapa alasan:</p>

<ol>
<li><p>Sebenarnya bisa saja kita buat aplikasi dengan menggunakan tipe data yang disediakan Java seperti Integer, String, Map, List, dan lainnya. Tapi akibatnya kode program kita menjadi sulit dimengerti. Coba bandingkan, lebih mudah dimengerti <code>public void simpan(Produk p)</code> atau <code>public void simpan(Map p)</code>? Dengan membuat tipe data sesuai istilah yang digunakan di domain kita, maka kode program akan lebih mudah dipahami.</p></li>
<li><p>Java merupakan bahasa yang <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a>, dia memeriksa tipe data/class dari tiap variabel. Pada ilustrasi di atas, method <code>public void simpan(Map p)</code> akan menerima apapun data yang kita masukkan ke dalam variabel <code>p</code>. Kalau ada kesalahan dalam nama variabel (misalnya nama ditulis name), baru akan terdeteksi pada waktu aplikasi dijalankan. Berbeda dengan <code>public void simpan(Produk p)</code> yang akan langsung menimbulkan pesan error apabila kita isi dengan tipe data selain <code>Produk</code>. Bug yang ditemukan pada waktu coding (compile-time) akan jauh lebih cepat diperbaiki daripada bug yang baru ditemukan pada waktu aplikasi dijalankan (runtime). Programmer PHP ada benarnya juga. Di bahasa PHP memang domain class ini tidak diperlukan, karena PHP tidak ada pemeriksaan compile-time. Tapi karena kita menggunakan Java, ada baiknya kita manfaatkan pemeriksaan compile-time ini.</p></li>
<li><p>Memisahkan antara layer database dan layer antarmuka. Apabila ada perubahan skema database, asalkan fitur di tampilan tidak berubah, kita cukup mengubah mapping domain object dan skema database. Tidak perlu mengubah kode program di layer antarmuka.</p></li>
<li><p>Pustaka siap pakai untuk validasi. Di Java, ada yang namanya <a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a>, yaitu suatu pustaka yang berguna untuk validasi. Dengan <a href="http://www.mkyong.com/spring-mvc/spring-3-mvc-and-jsr303-valid-example/">menggunakan JSR-303</a> ini kita tidak perlu lagi melakukan pengecekan <code>if(produk.getKode() == null)</code>. Cukup kita gunakan deklarasi <code>@NotNull private String kode;</code> dalam class <code>Produk</code></p></li>
</ol>


<h3>Interface Business Service</h3>

<p>Interface di Java artinya class yang methodnya abstrak semua. Lebih detail tentang method abstrak bisa dibaca di <a href="http://software.endy.muhardin.com/java/interface-abstract/">artikel ini</a>. Ada beberapa alasan kenapa kita harus memisahkan interface dan implementasinya, antara lain:</p>

<ul>
<li><p>pada waktu <a href="http://software.endy.muhardin.com/java/remoting-dengan-spring/">membuat aplikasi client-server</a>, kita cukup memberikan domain object dan interface ini kepada programmer aplikasi client. Sedangkan implementasinya (yang berisi kode program akses database) tetap di server. Ini akan meringankan ukuran aplikasi client, karena tidak perlu menyertakan implementasi (beserta library pendukungnya yang biasanya besar) yang tidak dia gunakan.</p></li>
<li><p>kita bebas mengubah strategi implementasi (misalnya ganti database dari MySQL menjadi PostgreSQL) tanpa perlu mengganggu aplikasi client</p></li>
<li><p>fitur declarative transaction yang dimiliki Spring akan lebih optimal bekerja bila kita memisahkan interface dan implementasi.</p></li>
</ul>


<p>Interface ini cukup satu class saja, yaitu <code>AplikasiPenjualanService</code>.</p>

<h3>Implementasi Business Service</h3>

<p>Ini merupakan implementasi dari interface <code>AplikasiPenjualanService</code>. Pada prakteknya, ada dua variasi yang biasa saya gunakan dalam membuat implementasi, yaitu:</p>

<ul>
<li>cukup membuat class implementasi service saja</li>
<li>membuat class implementasi service dan juga class data access object (DAO)</li>
</ul>


<p>Kapan memilih variasi yang mana?</p>

<ul>
<li>Bila menggunakan framework Spring Data JPA, kita harus pakai DAO karena frameworknya minta seperti itu</li>
<li>Selain Spring Data JPA, bebas mau pakai yang mana. Pilih saja yang lebih rapi dan mudah maintenance. Untuk aplikasi kecil, class implementasi service saja sudah cukup. Kalau aplikasinya besar, akan lebih mudah membaca 10 class DAO yang masing-masingnya terdiri dari 100 baris kode daripada 1000 baris dalam satu class implementasi service. Walaupun demikian, tidak ada pertimbangan teknis yang signifikan (seperti isu performance dan lainnya) antara pakai DAO atau tidak.</li>
</ul>


<h3>Automated Test</h3>

<p>Ini adalah kode program yang fungsinya mengetes kode program lainnya, dalam hal ini class implementasi dan class DAO. Konsep dasar tentang automated testing dibahas di <a href="http://software.endy.muhardin.com/java/ruthless-testing-1/">artikel ini</a>. Sedangkan untuk pengetesan database dibahas <a href="http://software.endy.muhardin.com/java/ruthless-testing-4/">di sini</a>.</p>

<p>Pada contoh aplikasi ini, kita menghadapi tantangan khusus, yaitu bagaimana caranya menggunakan test case yang sama untuk konfigurasi berbeda. Nantinya aplikasi ini akan dikembangkan untuk mendemonstrasikan akses database menggunakan framework lain seperti Hibernate, Spring Data JPA, dan JDBC polos tanpa framework. Logika pengetesan akan sama persis, yaitu:</p>

<ul>
<li>test insert</li>
<li>test update</li>
<li>test delete</li>
<li>test cari berdasarkan id</li>
<li>test ambil semua data dari tabel tertentu</li>
<li>test cari data dengan kriteria tertentu</li>
</ul>


<p>Tabel database yang diakses sama, sample data sama, bahkan nama method yang dijalankan juga sama. Bedanya hanyalah class implementasi mana yang digunakan dan konfigurasi mana yang dipakai.</p>

<p>Untuk itu, kita akan menggunakan teknik khusus yang disebut <code>abstract junit test case</code>. Secara garis besar, langkahnya seperti ini:</p>

<ol>
<li>Buat semua method test di superclass. Superclass ini memiliki abstract method, sehingga dengan sendirinya dia juga abstract.</li>
<li>Untuk mendapatkan class implementasi dan melakukan inisialisasi konfigurasi, gunakan abstract method</li>
<li>Buat subclass untuk masing-masing implementasi (Spring JDBC, Hibernate, dst) yang hanya berisi implementasi dari abstract method tersebut.</li>
</ol>


<p>Agar lebih jelas, silahkan lihat <a href="https://github.com/endymuhardin/belajar-akses-database-java/blob/spring-jdbc/src/test/java/com/muhardin/endy/training/java/aksesdb/service/ProdukServiceTest.java">superclassnya</a> dan <a href="https://github.com/endymuhardin/belajar-akses-database-java/blob/spring-jdbc/src/test/java/com/muhardin/endy/training/java/aksesdb/service/springjdbc/ProdukServiceSpringJdbcTest.java">subclass untuk Spring JDBC</a>.</p>

<h2>Struktur folder</h2>

<p>Sekian banyak class, bagaimana penempatannya? Silahkan lihat struktur folder berikut:</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/01-struktur-folder-top-level.png" title="Top Level Folder" ></p>

<p>Tidak ada yang istimewa dari struktur di atas, cuma struktur folder standar Maven. Mari kita lihat source code aplikasi.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/02-struktur-folder-main-java.png" title="Source Folder Java" ></p>

<p>Di sini kita bisa lihat class sudah diatur ke dalam package berbeda sesuai fungsinya, yaitu domain, service, dao. Untuk implementasi service dengan Spring JDBC kita buatkan package tersendiri. Selanjutnya kita lihat lokasi file konfigurasi.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/03-struktur-folder-main-resources.png" title="Source Folder Konfigurasi" ></p>

<p>File konfigurasi ditaruh dalam package. Sebetulnya ditaruh di top level juga boleh, ini hanya sekedar kebiasaan saja.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/04-struktur-folder-test.png" title="Source Test Folder" ></p>

<p>Lokasi penempatan test class bisa dilihat di atas. Abstract class yang saya ceritakan di atas terlihat di package <code>com.muhardin.endy.training.java.aksesdb.service</code>, sedangkan implementasi konfigurasinya ada di subpackage <code>springjdbc</code> di bawahnya.</p>

<p>Setelah kita melihat penempatan file dan folder, mari kita lihat kerangka kode program di masing-masing class/file. Supaya bisa mendapatkan <em>big-picture</em>, kita akan lihat kerangka class dan method saja. Implementasinya menyusul pada bagian selanjutnya.</p>

<h1>Domain Object</h1>

<h2>Class Produk</h2>

<p>Class ini merupakan padanan tabel m_produk di database.
Dia memiliki beberapa property sesuai dengan kolom di database.
Berikut penjelasannya</p>

<table>
<thead>
<tr>
<th>Nama Property </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id            </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>kode          </td>
<td> kode                </td>
<td> String         </td>
<td> varchar</td>
</tr>
<tr>
<td>nama          </td>
<td> nama                </td>
<td> String         </td>
<td> varchar</td>
</tr>
<tr>
<td>harga         </td>
<td> harga               </td>
<td> BigDecimal     </td>
<td> decimal(19,2)</td>
</tr>
</tbody>
</table>


<p>Berikut kode program untuk class Produk.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>import java.math.BigDecimal;</p>

<p>public class Produk {</p>

<pre><code>private Integer id;
private String kode;
private String nama;
private BigDecimal harga;

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<h2>Class Penjualan</h2>

<p>Mapping Java ke SQL</p>

<table>
<thead>
<tr>
<th>Nama Property  </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id             </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>waktuTransaksi </td>
<td> waktu_transaksi     </td>
<td> Date           </td>
<td> datetime</td>
</tr>
</tbody>
</table>


<p>Kode program class Penjualan</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>// import generate dari IDE</p>

<p>public class Penjualan {</p>

<pre><code>private Integer id;
private Date waktuTransaksi;
private List&lt;PenjualanDetail&gt; daftarPenjualanDetail 
    = new ArrayList&lt;PenjualanDetail&gt;();

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<h2>Class Penjualan Detail</h2>

<p>Mapping Java ke SQL</p>

<table>
<thead>
<tr>
<th>Nama Property  </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id             </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>penjualan      </td>
<td> id_penjualan        </td>
<td> Penjualan      </td>
<td> integer foreign key</td>
</tr>
<tr>
<td>produk         </td>
<td> id_produk           </td>
<td> Produk         </td>
<td> integer foreign key</td>
</tr>
<tr>
<td>jumlah         </td>
<td> jumlah              </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>harga          </td>
<td> harga               </td>
<td> BigDecimal     </td>
<td> decimal(19,2)</td>
</tr>
</tbody>
</table>


<p>Kode program class PenjualanDetail</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>import java.math.BigDecimal;</p>

<p>public class PenjualanDetail {</p>

<pre><code>private Integer id;
private Penjualan penjualan;
private Produk produk;
private BigDecimal harga;
private Integer jumlah;

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<p>Yang perlu diperhatikan di sini adalah perbedaan cara perlakuan relasi antara Java dan database.
Di Java, kita perlu mendefinisikan relasi di dua tempat, yaitu variabel <code>daftarPenjualanDetail</code> di class <code>Penjualan</code>
dan variabel <code>penjualan</code> di class <code>PenjualanDetail</code>. Sedangkan di database, relasi ini cukup didefinisikan melalui foreign key
<code>id_penjualan</code> di tabel <code>t_penjualan_detail</code>.</p>

<p>Perbedaan lain, di database relasi ini cukup diwakili satu nilai saja, yaitu nilai foreign key.
Sedangkan di Java diwakili satu class penuh (<code>Produk</code> atau <code>Penjualan</code>) yang di dalamnya memuat banyak nilai.</p>

<p>Untuk menjembatani perbedaan ini, kita perlu membuat mapper untuk mengubah data dari database menjadi object Java dan sebaliknya. Contoh kode program untuk mapper ini akan dibahas pada bagian selanjutnya.</p>

<h1>Interface Business Service</h1>

<p>Ini adalah daftar fitur yang ada di aplikasi, didefinisikan berupa class/interface dan method.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public interface PenjualanService {</p>

<pre><code>// service berkaitan dengan produk
void simpan(Produk p);
Produk cariProdukById(Integer id);
Produk cariProdukByKode(String kode);
Long hitungSemuaProduk();
List&lt;Produk&gt; cariSemuaProduk(Integer halaman, Integer baris);
Long hitungProdukByNama(String nama);
List&lt;Produk&gt; cariProdukByNama(String nama, Integer halaman, Integer baris);

// service yang berkaitan dengan transaksi
void simpan(Penjualan p);
Penjualan cariPenjualanById(Integer id);
Long hitungPenjualanByPeriode(Date mulai, Date sampai);
List&lt;Penjualan&gt; cariPenjualanByPeriode(Date mulai, Date sampai, Integer halaman, Integer baris);
Long hitungPenjualanDetailByProdukDanPeriode(Produk p, Date mulai, Date sampai);
List&lt;PenjualanDetail&gt; cariPenjualanDetailByProdukDanPeriode(Produk p, Date mulai, Date sampai, Integer halaman, Integer baris);
</code></pre>

<p>}
```</p>

<h1>Implementasi Business Service</h1>

<p>Implementasi dari interface di atas kita bagi menjadi dua kategori, yaitu class implementasi service yang nantinya akan memanggil class DAO. Pertimbangan dan alasan mengapa begini sudah dijelaskan di atas.</p>

<h2>Class ServiceSpringJdbc</h2>

<p>Class ini sebetulnya hanya memanggil class DAO saja, jadi baiklah kita tampilkan seluruh isinya di sini.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import statement generate dari IDE</p>

<p>@Service @Transactional
public class PenjualanServiceSpringJdbc implements PenjualanService{</p>

<pre><code>@Autowired private ProdukDao produkDao;
@Autowired private PenjualanDao penjualanDao;
@Autowired private PenjualanDetailDao penjualanDetailDao;

@Override
public void simpan(Produk p) {
    produkDao.simpan(p);
}

@Override
public Produk cariProdukById(Integer id) {
    return produkDao.cariById(id);
}

@Override
public Produk cariProdukByKode(String kode) {
    return produkDao.cariByKode(kode);
}

@Override
public Long hitungSemuaProduk() {
    return produkDao.hitungSemua();
}

@Override
public List&lt;Produk&gt; cariSemuaProduk(Integer halaman, Integer baris) {
    return produkDao.cariSemua(halaman, baris);
}

@Override
public Long hitungProdukByNama(String nama) {
    return produkDao.hitungByNama(nama);
}

@Override
public List&lt;Produk&gt; cariProdukByNama(String nama, Integer halaman, Integer baris) {
    return produkDao.cariByNama(nama, halaman, baris);
}

@Override
public void simpan(Penjualan p) {
    penjualanDao.simpan(p);
}

@Override
public Penjualan cariPenjualanById(Integer id) {
    return penjualanDao.cariById(id);
}

@Override
public Long hitungPenjualanByPeriode(Date mulai, Date sampai) {
    return penjualanDao.hitungByPeriode(mulai, sampai);
}

@Override
public List&lt;Penjualan&gt; cariPenjualanByPeriode(Date mulai, Date sampai, 
        Integer halaman, Integer baris) {
    return penjualanDao.cariByPeriode(mulai, sampai, halaman, baris);
}

@Override
public Long hitungPenjualanDetailByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai) {
    return penjualanDetailDao.hitungByProdukDanPeriode(p, mulai, sampai);
}

@Override
public List&lt;PenjualanDetail&gt; cariPenjualanDetailByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai, Integer halaman, Integer baris) {
    return penjualanDetailDao.cariByProdukDanPeriode(p, mulai, sampai, halaman, baris);
}
</code></pre>

<p>}
```</p>

<h2>Class DAO</h2>

<p>Class DAO akan kita bahas secara mendetail di bagian selanjutnya. Pada kesempatan ini kita hanya tampilkan deklarasi class dan method saja supaya jelas mana method yang dipanggil dari implementasi service di atas.</p>

<h3>ProdukDAO</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class ProdukDao {</p>

<pre><code>public void simpan(Produk p) {}

public Produk cariById(Integer id) {}

public Produk cariByKode(String kode) {}

public Long hitungSemua() {}

public List&lt;Produk&gt; cariSemua(Integer halaman, Integer baris) {}

public Long hitungByNama(String nama) {}

public List&lt;Produk&gt; cariByNama(String nama, Integer halaman, Integer baris) {}

private class ResultSetJadiProduk implements RowMapper&lt;Produk&gt; {
    @Override
    public Produk mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h3>PenjualanDao</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class PenjualanDao {</p>

<pre><code>public void simpan(Penjualan p) {}

public Penjualan cariById(Integer id) {}

public Long hitungByPeriode(Date mulai, Date sampai) {}

public List&lt;Penjualan&gt; cariByPeriode(Date mulai, Date sampai, Integer halaman, Integer baris) {}


private class ResultSetJadiPenjualan implements RowMapper&lt;Penjualan&gt; {
    @Override
    public Penjualan mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h3>PenjualanDetailDao</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class PenjualanDetailDao {</p>

<pre><code>public void simpan(final PenjualanDetail p) {}

public List&lt;PenjualanDetail&gt; cariByPenjualan(Penjualan p) {}

public Long hitungByProdukDanPeriode(Produk p, Date mulai, Date sampai) {}

public List&lt;PenjualanDetail&gt; cariByProdukDanPeriode(Produk p, Date mulai, Date sampai, Integer halaman, Integer baris) {}


private class ResultSetJadiPenjualanDetail implements RowMapper&lt;PenjualanDetail&gt; {
    @Override
    public PenjualanDetail mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h1>Automated Test</h1>

<p>Seperti dijelaskan di atas, automated test kita bagi menjadi dua kategori, yaitu abstract class yang menampung semua logika pengetesan, dan concrete class yang menyediakan konfigurasi.</p>

<h2>Abstract Base Class</h2>

<h3>ProdukServiceTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public abstract class ProdukServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {}

@Test
public void testSimpanProduk() {}

@Test
public void testCariProdukById() {}

@Test
public void testCariProdukByKode() {}

@Test
public void testHitungSemuaProduk() {}

@Test
public void testCariSemuaProduk() {}

@Test
public void testHitungProdukByNama() {}

@Test
public void testCariProdukByNama() {}
</code></pre>

<p>}
```</p>

<h3>PenjualanServiceTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public abstract class PenjualanServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {}

@Test
public void testSimpanPenjualan() throws Exception {}

@Test
public void testCariPenjualanById(){}

@Test
public void testHitungPenjualanByPeriode(){}

@Test
public void testCariPenjualanByPeriode(){}

@Test
public void testHitungPenjualanDetailByProdukDanPeriode(){}

@Test
public void testCariPenjualanDetailByProdukDanPeriode(){}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat di atas, kedua class tersebut memiliki dua abstract method, yaitu:</p>

<ul>
<li><code>public abstract PenjualanService getPenjualanService()</code></li>
<li><code>public abstract DataSource getDataSource();</code></li>
</ul>


<p>Kedua object <code>PenjualanService</code> dan <code>DataSource</code> didapatkan dari konfigurasi Spring.
Konfigurasi Spring dibuat berdasarkan teknologi yang digunakan.
Konfigurasi Spring JDBC berbeda dengan konfigurasi Hibernate ataupun Spring Data JPA.</p>

<p>Dengan teknik ini, bila di kemudian hari kita membuat implementasi dengan Hibernate atau Spring Data JPA,
kita tidak perlu lagi copy-paste test class, cukup buat subclass yang menyediakan kedua object tersebut.</p>

<p>Berikut adalah subclassnya</p>

<h2>Implementasi Test Business Service</h2>

<p>Karena hanya beberapa baris dan tidak butuh banyak penjelasan, kita tampilkan di sini full source code, bukan hanya kerangkanya saja.</p>

<h3>ProdukServiceSpringJdbcTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class ProdukServiceSpringJdbcTest extends ProdukServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}
```</p>

<h3>PenjualanServiceSpringJdbcTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class PenjualanServiceSpringJdbcTest extends PenjualanServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat di atas, <code>dataSource</code> dan <code>penjualanService</code> disediakan melalui Dependency Injection.</p>

<p>Cara kerjanya sebagai berikut:</p>

<ol>
<li>Kita jalankan JUnit melalui IDE atau Maven. IDE atau Maven akan membaca semua file dalam folder <code>src/test/java</code> dan memproses semua class yang namanya berakhiran <code>Test</code> seperti <code>PenjualanServiceSpringJdbcTest</code>. IDE/Maven juga memproses <code>PenjualanServiceTest</code>, tapi karena classnya abstract maka tidak diproses lebih lanjut.</li>
<li>JUnit melihat annotation <code>@RunWith</code>, jadi dia tidak menjalankan sendiri melainkan menyuruh <code>SpringJUnit4ClassRunner</code> untuk menjalankan test</li>
<li><code>SpringJUnit4ClassRunner</code> membaca annotation <code>@ContextConfiguration</code>, lalu menggunakan nilai di dalamnya untuk melakukan inisialisasi <code>ApplicationContext</code>, kemudian mengisi variabel yang ditandai dengan <code>@Autowired</code></li>
<li>Karena <code>PenjualanServiceSpringJdbcTest</code> merupakan subclass dari <code>PenjualanServiceTest</code>, maka dia akan mewarisi semua method <code>@Test</code> yang dimiliki <code>PenjualanServiceTest</code>. Method <code>@Test</code> ini akan dijalankan oleh IDE/Maven.</li>
<li>Pada waktu method <code>@Test</code> dijalankan, bila perlu object <code>PenjualanService</code>, maka akan didapat dengan cara memanggil method <code>getPenjualanService</code>. Karena methodnya sudah dibuatkan implementasinya (tidak abstract lagi) dan sudah ada isinya, maka method <code>@Test</code> dapat bekerja dengan baik.</li>
</ol>


<p>Demikianlah bagian kedua dari tutorial mengakses database menggunakan Spring JDBC. Pada bagian ini kita sudah melihat bagaimana cara pengaturan file/folder dan interaksi antar class/method. Di bagian selanjutnya kita akan lihat <a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">bagaimana cara menjalankan perintah SQL</a>.</p>
]]></content>
  </entry>
  
</feed>
