<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-11-14T18:49:37+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mendapatkan Informasi System dengan Java]]></title>
    <link href="http://software.endy.muhardin.com/java/mendapatkan-informasi-system-dengan-java/"/>
    <updated>2013-10-29T09:52:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mendapatkan-informasi-system-dengan-java</id>
    <content type="html"><![CDATA[<p>Pada salah satu project yang sedang saya kerjakan, ada kebutuhan untuk mendapatkan informasi mengenai sistem dimana aplikasi diinstal. Informasi yang dibutuhkan antara lain:</p>

<ul>
<li>Sistem Operasi</li>
<li>Kapasitas Memori</li>
<li>Kapasitas Disk</li>
<li>Jumlah Network Interface</li>
<li>MAC Address dari masing-masing Network Interface</li>
</ul>


<p>Dalam artikel ini, kita akan membahas cara mendapatkan berbagai informasi tersebut. Seperti biasa, kode program bisa diambil di <a href="https://github.com/endymuhardin/belajar-java-sysinfo">repository Github saya</a>.</p>

<!--more-->


<h2>Sistem Operasi</h2>

<p>Informasi tentang Sistem Operasi dapat diperoleh dengan menggunakan class java.lang.System. Dari class ini kita bisa menggunakan method getProperty yang berisi berbagai informasi tentang sistem. Daftar property yang tersedia dapat dilihat di <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperties()">halaman dokumentasinya</a>. Property yang berkaitan dengan sistem operasi adalah:</p>

<ul>
<li>os.name</li>
<li>os.version</li>
<li>os.arch</li>
</ul>


<p>Berikut contoh penggunaannya</p>

<p>```java
String os = System.getProperty("os.name");
os += ":" + System.getProperty("os.version");
os += ":" + System.getProperty("os.arch");</p>

<p>System.out.println(os);
```</p>

<p>Di laptop saya, outputnya seperti ini:</p>

<p><code>
Linux:3.11.0-12-generic:amd64
</code></p>

<h2>Kapasitas Memori</h2>

<p>Aplikasi Java berjalan di atas JVM, tidak langsung di atas sistem operasi. Untuk urusan memori, ada dua jenis memori yang kita kenal, yaitu memori yang disediakan untuk JVM dan memori yang tersedia di komputer (RAM). Hal ini sering menimbulkan kebingungan di programmer Java pemula, yaitu</p>

<blockquote><p>Komputer saya RAM-nya 8 GB, kenapa aplikasi Java saya cuma bisa pakai 2 GB?</p></blockquote>

<p>Biasanya penyebabnya adalah karena memori yang dialokasikan untuk JVM hanya 2 GB.</p>

<h3>Memori Fisik (RAM)</h3>

<p>Untuk mendapatkan informasi tentang memori fisik yang tersedia, kita gunakan class <code>com.sun.management.OperatingSystemMXBean</code>. Berikut cara mendapatkan object dari class tersebut.</p>

<p>```java
OperatingSystemMXBean osBean</p>

<pre><code>= (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
</code></pre>

<p>```</p>

<p>Setelah itu, kita bisa gunakan untuk mendapatkan informasi memori sebagai berikut</p>

<p><code>java
Long memory = osBean.getTotalPhysicalMemorySize();
</code></p>

<p>Dokumentasi lengkap dari class tersebut bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html">di sini</a>.</p>

<h3>Memori JVM</h3>

<p>Ada dua variabel yang menginformasikan memori JVM, yaitu memori yang dialokasikan, dan memori yang terpakai. Aplikasi kita boleh menggunakan memori maksimal sebanyak yang dialokasikan. Tapi aplikasi belum tentu menggunakan semuanya, hanya sebagian saja yang terpakai. Informasi memori JVM bisa didapatkan dari class <code>java.lang.Runtime</code>.</p>

<p>Berikut cara untuk mendapatkan memori yang dialokasikan untuk JVM</p>

<p><code>java
Long totalMemory = Runtime.getRuntime().totalMemory();
</code></p>

<p>Sedangkan untuk mendapatkan memori terpakai, kita kurangi <code>totalMemory</code> dengan <code>freeMemory</code> (memori yang tidak terpakai)</p>

<p><code>java
Long freeMemory = Runtime.getRuntime().freeMemory();
Long terpakai = totalMemory - freeMemory;
</code></p>

<p>Lebih lengkapnya bisa dilihat langsung di <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#totalMemory()">dokumentasi class <code>Runtime</code></a></p>

<h2>Kapasitas Storage</h2>

<p>Informasi tentang storage bisa didapatkan di class <code>java.io.File</code>. Pertama, kita buat dulu objek <code>File</code> yang mengarah ke partisi yang ingin kita ketahui informasinya.</p>

<p>Untuk Windows, gunakan <code>C:</code>, <code>D:</code>, dan seterusnya.</p>

<p><code>java
File f = new File("C:");
</code></p>

<p>Untuk Linux, gunakan <code>/</code>, <code>/home</code>, dan sebagainya.</p>

<p><code>java
File f = new File("/home");
</code></p>

<p>Ada beberapa method yang disediakan yaitu:</p>

<ul>
<li>totalSpace() : kapasitas storage</li>
<li>usableSpace() : kapasitas yang bisa digunakan</li>
<li>freeSpace() : ruang kosong</li>
</ul>


<p>Kita tentu bertanya-tanya, apa bedanya <code>usable</code> dan <code>free</code>? Free adalah ruang yang tidak terpakai, tapi belum tentu boleh dipakai karena masalah permission, ijin akses, dan sebagainya. Usable adalah ruang yang boleh dipakai. Kadang-kadang, nilai <code>usable</code> sama dengan nilai <code>free</code>. Penjelasannya bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#getUsableSpace(">di sini</a>).</p>

<p>Cara pakainya tidak sulit.</p>

<p><code>java
Long totalSpace = f.getTotalSpace();
Long usableSpace = f.getUsableSpace();
Long freeSpace = f.getFreeSpace();
</code></p>

<h2>Network Interface</h2>

<p>Informasi tentang network interface bisa didapatkan di <code>java.net.NetworkInterface</code>. Pertama, kita dapatkan dulu seluruh interface yang ada di komputer. Satu komputer (apalagi server) biasa memiliki lebih dari satu interface. Laptop saja biasanya punya dua, ethernet dan wifi.</p>

<p><code>java
Enumeration&lt;NetworkInterface&gt; semuaInterface = NetworkInterface.getNetworkInterfaces();
</code></p>

<p>Setelah itu, kita bisa melakukan loop untuk mendapatkan jumlah interface, nama interface, dan MAC addressnya.</p>

<p>```java
Integer jumlah = 0;
while(semuaInterface.hasMoreElements()){</p>

<pre><code>NetworkInterface ni = semuaInterface.nextElement();
System.out.println("Nama Interface : "+ni.getDisplayName());
byte[] mac = ni.getHardwareAddress();
if(mac != null){
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; mac.length; i++) {
            sb.append(String.format("%02X%s", mac[i], (i &lt; mac.length - 1) ? "-" : ""));        
    }
    System.out.println("MAC Address : "+sb.toString());
}
jumlah++;
</code></pre>

<p>}
System.out.println("Jumlah interface : "+jumlah);
```</p>

<p>Demikianlah cara mendapatkan informasi tentang sistem tempat aplikasi Java kita dijalankan.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrasi Database dengan Liquibase]]></title>
    <link href="http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase/"/>
    <updated>2013-10-01T21:22:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/migrasi-database-dengan-liquibase</id>
    <content type="html"><![CDATA[<p>Salah satu kepuasan kita sebagai programmer adalah pada waktu aplikasi yang kita buat digunakan banyak user dan menghasilkan banyak manfaat bagi mereka. Sebagai konsekuensinya, akan banyak permintaan tambahan dari user untuk menambah fitur ataupun mengubah fitur yang sudah ada supaya makin nyaman digunakan.</p>

<p>Seringkali terjadi, perubahan yang diminta ini akan menyebabkan berubahnya skema database. Ini merupakan hal yang wajar dan umum terjadi, sehingga kita perlu menyiapkan mental untuk menerima kondisi ini sebagai sesuatu yang lumrah dan tidak mengerikan.</p>

<p>Tools yang sering saya gunakan untuk mengurus perubahan (evolusi) skema database adalah <a href="http://www.liquibase.org">Liquibase</a>. Pada <a href="http://software.endy.muhardin.com/java/membuat-changelog-liquibase/">artikel terdahulu</a>, kita sudah membahas cara menggunakan Liquibase untuk mengkonversi skema database menjadi XML supaya bisa dikelola di version control. Kali ini, kita akan menggunakan Liquibase untuk melakukan migrasi dari skema database antar versi aplikasi.</p>

<!--more-->


<p>Studi kasusnya sebagai berikut. Misalnya kita punya aplikasi versi <code>1.0</code> yang sudah berjalan di production (live) dan digunakan user. Aplikasi versi <code>1.0</code> ini kita kembangkan selama beberapa minggu --diberikan tambahan fitur, bug diperbaiki, tampilan diperindah, dan berbagai peningkatan lainnya-- menjadi versi <code>2.0</code>. Antar kedua versi ini terjadi perubahan skema database. Kita ingin membuat script SQL untuk mengkonversi (migrasi) skema database versi <code>1.0</code> menjadi skema versi <code>2.0</code>. Untuk keperluan itu, kita gunakan Liquibase.</p>

<p>Liquibase memiliki kemampuan untuk membandingkan (diff) dua database, kemudian membuatkan file untuk migrasi dari skema yang satu (versi <code>1.0</code>) menjadi skema lainnya (versi <code>2.0</code>).</p>

<h2>Menyiapkan kedua database</h2>

<p>Langkah pertama adalah menyiapkan kedua versi database. Biasanya saya membuat dump dari database production (skema versi <code>1.0</code>), kemudian di-restore di tempat lain (misalnya di laptop). Kemudian saya juga menyiapkan database development yang menggunakan skema versi <code>2.0</code>.</p>

<p>Agar lebih jelas, kita namakan saja database yang diambil dari production dengan nama <code>aplikasi_v_1_0</code> dan database baru dengan nama <code>aplikasi_v_2_0</code>. Berikut adalah informasi koneksi JDBC untuk kedua database</p>

<h3>aplikasi_v_1_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_1_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h3>aplikasi_v_2_0</h3>

<ul>
<li>jdbc.driver = <code>com.mysql.jdbc.Driver</code></li>
<li>jdbc.url = <code>jdbc:mysql://localhost/aplikasi_v_2_0</code></li>
<li>jdbc.username = <code>root</code></li>
<li>jdbc.password = <code>coba</code></li>
</ul>


<h2>Konfigurasi Liquibase</h2>

<p>Seperti di artikel terdahulu, kita membutuhkan tiga file yang kita letakkan di folder yang sama, yaitu:</p>

<ul>
<li><code>mysql-connector-java-5.1.25.jar</code> : driver database</li>
<li><code>liquibase-core-2.0.5.jar</code> : aplikasi liquibase</li>
<li><code>liquibase.properties</code> : konfigurasi liquibase</li>
</ul>


<p>Sesuaikan kedua file jar dengan versi yang terbaru.</p>

<p>File <code>liquibase.properties</code> berisi konfigurasi yang dibutuhkan oleh liquibase. Berikut isinya</p>

<p><code>
driver: com.mysql.jdbc.Driver
classpath: mysql-connector-java-5.1.25.jar
url: jdbc:mysql://localhost/aplikasi_v_2_0
username: root
password: admin
referenceUrl: jdbc:mysql://localhost/aplikasi_v_1_0
referenceUsername: root
referencePassword: admin
changeLogFile: changelog.xml
</code></p>

<p>Berikut penjelasan dari isi file:</p>

<ul>
<li>driver: JDBC driver sesuai merek database yang kita gunakan</li>
<li>classpath: lokasi file JDBC driver</li>
<li>url: JDBC url untuk database tujuan (versi <code>2.0</code>)</li>
<li>username: username untuk database tujuan (versi <code>2.0</code>)</li>
<li>password: password untuk database tujuan (versi <code>2.0</code>)</li>
<li>referenceUrl: JDBC url untuk database asal (versi <code>1.0</code>)</li>
<li>referenceUsername: username untuk database asal (versi <code>1.0</code>)</li>
<li>referencePassword: password untuk database asal (versi <code>1.0</code>)</li>
<li>changeLogFile: nama file tujuan untuk menulis hasil perbandingan kedua database</li>
</ul>


<h2>Menjalankan Liquibase : Membuat file changelog</h2>

<p>Pertama, kita buat dulu file changelog sesuai format Liquibase. Commandnya adalah sebagai berikut:</p>

<p><code>
java -jar liquibase-core-2.0.5.jar diffChangeLog
</code></p>

<p>Berikut output dari perintah di atas</p>

<p><code>
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_1_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading tables for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading views for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading foreign keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading primary keys for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading columns for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading unique constraints for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Reading indexes for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: Sequences not supported for
 root@localhost @ jdbc:mysql://localhost/aplikasi_v_2_0 ...
INFO 10/1/13 9:11 PM:liquibase: changelog.xml does not exist, creating
Liquibase 'diffChangeLog' Successful
</code></p>

<p>Perintah ini akan menghasilkan file <code>changelog.xml</code> di folder tempat kita berada. File ini berisi perbedaan antar skema versi 1.0 dengan skema versi 2.0. Isinya seperti ini</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"></p>

<pre><code>&lt;changeSet author="endy (generated)" id="1380636706862-1"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="allowed_addresses" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-2"&gt;
    &lt;addColumn tableName="m_customer"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-3"&gt;
    &lt;addColumn tableName="m_plan"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-4"&gt;
    &lt;addColumn tableName="m_provider"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-5"&gt;
    &lt;addColumn tableName="m_rate"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-6"&gt;
    &lt;addColumn tableName="m_routing"&gt;
        &lt;column name="deleted" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/addColumn&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-7"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_password" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1380636706862-8"&gt;
    &lt;dropNotNullConstraint columnDataType="VARCHAR(255)" columnName="bind_username" tableName="m_provider"/&gt;
&lt;/changeSet&gt;
</code></pre>

<p></databaseChangeLog>
```</p>

<p>Kita lihat di atas bahwa antara skema versi <code>1.0</code> dan versi <code>2.0</code> terjadi perubahan sebagai berikut:</p>

<ul>
<li>penambahan kolom <code>allowed_address</code> di tabel <code>m_customer</code></li>
<li>penambahan kolom <code>deleted</code> di berbagai tabel lainnya</li>
<li>menghilangkan constraint <code>NOT NULL</code> di kolom <code>bind_username</code> dan <code>bind_password</code></li>
</ul>


<p>Kita bisa periksa file ini dan sesuaikan bila ada yang kurang tepat.</p>

<h2>Menjalankan Liquibase : Membuat script SQL</h2>

<p>File XML saja tentunya tidak bermanfaat banyak buat kita. Untuk bisa dieksekusi di database production, kita memerlukan script SQL. Untungnya Liquibase punya fitur untuk membuat script SQL. Berikut perintahnya</p>

<p><code>
java -jar liquibase-core-2.0.5.jar updateSQL
</code></p>

<p>Outputnya adalah sebagai berikut</p>

<p>```sql
--  <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>
--  Update Database Script
--  </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
--  Change Log: changelog.xml
--  Ran at: 10/1/13 9:18 PM
--  Against: root@localhost@jdbc:mysql://localhost/aplikasi_v_2_0
--  Liquibase version: 2.0.5
--  *********************************************************************</p>

<p>--  Lock Database
--  Changeset changelog.xml::1380636706862-1::endy (generated)::(Checksum: 3:87288bc453555824cb2e28ddafed9557)
ALTER TABLE <code>m_customer</code> ADD <code>allowed_addresses</code> VARCHAR(255) NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-1', '2.0.5', '3:87288bc453555824cb2e28ddafed9557', 5);</p>

<p>--  Changeset changelog.xml::1380636706862-2::endy (generated)::(Checksum: 3:27e1f8b069e4471400f3deff5034bca9)
ALTER TABLE <code>m_customer</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-2', '2.0.5', '3:27e1f8b069e4471400f3deff5034bca9', 6);</p>

<p>--  Changeset changelog.xml::1380636706862-3::endy (generated)::(Checksum: 3:14c13dec957537886d6035b32fd4c90c)
ALTER TABLE <code>m_plan</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-3', '2.0.5', '3:14c13dec957537886d6035b32fd4c90c', 7);</p>

<p>--  Changeset changelog.xml::1380636706862-4::endy (generated)::(Checksum: 3:b54952b6be5eb80caf649dc75f974f65)
ALTER TABLE <code>m_provider</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-4', '2.0.5', '3:b54952b6be5eb80caf649dc75f974f65', 8);</p>

<p>--  Changeset changelog.xml::1380636706862-5::endy (generated)::(Checksum: 3:6b840975b06488faa9ec0ed1d3e8d123)
ALTER TABLE <code>m_rate</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-5', '2.0.5', '3:6b840975b06488faa9ec0ed1d3e8d123', 9);</p>

<p>--  Changeset changelog.xml::1380636706862-6::endy (generated)::(Checksum: 3:909c459661aacc260b40971e4215a481)
ALTER TABLE <code>m_routing</code> ADD <code>deleted</code> BIT NOT NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Add Column', 'EXECUTED', 'changelog.xml', '1380636706862-6', '2.0.5', '3:909c459661aacc260b40971e4215a481', 10);</p>

<p>--  Changeset changelog.xml::1380636706862-7::endy (generated)::(Checksum: 3:ac26c24529898f4c1c2133225d3d5ee8)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_password</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-7', '2.0.5', '3:ac26c24529898f4c1c2133225d3d5ee8', 11);</p>

<p>--  Changeset changelog.xml::1380636706862-8::endy (generated)::(Checksum: 3:968da08768e83eaaa863f0a3cafc204e)
ALTER TABLE <code>m_provider</code> MODIFY <code>bind_username</code> VARCHAR(255) NULL;</p>

<p>INSERT INTO <code>DATABASECHANGELOG</code> (<code>AUTHOR</code>, <code>COMMENTS</code>, <code>DATEEXECUTED</code>, <code>DESCRIPTION</code>, <code>EXECTYPE</code>, <code>FILENAME</code>, <code>ID</code>, <code>LIQUIBASE</code>, <code>MD5SUM</code>, <code>ORDEREXECUTED</code>) VALUES ('endy (generated)', '', NOW(), 'Drop Not-Null Constraint', 'EXECUTED', 'changelog.xml', '1380636706862-8', '2.0.5', '3:968da08768e83eaaa863f0a3cafc204e', 12);</p>

<p>--  Release Database Lock
```</p>

<p>Output tersebut bisa kita periksa dulu kebenarannya, kemudian kita edit bila perlu, lalu tinggal dijalankan di skema database versi <code>1.0</code> ... voila ... dia akan berubah menjadi database dengan skema versi <code>2.0</code>.</p>

<p>Demikianlah cara mudah untuk melakukan migrasi. Jangan lupa simpan isi file <code>changelog.xml</code> ke dalam version control supaya segala perubahan terhadap skema database tercatat riwayatnya.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengobati OOM]]></title>
    <link href="http://software.endy.muhardin.com/java/mengobati-oom/"/>
    <updated>2013-06-08T22:25:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengobati-oom</id>
    <content type="html"><![CDATA[<p>Beberapa waktu belakangan ini, di milis mulai banyak bermunculan pertanyaan yang berkaitan dengan Out Of Memory Error (OOM).
Error ini biasanya terjadi bila data dalam aplikasi sudah besar (melebihi 2 GB), dan umumnya terjadi pada saat membuat report PDF/XLS/CSV, dsb.</p>

<p>Biasanya juga, <em>obat yang dikonsumsi</em> oleh penderita OOM ini ada dua:</p>

<ul>
<li>Mengatur alokasi memori dengan opsi <code>Xms</code> dan <code>Xmx</code></li>
<li>Menggunakan perintah <code>System.gc()</code></li>
</ul>


<p>Sayangnya, kedua <em>obat</em> ini tidak akan menyelesaikan masalah. Analoginya seperti kita kena infeksi otak, lalu minum Panadol. Sakit kepalanya mungkin akan hilang sementara waktu, tapi tidak lama kemudian justru akibatnya lebih fatal.</p>

<p>Lalu bagaimana solusinya?</p>

<!--more-->


<h1>Salah Kaprah tentang OOM</h1>

<p>Pertama, saya luruskan dulu mengenai <code>System.gc</code>.
Intinya begini</p>

<blockquote><p>System.gc() hanya boleh dipakai dengan satu (dan hanya satu-satunya) syarat:
Yaitu pada waktu sudah bisa menjelaskan ke orang lain bagaimana cara kerja garbage collector dan sudah paham apa itu JVM Ergonomics.</p></blockquote>

<p>Next time mau mengetik System.gc, tanyakan pada diri sendiri, apakah saya sudah paham JVM Ergonomics dan bisa menjelaskannya ke orang lain? Kalau jawabannya belum, jangan diteruskan mengetik System.gc().</p>

<blockquote><p>Lalu apa itu <code>System.gc</code> dan kapan digunakan?</p></blockquote>

<p>Kan sudah dijelaskan di atas, pelajari cara kerja garbage collector dan apa itu JVM ergonomics.</p>

<p>Satu lagi salah kaprah yang harus dibenahi :
opsi <code>Xms</code> dan <code>Xmx</code> itu gunanya adalah <strong>UNTUK MEMAKSIMALKAN PENGGUNAAN MEMORI</strong>.
<code>Xms</code> dan <code>Xms</code> <strong>BUKAN SOLUSI UNTUK MASALAH OOM</strong>.</p>

<p>Masalah OOM itu ada di kode program kita sendiri, jadi carilah solusinya di kode program kita sendiri.
Penyebab OOM itu juga cuma satu : aplikasi kita menggunakan memori lebih besar daripada yang tersedia.
Besar pasak daripada tiang.</p>

<ol>
<li>Memori tersedia 4 GB, aplikasi kita pakai 4.1 GB => OOM</li>
<li>Memori tersedia 2 GB, aplikasi kita pakai 1.5 GB => No OOM padahal lebih kecil dari #1</li>
<li>RAM fisik ada 16 GB, tapi aplikasi kita cuma bisa memanfaatkan 2 GB => gunakan <code>Xms</code> dan <code>Xmx</code>.</li>
</ol>


<h1>Penyebab OOM dan Solusinya</h1>

<p>Beberapa penyebab umum terjadinya OOM :</p>

<h2>Unbounded Query</h2>

<p>Unbounded query adalah query yang tidak kita batasi jumlahnya.
Contohnya <code>select * from tbl_penjualan</code>. Kalau data penjualan hanya 1000 transaksi, no problem. Kalau transaksinya ada 10 juta record dalam satu hari, ya pasti langsung kena OOM.</p>

<p>Solusinya : pastikan selalu menggunakan paging. Ganti querynya menjadi <code>select * from tbl_penjualan limit 0,20</code> sehingga cuma mengeluarkan 20 record, berapapun banyaknya data dalam tabel.</p>

<h2>Generate File</h2>

<p>Seringkali kita ingin menghasilkan file report. Misalnya laporan penjualan bulan ini, berapapun data yang ada di tabel untuk periode bulan ini, harus ditulis ke file. File ini bisa berupa PDF, XLS, XML, CSV, dan sebagainya.</p>

<p>Format file tidak masalah. Yang menjadi masalah adalah cara membuatnya. Ada beberapa kesalahan umum :</p>

<ul>
<li>mengumpulkan data di variabel sebelum menulis file</li>
<li>tidak melepas data yang sudah diproses</li>
<li>tidak paham cara kerja report engine</li>
</ul>


<h3>Mengumpulkan data di variabel</h3>

<p>Contoh pseudocode seperti ini</p>

<p>```java
List<Penjualan> data = new ArrayList<Penjualan>();</p>

<p>// resultset adalah cursor, dia hanya baca apa yang ditarik saja
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>while(rs.next()){</p>

<pre><code>Penjualan p = konversiResultSetJadiPenjualan(rs);
data.add(p);
</code></pre>

<p>}
```</p>

<p>Coding di atas akan mengumpulkan semua record di variabel <code>data</code>.
Bila ada 1 juta record yang dihasilkan oleh query dengan masing-masing record berukuran 1 KB,
maka variabel data tersebut akan berukuran 1 GB. Kalau Java VM kita berikan alokasi 2 GB, cuma butuh 3 user untuk menimbulkan OOM.
Menaikkan alokasi menjadi 8 GB melalui <code>Xms</code> dan <code>Xmx</code> tidak akan membantu banyak.</p>

<h3>Tidak melepas data yang sudah diproses</h3>

<p>Ini biasanya terjadi kalau kita menulis sendiri file output. Perhatikan contoh kode berikut:</p>

<p>```java
ResultSet rs = connection.createStatement("select * from tbl_penjualan")</p>

<pre><code>.executeQuery();
</code></pre>

<p>File output = new File("output.csv");
while(rs.next()){</p>

<pre><code>String baris = konversiResultSetJadiString(rs);
output.write(baris);
output.flush();
</code></pre>

<p>}
```</p>

<p>Menulis file ada bermacam-macam. Ada yang menggunakan buffer ada yang tidak. Pastikan kita mengosongkan buffer setiap kali iterasi supaya tidak penuh, biasanya dengan method <code>flush</code> atau sejenisnya.</p>

<h3>Tidak paham cara kerja report engine</h3>

<p>Dalam mendesain library yang dipakai orang banyak, biasanya si pembuat akan melakukan optimasi untuk penggunaan yang sering terjadi.
Misalnya 80% orang membuat PDF berukuran 10 halaman atau lebih sedikit, 20% sisanya membuat 1000 halaman atau lebih.
Pada situasi ini, pembuat library report yang baik pasti akan memudahkan pembuatan 10 halaman report karena itulah fitur yang paling sering digunakan.</p>

<p>Bila kita termasuk golongan yang 20%, kita harus belajar lebih giat supaya paham bagaimana mengatasi kondisi minoritas tersebut.</p>

<p>Sebagai contoh, kalau kita menggunakan Jasper Report, ada fitur yang disebut dengan <a href="http://community.jaspersoft.com/wiki/comparison-report-virtualizers">Virtualizer</a> untuk membuat report berukuran besar. Pastikan kita sudah memahami kasus-kasus khusus ini.</p>

<h2>Inisialisasi object besar di dalam loop</h2>

<p>Perhatikan contoh kode di bawah</p>

<p>```java
public void simpan(Produk p){</p>

<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext("konfig-spring.xml");
ProdukDao pd = ctx.getBean(ProdukDao.class);
pd.save(p);
</code></pre>

<p>}
```</p>

<p><code>ApplicationContext</code> merupakan object Spring Framework yang berisi seluruh konfigurasi aplikasi. Isinya :</p>

<ul>
<li>konfigurasi database</li>
<li>mapping ORM (kalau pakai ORM)</li>
<li>semua object yang dimanage Spring</li>
</ul>


<p>Intinya, ini adalah object yang besar sekali dan sangat kompleks. Object seperti ini biasanya hanya dibuat sekali saja sepanjang aplikasi dijalankan. Bila kita taruh dalam method seperti di atas, maka tiap kali ada user simpan data produk, object besar tersebut akan dibuat, sehingga menghabiskan memori.</p>

<p>Pesan moralnya, pahami library yang digunakan supaya tahu karakteristik dan cara kerjanya.</p>

<h2>Penggunaan collection yang kurang benar</h2>

<p>Collection (Set, Map, List) adalah object yang menampung object lain. Kita harus memastikan bahwa object ini berada dalam scope yang benar. Lihat kode program berikut</p>

<p>```java
public class Coba {</p>

<pre><code>private static List&lt;Integer&gt; noSurat = new ArrayList&lt;Integer&gt;();
private static Integer noTerakhir = 0;

public void bikinSuratBaru(){
    noTerakhir++;
    noSurat.add(noTerakhir);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Pada kode di atas, <code>noSurat</code> memiliki scope static, sehingga dia akan terus ada selama aplikasi berjalan. Bila aplikasi tidak mati dalam waktu yang lama, dan dalam sehari ada 1 juta surat baru, tinggal tunggu waktu saja sampai kena OOM.</p>

<h1>Panduan Solusi Umum</h1>

<p>Selain yang disebutkan di atas, masih banyak penyebab lain, yang paling sering terjadi adalah yang dibahas di atas. Kalau penyebab OOM tidak kita atasi, berapapun memori yang kita sediakan (melalui <code>Xms</code> dan <code>Xmx</code>) tidak akan cukup. Inilah sebabnya saya katakan bahwa <code>Xms</code> dan <code>Xmx</code> itu bukan solusi untuk OOM. Yang harus kita lakukan adalah <strong>mengendalikan pemakaian</strong> memori, bukan <strong>menambah</strong> memori.</p>

<p>Jadi kalau menemukan OOM, coba dicek lagi kode programnya.
Tidak perlu pakai VisualVM atau tools2 lain, cukup code review aja.</p>

<p>Dibaca satu2 source codenya, untuk tiap baris, tanyakan pertanyaan ini :</p>

<ol>
<li>Method/statement ini akan dipanggil seberapa sering?</li>
<li>Looping ini akan berputar maksimal berapa kali?</li>
<li>Berapa kira2 ukuran tiap row yang ditarik dalam query? Sekali tarik berapa row?</li>
<li>Setelah saya tarik row, kapan dia selesai digunakan? Apakah nunggu PDF jadi dulu baru selesai (inilah kandidat OOM), atau tiap selesai satu halaman PDF sudah bisa direlease?</li>
</ol>


<p>Mudah-mudahan dengan adanya artikel ini tidak ada lagi orang yang mengobati OOM dengan <code>System.gc</code> atau <code>Xmx</code>.</p>

<h2>Referensi</h2>

<ul>
<li><a href="http://java.dzone.com/news/how-fix-memory-leaks-java">How to fix memory leaks in Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengetes Akses Database]]></title>
    <link href="http://software.endy.muhardin.com/java/mengetes-akses-database/"/>
    <updated>2013-06-05T11:49:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mengetes-akses-database</id>
    <content type="html"><![CDATA[<p>Pada bagian ini, kita akan mempersiapkan seperangkat kode program untuk mengetes aplikasi yang telah kita buat.</p>

<p>Artikel ini merupakan bagian kelima dan terakhir dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<h2>Setup Test</h2>

<p>Seperti telah dijelaskan sebelumnya, test class kita akan terdiri dari dua bagian:</p>

<ol>
<li>Abstract superclass : berisi seluruh kode program pengetesan aplikasi</li>
<li>Concrete subclass : berisi kode program untuk melakukan inisialisasi</li>
</ol>


<p>Berikut adalah kerangka abstract superclass test untuk <code>Produk</code></p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import statement, generate menggunakan IDE</p>

<p>public abstract class ProdukServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {

}

@Test
public void testSimpanUpdateHapusProduk() throws Exception {

}

// test method lain tidak ditampilkan
</code></pre>

<p>}
```</p>

<p>Dan berikut ini adalah concrete subclass yang berfungsi melakukan inisialisasi konfigurasi Spring JDBC</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import statement generate menggunakan IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class ProdukServiceSpringJdbcTest extends ProdukServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>Database Reset</h2>

<p>Pada kode program abstract superclass di atas, kita melihat ada method untuk membersihkan data test. Method ini diberikan annotation <code>@Before</code> supaya dia dijalankan <strong>sebelum masing-masing test</strong>.</p>

<p>Berikut adalah isi method tersebut</p>

<p>```java
@Before
public void bersihkanDataTest() throws Exception {</p>

<pre><code>DataSource ds = getDataSource();
Connection conn = ds.getConnection();

String sql = "delete from m_produk where kode like ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setString(1,"T-001%");
ps.executeUpdate();
conn.close();
</code></pre>

<p>}
```</p>

<p>Di method tersebut, kita menghapus semua produk yang kodenya diawali <code>T-001</code>. Ini adalah data yang kita insert selama proses tes. Agar tidak mengganggu tes lainnya, kita hapus data percobaan tersebut.</p>

<h2>Test Insert Update Delete</h2>

<p>Proses insert, update, dan delete mengubah data yang ada dalam database. Supaya kita tidak repot mengurus data sample yang sudah ada di database, ketiga proses ini kita tes dalam satu kesatuan. Dengan demikian, setelah selesai dijalankan, datanya kembali bersih seperti sebelumnya. Berikut kode programnya.</p>

<p>```java
@Test
public void testSimpanUpdateHapusProduk() throws Exception{</p>

<pre><code>Produk p = new Produk();
p.setHarga(new BigDecimal(125000));
p.setKode("T-001");
p.setNama("Produk Test 001");

PenjualanService service = getPenjualanService();
service.simpan(p);
assertNotNull(p.getId());

Connection conn = getDataSource().getConnection();
PreparedStatement psCariById 
        = conn.prepareStatement
            ("select * from m_produk where id = ?");
psCariById.setInt(1, p.getId());
ResultSet rs = psCariById.executeQuery();

// test nilai awal
assertTrue(rs.next());
assertEquals("T-001",rs.getString("kode"));

// update record
p.setKode("T-001x");
service.simpan(p);

// test query setelah update
rs = psCariById.executeQuery();

assertTrue(rs.next());
assertEquals("T-001x",rs.getString("kode"));

// test delete
service.hapus(p);

// test query setelah hapus
rs = psCariById.executeQuery();

assertFalse(rs.next());
</code></pre>

<p>}
```</p>

<p>Dari komentar yang ada dalam kode program, sudah jelas apa maksud dari masing-masing bagian.</p>

<h2>Test Query</h2>

<p>Selanjutnya kita melakukan tes terhadap query. Kita mulai dari yang sederhana dulu, yaitu tabel produk.
Berikut kode program pengetesannya.</p>

<p>```java
@Test
public void testCariProdukById() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukById(1));
assertNull(service.cariProdukById(99));
</code></pre>

<p>}</p>

<p>@Test
public void testCariProdukByKode() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertNotNull(service.cariProdukByKode("K-001"));
assertNull(service.cariProdukByKode("X-001"));
</code></pre>

<p>}</p>

<p>@Test
public void testHitungSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
assertEquals(Long.valueOf(3), 
    Long.valueOf(service.hitungSemuaProduk()));
</code></pre>

<p>}</p>

<p>@Test
public void testCariSemuaProduk() {</p>

<pre><code>PenjualanService service = getPenjualanService();
List&lt;Produk&gt; hasil = service.cariSemuaProduk(1, 100);
assertNotNull(hasil);
assertTrue(hasil.size() == 3);
for (Produk produk : hasil) {
    assertNotNull(produk.getId());
    assertNotNull(produk.getKode());
    assertNotNull(produk.getNama());
    assertNotNull(produk.getHarga());
}
</code></pre>

<p>}
```</p>

<p>Logika pengetesan tidak kompleks. Kita query datanya menggunakan method di <code>ProdukDao</code> yang telah kita buat,
lalu kita bandingkan dengan kondisi yang seharusnya. Perbandingan dilakukan menggunakan method yang telah disediakan JUnit, yaitu method berawalan <code>assert</code>, misalnya <code>assertNotNull</code>, <code>assertEquals</code>, dan lainnya.</p>

<p>Yang harus diperhatikan di sini adalah, kita harus benar-benar tahu persis isi database supaya test ini bisa berjalan dengan baik. Ada banyak teknik yang bisa digunakan untuk memastikan isi database sebelum tes dijalankan, salah satunya menggunakan tools yang bernama <a href="http://www.dbunit.org/">DBUnit</a>. Lebih lanjut tentang cara menggunakan DBUnit bisa dibaca di <a href="http://software.endy.muhardin.com/java/ruthless-testing-4/">artikel ini</a>.</p>

<h2>Test Relasi</h2>

<p>Pengetesan terhadap relasi pada prinsipnya tidak berbeda. Hanya ada sedikit tambahan yaitu kita juga harus memastikan apakah relasinya berhasil terisi dengan sempurna. Berikut pengetesannya.</p>

<p>```java
@Test</p>

<pre><code>public void testCariPenjualanDetailByProdukDanPeriode(){
Produk p = new Produk();
p.setId(1);

Date mulai = new DateTime(2013,1,1,0,0,0,0).toDate();
Date sampai = new DateTime(2013,2,1,0,0,0,0).toDate();

List&lt;PenjualanDetail&gt; hasil = getPenjualanService()
        .cariPenjualanDetailByProdukDanPeriode(p, 
            mulai, sampai, 1, 100);

assertNotNull(hasil);
assertTrue(hasil.size() == 2);

for (PenjualanDetail penjualanDetail : hasil) {
    verifikasiPenjualanDetail(penjualanDetail);
}
</code></pre>

<p>}
```</p>

<p>Pada kode program di atas, terlihat bahwa kita melakukan looping yang di dalamnya ada verifikasi <code>PenjualanDetail</code>. Berikut isi methodnya.</p>

<p>```java
private void verifikasiPenjualanDetail</p>

<pre><code>    (PenjualanDetail penjualanDetail) {
assertNotNull(penjualanDetail.getProduk().getHarga());
assertNotNull(penjualanDetail.getPenjualan().getWaktuTransaksi());
</code></pre>

<p>}
```</p>

<p>Kita cukup memastikan bahwa relasi yang dimiliki <code>PenjualanDetail</code> yaitu <code>Produk</code> dan <code>Penjualan</code> tidak null. Demikian juga variabel yang ada di dalam objectnya yaitu <code>harga</code> dan <code>waktuTransaksi</code>.</p>

<p>Demikianlah rangkaian artikel tentang penggunaan Spring JDBC. Kode program selengkapnya dapat diambil <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc">di Github</a>.
Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Query dengan Spring JDBC]]></title>
    <link href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/"/>
    <updated>2013-06-03T20:08:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/query-dengan-spring-jdbc</id>
    <content type="html"><![CDATA[<p>Pada artikel sebelumnya kita telah bisa mengubah data dalam database, baik menambah (insert), mengubah (update), maupun menghapus (data). Kali ini kita akan membahas tentang cara pengambilan data (select) dari dalam database.</p>

<p>Artikel ini merupakan bagian keempat dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert, update, dan delete data</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query data</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Mengetes Akses Database</a></li>
</ol>


<!--more-->


<p>Pada dasarnya, untuk mengambil data dari database hanya ada dua varian yang kita gunakan, yaitu:</p>

<ul>
<li>mengambil data tunggal, gunakan method <code>queryForObject</code></li>
<li>mengambil data banyak, gunakan method <code>queryForList</code> atau <code>query</code> saja</li>
</ul>


<p>Kita lihat dulu implementasi yang paling mendasar, ambil semua data produk dari database. Berikut deklarasi SQLnya.</p>

<p>```java
private static final String SQL_CARI_SEMUA</p>

<pre><code>= "select * from m_produk limit ?,?";
</code></pre>

<p>```</p>

<p>Perintah SQL di atas akan dipakai dalam method <code>cariSemua</code> sebagai berikut</p>

<p>```java
public List<Produk> cariSemua(Integer halaman, Integer baris) {</p>

<pre><code>return jdbcTemplate.query(SQL_CARI_SEMUA,
        new ResultSetJadiProduk(),
        PagingHelper.halamanJadiStart(halaman, baris),
        baris);
</code></pre>

<p>}
```</p>

<p>Pada contoh di atas, kita menggunakan method <code>query</code> yang menerima tiga argumen, yaitu:</p>

<ul>
<li>SQL yang akan dijalankan, berupa String</li>
<li>Class yang bertugas mengubah ResultSet menjadi object yang kita inginkan, dalam hal ini object <code>Produk</code>. Class ini akan kita buat sendiri, yaitu class <code>ResultSetJadiProduk</code>.</li>
<li>argumen lain-lain (varargs). Ini merupakan fitur Java sejak versi 5 yang artinya kita bisa memasukkan argumen sebanyak-banyaknya dalam method. Argumen ini akan dikonversi menjadi List untuk diproses oleh method <code>query</code></li>
</ul>


<p>Jadi, bukan salah ketik kalau di atas saya sebut tiga argumen padahal kita memasukkan empat variabel ke dalamnya.</p>

<p>SQL select tentu tidak perlu kita bahas lagi, mari masuk ke class <code>ResultSetJadiProduk</code></p>

<h2>Membuat Mapper</h2>

<p>Class <code>ResultSetJadiProduk</code> bertugas mengkonversi hasil query ke database yang ada dalam class <code>ResultSet</code> menjadi object <code>Produk</code>. Implementasinya tidak rumit, ini dia.</p>

<p>```java
private class ResultSetJadiProduk implements RowMapper<Produk> {</p>

<pre><code>@Override
public Produk mapRow(ResultSet rs, int i) throws SQLException {
    Produk p = new Produk();
    p.setId((Integer) rs.getObject("id"));
    p.setKode(rs.getString("kode"));
    p.setNama(rs.getString("nama"));
    p.setHarga(rs.getBigDecimal("harga"));
    return p;
}
</code></pre>

<p>}
```</p>

<p>Kita membuatnya sebagai class di dalam class (inner class). Kalau lupa dengan strukturnya, silahkan baca lagi bab dua tentang Struktur Aplikasi.</p>

<p>Class ini harus implement interface <code>RowMapper&lt;T&gt;</code> milik Spring. <code>T</code> diganti dengan class yang menjadi tujuan konversi. Interface <code>RowMapper&lt;T&gt;</code> ini mewajibkan kita membuat method <code>mapRow</code>. Isi method tersebut sudah cukup jelas sehingga tidak perlu dijelaskan.</p>

<p>Class ini nantinya bisa kita gunakan juga di query yang menghasilkan satu object <code>Produk</code> seperti <code>cariById</code> dan <code>cariByKode</code>. Berikut implementasinya</p>

<p>```java
public Produk cariById(Integer id) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiProduk(), id);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}</p>

<p>public Produk cariByKode(String kode) {</p>

<pre><code>try {
    return jdbcTemplate.queryForObject(SQL_CARI_BY_KODE, 
        new ResultSetJadiProduk(), kode);
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Kedua method ini sama saja prinsipnya dengan <code>cariSemua</code> yang sudah kita bahas sebelumnya.</p>

<h2>Mengambil data berelasi</h2>

<p>Setelah berhasil mengambil data dari satu produk, mari kita coba untuk berurusan dengan data berelasi. Sebetulnya prinsipnya sama saja, yaitu membuatkan class konversi. Bedanya hanya terletak pada query SQL yang menggunakan join, tidak ada hubungannya dengan Spring JDBC.</p>

<p>Pada service interface, kita memiliki fitur rekap transaksi untuk satu produk tertentu, yang dimuat dalam method <code>cariPenjualanDetailByProdukDanPeriode</code>. Method tersebut memanggil method <code>cariByProdukDanPeriode</code> dalam class <code>PenjualanDetailDao</code>. Berikut implementasinya.</p>

<p>```java
public class PenjualanDetailDao {</p>

<pre><code>private static final String SQL_CARI_BY_PRODUK_DAN_PERIODE 
        = "select pd.*, p.waktu_transaksi, "
        + "produk.kode as kode_produk, produk.nama as nama_produk,"
        + "produk.harga as harga_produk "
        + "from t_penjualan_detail pd "
        + "inner join t_penjualan p on pd.id_penjualan = p.id "
        + "inner join m_produk produk on pd.id_produk = produk.id " 
        + "where pd.id_produk = ? " +
        + "and (p.waktu_transaksi between ? and ?) " +
        + "limit ?,?";

public List&lt;PenjualanDetail&gt; cariByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai, Integer halaman, Integer baris) {
    return jdbcTemplate.query(SQL_CARI_BY_PRODUK_DAN_PERIODE, 
            new ResultSetJadiPenjualanDetail(), 
            p.getId(), 
            mulai, 
            sampai, 
            PagingHelper.halamanJadiStart(halaman, baris), 
            baris);
}
</code></pre>

<p>}
```</p>

<p>Konversi dari <code>ResultSet</code> menjadi <code>PenjualanDetail</code> dilakukan dalam class <code>ResultSetJadiPenjualanDetail</code> berikut</p>

<p>```java
private class ResultSetJadiPenjualanDetail</p>

<pre><code>    implements RowMapper&lt;PenjualanDetail&gt; {

@Override
public PenjualanDetail mapRow(ResultSet rs, int i) 
        throws SQLException {
    PenjualanDetail p = new PenjualanDetail();
    p.setId((Integer) rs.getObject("id"));
    p.setHarga(rs.getBigDecimal("harga"));
    p.setJumlah((Integer) rs.getObject("jumlah"));

    // relasi ke produk
    Produk px = new Produk();
    px.setId((Integer) rs.getObject("id_produk"));
    px.setKode(rs.getString("kode_produk"));
    px.setNama(rs.getString("nama_produk"));
    px.setHarga(rs.getBigDecimal("harga_produk"));
    p.setProduk(px);

    // relasi ke penjualan
    Penjualan jual = new Penjualan();
    jual.setId((Integer) rs.getObject("id_penjualan"));
    jual.setWaktuTransaksi(rs.getDate("waktu_transaksi"));
    p.setPenjualan(jual);

    return p;
}
</code></pre>

<p>}
```</p>

<p>Selain class <code>PenjualanDetail</code> itu sendiri, kita juga membuatkan object <code>Produk</code> dan <code>Penjualan</code> yang kemudian akan dipasang pada object <code>PenjualanDetail</code>.</p>

<h2>Pagination</h2>

<p>Dalam mengambil data yang berjumlah banyak seperti data transaksi, biasanya kita akan melakukan <em>pagination</em>, yaitu membagi data menjadi beberapa halaman. Di MySQL, kita menggunakan keyword <code>LIMIT</code> untuk melakukan hal ini. Keyword <code>LIMIT</code> menerima dua argumen, yaitu nomer record pertama yang mau diambil dan jumlah record yang mau diambil. Jadi bila kita ingin mengambil record 11 - 15, kita menggunakan keyword <code>LIMIT 11, 5</code>.</p>

<p>Ini agak berbeda dengan argumen yang diterima dalam method pencarian kita. Yang diminta di situ adalah nomer halaman dan jumlah record per halaman. Jadi kalau misalnya data kita berjumlah 56 record dan kita ingin setiap halaman berisi 10 record, maka data tersebut akan terbagi menjadi 6 halaman. Bila kita ingin mengambil halaman terakhir, kita memberikan argumen <code>6</code> dan <code>10</code> ke dalam method pencarian.</p>

<p>Tentunya harus ada konversi dari nomer halaman menjadi nomer baris. Ini kita lakukan di class <code>PagingHelper</code> yang isinya sebagai berikut.</p>

<p>```java
public class PagingHelper {</p>

<pre><code>public static Integer halamanJadiStart(Integer halaman, 
        Integer baris){
    if (halaman &lt; 1) {
        return 0;
    }
    return (halaman - 1) * baris;
}
</code></pre>

<p>}
```</p>

<h2>Header Detail</h2>

<p>Dalam aplikasi, pasti ada fitur untuk menampilkan daftar transaksi dalam periode tertentu.
Seperti sudah kita bahas, satu transaksi terdiri dari satu header dan beberapa detail.
Data ini tentu ingin kita ambil semua.</p>

<p>Caranya sederhana :</p>

<ol>
<li>Query dulu headernya: <code>select * from t_penjualan where id = ?</code></li>
<li>Query detailnya: <code>select * from t_penjualan_detail where id_penjualan = ?</code></li>
<li>Gabungkan keduanya</li>
</ol>


<p>Berikut contohnya, pada waktu kita ingin mencari <code>Penjualan</code> berdasarkan <code>id</code></p>

<p>```java
public Penjualan cariById(Integer id) {</p>

<pre><code>try {
    Penjualan p = jdbcTemplate.queryForObject(SQL_CARI_BY_ID, 
        new ResultSetJadiPenjualan(), id);
    List&lt;PenjualanDetail&gt; daftarDetail = penjualanDetailDao
        .cariByPenjualan(p);
    p.setDaftarPenjualanDetail(daftarDetail);
    return p;
} catch (EmptyResultDataAccessException err) {
    return null;
}
</code></pre>

<p>}
```</p>

<p>Di sana, kita memanggil method <code>cariByPenjualan</code> yang ada di class <code>PenjualanDetailDao</code>. Berikut kode programnya</p>

<p>```java
public List<PenjualanDetail> cariByPenjualan(Penjualan p){</p>

<pre><code>List&lt;PenjualanDetail&gt; hasil 
    = jdbcTemplate.query(SQL_CARI_BY_ID_PENJUALAN, 
        new ResultSetJadiPenjualanDetail(), p.getId());

// set relasi ke penjualan
for (PenjualanDetail penjualanDetail : hasil) {
    penjualanDetail.setPenjualan(p);
}

return hasil;
</code></pre>

<p>}
```</p>

<p>Kembali ke <code>PenjualanDao</code>, setelah kita mendapatkan <code>List&lt;PenjualanDetail&gt;</code> dari method di atas, kita pasang di object penjualan yang sudah kita dapatkan di baris ini</p>

<p><code>java
p.setDaftarPenjualanDetail(daftarDetail);
</code></p>

<p>Demikianlah cara kita mengambil data dari database menggunakan Spring JDBC.
Hal ini tentu tidak rumit asalkan kita sudah paham dasar-dasar SQL termasuk cara melakukan join antar tabel.
Jadi kesimpulannya, untuk mengambil data menggunakan Spring JDBC, yang perlu kita lakukan hanyalah:</p>

<ol>
<li>Membuat SQL, lengkap dengan join bila perlu. Contohnya bisa dilihat di class <code>PenjualanDetailDao</code> yang memiliki banyak join.</li>
<li>Membuat class untuk mengkonversi dari <code>ResultSet</code> menjadi object yang kita inginkan, misalnya <code>Produk</code> atau <code>Penjualan</code></li>
</ol>


<p>Pada bagian selanjutnya, kita tinggal <a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">mengetes kode program</a> yang telah kita buat ini.</p>
]]></content>
  </entry>
  
</feed>
