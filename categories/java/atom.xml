<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-12-10T22:20:22+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Meningkatkan performance Android Emulator]]></title>
    <link href="http://software.endy.muhardin.com/java/meningkatkan-performance-android-emulator/"/>
    <updated>2013-12-10T17:39:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/meningkatkan-performance-android-emulator</id>
    <content type="html"><![CDATA[<p>Setelah kemarin kita mempersiapkan persenjataan untuk coding Android, langkah selanjutnya tentu saja membuat aplikasi <code>Hello World</code> dan kemudian mencoba menjalankannya. Ada dua pilihan cara menjalankan aplikasi Android, yaitu langsung di <em>device</em> atau menggunakan emulator.</p>

<p>Sayangnya, secara default emulator Android sangat lemot. Sedangkan kecepatan kita dalam membangun aplikasi sangat ditentukan oleh kecepatan kita melakukan siklus <em>edit-test-fix</em>. Kalau langkah <em>test</em> butuh waktu lama, dengan sendirinya proses development kita juga akan butuh waktu lama.</p>

<p>Untungnya ada teknik yang tersedia untuk meningkatkan kecepatan emulator Android, yaitu dengan <a href="http://software.intel.com/en-us/articles/speeding-up-the-android-emulator-on-intel-architecture">menggunakan emulator berbasis Intel platform</a>. Kita akan bahas cara-caranya di artikel ini.</p>

<p><img src="http://lh5.googleusercontent.com/-ynU8SU2Efd0/Uqa45WE4K_I/AAAAAAAAC7w/umEdkuO7wqA/w467-h623-no/20131210_134625.jpg"></p>

<!--more-->


<p>Prinsip dasarnya adalah, kita memanfaatkan fitur virtualisasi yang sudah tersedia di prosesor Intel generasi saat ini. Dengan fitur ini, emulator Android bisa berjalan dengan lebih cepat karena ada dukungan di prosesor. Tentunya terlebih dulu kita harus melakukan pengecekan apakah prosesor di komputer kita sudah mendukung fitur ini atau belum.</p>

<p>Di Windows dan Mac, fitur ini diaktifkan dengan driver khusus dari Intel yang disebut dengan Intel® Hardware Accelerated Execution Manager (Intel® HAXM). Sedangkan pada Linux, fitur ini tersedia dalam aplikasi virtualisasi KVM.</p>

<p>Mari kita bahas cara pengecekannya satu persatu dengan Linux maupun dengan Windows.</p>

<h2>Instalasi di Linux</h2>

<p>Berikut adalah langkah-langkahnya:</p>

<ol>
<li>Verifikasi apakah prosesor kita sudah mendukung</li>
<li>Instalasi KVM</li>
<li>Membuat emulator Intel di Android Virtual Device (AVD) Manager</li>
</ol>


<h3>Verifikasi Dukungan Prosesor</h3>

<p>Di Ubuntu, kita bisa menjalankan perintah berikut di terminal.</p>

<p><code>
egrep -c '(vmx|svm)' /proc/cpuinfo
</code></p>

<p>Kalau outputnya <code>0</code>, berarti komputer kita tidak support. Angka <code>1</code> atau lebih menunjukkan bahwa komputer kita mendukung KVM.</p>

<h3>Instalasi KVM</h3>

<p>Berikut perintahnya</p>

<p><code>
sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils
</code></p>

<p>Setelah selesai, kita harus logout dan login lagi, karena Ubuntu menambahkan user kita ke grup <code>libvirtd</code>. Penambahan ke grup ini baru dibaca pada saat kita login.</p>

<p>Kita bisa tes kesuksesan proses instalasi, jalankan perintah berikut:</p>

<p><code>
virsh -c qemu:///system list
</code></p>

<p>Bila sukses, outputnya seperti ini</p>

<p>```</p>

<h2> Id Name                 State</h2>

<p>```</p>

<p>Bila gagal, outputnya seperti ini</p>

<p><code>
libvir: Remote error : Permission denied
error: failed to connect to the hypervisor
</code></p>

<p>Selanjutnya, kita tinggal membuat Android Virtual Device (AVD) yang menggunakan platform Intel. Langkah ini akan kita bahas setelah penjelasan tentang cara instalasi Intel® HAXM di Windows.</p>

<h2>Instalasi di Windows</h2>

<p>Instalasi Intel® HAXM dilakukan melalui Android SDK Manager. Opsinya ada di folder Extra di paling bawah.
Jangan lupa instal juga emulator Intel sekaligus.</p>

<p><img src="http://lh4.googleusercontent.com/-ZitwHacTB50/UqcZWbt1alI/AAAAAAAAC8Y/T_rChtMx4m0/w746-h576-no/haxm01.png"></p>

<p>Instalasi melalui Android SDK Manager ini ternyata hanya mengunduh Intel® HAXM saja. Kita tetap harus menginstalnya sendiri. Cari filenya dalam folder <code>extras</code> dalam Android SDK.</p>

<p><img src="http://lh6.googleusercontent.com/-vyyFTq3bx_4/UqcZVfev3QI/AAAAAAAAC8Q/fAcHpy2KJMo/w233-h122-no/haxm02.png"></p>

<p>Jalankan saja installer seperti biasa. Klik Next sampai selesai.</p>

<h2>Membuat Emulator Intel</h2>

<p>Selanjutnya, kita tinggal membuat AVD seperti biasa. Pastikan kita pilih opsi platform Intel.</p>

<p><img src="http://lh3.googleusercontent.com/-phoDzK--s64/Uqcbh-dQWzI/AAAAAAAAC8s/2WWFtnFY1TE/w572-h623-no/Edit+Android+Virtual+Device+%2528AVD%2529+_001.png"></p>

<p>Jangan lupa untuk mencentang juga opsi <code>Use Host GPU</code> untuk mengalihkan beban pemrosesan tampilan dari emulator ke komputer kita.</p>

<p>Selamat mencoba, seharusnya sekarang emulator bisa dijalankan dengan lebih cepat. Oh iya, ada sedikit keterbatasan. Pada saat artikel ini ditulis, Intel belum merilis emulator untuk Android versi terbaru (KitKat / API level 19). Jadi kita terpaksa coding menggunakan API level 18.</p>

<p>Semoga bermanfaat</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Persiapan Coding Java]]></title>
    <link href="http://software.endy.muhardin.com/java/persiapan-coding-java/"/>
    <updated>2013-11-27T11:10:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/persiapan-coding-java</id>
    <content type="html"><![CDATA[<p>Sebelum kita mulai coding, langkah pertama tentulah menginstal persenjataan. Perlengkapan minimal yang dibutuhkan untuk coding Java sebenarnya cuma:</p>

<ul>
<li>Java SDK</li>
<li>Text editor. Tidak perlu yang canggih, asal ada warnanya seperti Gedit, Notepad++, dan sejenisnya</li>
</ul>


<p>Kalau sudah pakai library tambahan --seperti driver database, framework, dan lainnya-- maka perlu menggunakan <a href="http://maven.apache.org">Maven</a> supaya mudah mengelolanya. Berikut adalah langkah-langkah persiapannya.</p>

<!--more-->


<h2>Langkah Instalasi</h2>

<p>Secara garis besar, langkah-langkahnya sebagai berikut:</p>

<ol>
<li>Install Java SDK</li>
<li>Extract Maven</li>
<li>Setting <em>Environment Variable</em></li>
</ol>


<p>Ada 2 <em>environment variable</em> yang harus dibuat karena belum ada, yaitu:</p>

<ul>
<li>JAVA_HOME : lokasi instalasi Java SDK</li>
<li>M2_HOME : lokasi extract Maven</li>
</ul>


<p>Dan satu yang harus diedit, yaitu variabel <code>PATH</code>. Tambahkan:</p>

<ul>
<li>JAVA_HOME/bin : lokasi compiler java</li>
<li>M2_HOME/bin : lokasi perintah <code>mvn</code></li>
</ul>


<p>Berikut caranya di Ubuntu dan Windows 8.</p>

<h2>Instalasi di Ubuntu</h2>

<p>Di Ubuntu tidak sulit, tinggal install saja paket <code>openjdk-7-jdk</code>. Terserah mau pakai GUI atau command line. Setelah itu kita extract <a href="http://maven.apache.org">Maven</a> di folder manapun yang kita suka. Biasanya saya extract di folder <code>/opt</code>.</p>

<p>Untuk menambahkan environment variable kita edit file <code>/etc/environment</code> sehingga isinya menjadi seperti ini</p>

<p><code>
JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
M2_HOME=/opt/apache-maven-3.1.1
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/apache-maven-3.1.1/bin"
</code></p>

<p>Setelah <code>/etc/environment</code> diedit, restart komputer supaya isi file tersebut dibaca semua aplikasi.</p>

<p>Mudah bukan? Bandingkan panjang penjelasannya dengan Windows di bawah ini ;p</p>

<h2>Instalasi di Windows</h2>

<h3>Instalasi JDK dan Maven</h3>

<p>Java SDK bisa diunduh <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">di sini</a>. Ambil yang <code>JDK</code>, bukan <code>Server JRE</code> ataupun <code>JRE</code>. Setelah terunduh, jalankan installernya, klik Next-next sampai selesai.</p>

<p>Maven bisa diunduh di <a href="http://maven.apache.org">websitenya</a>. Setelah terunduh, extract ke folder manapun. Biasanya saya taruh di folder Program Files</p>

<p><img src="http://lh4.googleusercontent.com/-88rrGGuOgjU/UpVtUVWgtII/AAAAAAAACeU/6uGPetDKkT0/s600/01.+Folder+Program+Files.png"></p>

<p><a name="environment-variable-windows"></a></p>

<h3>Setting Environment Variable</h3>

<p>Selanjutnya sama, kita harus tambahkan variabel <code>JAVA_HOME</code> dan <code>M2_HOME</code>, kemudian edit variabel <code>PATH</code>. Pertama, klik kanan My Computer di Windows Explorer.</p>

<p><img src="http://lh4.googleusercontent.com/-8Cih2iGl_pQ/UpVtUzzuPFI/AAAAAAAACeM/aPAT_hokw-Q/s600/03.+My+Computer+-+Properties.png"></p>

<p>Kemudian tekan Properties. Muncul layar System Information</p>

<p><img src="http://lh5.googleusercontent.com/-Sx6WUwPghwI/UpVtXZKBDhI/AAAAAAAACek/9mq4DYMJ2HQ/s600/04.+System+Properties.png"></p>

<p>Klik Advanced System Setting untuk memunculkan System Properties</p>

<p><img src="http://lh3.googleusercontent.com/-BsUFuPg6rXI/UpVtVzN8ndI/AAAAAAAACeY/WzJtJDNMDEM/s600/04.+System+Properties+-+Environment+Variables.png"></p>

<p>Tekan tombol Environment Variables. Setelah muncul layarnya, tekan tombol <code>New</code> di kotak yang bawah (<code>System Variables</code>). Kemudian isi nama variable <code>JAVA_HOME</code> seperti ini</p>

<p><img src="http://lh3.googleusercontent.com/-ErYIcSxokVo/UpVtXlKvfFI/AAAAAAAACes/cf3WGL5toyc/s600/05.+JAVA_HOME.png"></p>

<p>Nilai <code>value</code> bisa dicopy-paste dari Windows Explorer. Pastikan dia menunjuk ke lokasi instalasi Java SDK</p>

<p><img src="http://lh6.googleusercontent.com/-5RRmCmNhnQ4/UpVtU7VKGBI/AAAAAAAACeE/KVwPyHsp3a0/s600/02.+Folder+Instalasi+Java.png"></p>

<p>Lakukan hal yang sama untuk variabel <code>M2_HOME</code></p>

<p><img src="http://lh6.googleusercontent.com/-ikCikrAAF9M/UpVtXuMUf5I/AAAAAAAACe0/N-Qx-fTacBc/s400/06.+M2_HOME.png"></p>

<p>Cari variabel bernama <code>Path</code>, kemudian Edit</p>

<p><img src="http://lh4.googleusercontent.com/-JNctbwhxp7I/UpVtYZRQuVI/AAAAAAAACfE/y852SKFSYXM/s400/08.+PATH.png"></p>

<p>Isinya adalah sebagai berikut</p>

<p><code>
whatever-isi-path-yang-lama;%JAVA_HOME%\bin;%M2_HOME%\bin
</code></p>

<p>Perhatikan bahwa variabel PATH berisi banyak nilai, di Windows masing-masingnya dipisahkan oleh tanda <code>;</code>. Sedangkan di Linux, dipisahkan oleh tanda <code>:</code></p>

<p>Klik OK untuk menutup semua dialog. Setelah itu kita test. Buka command prompt baru. Kalau sebelumnya sudah membuka command prompt, harus ditutup dulu dan buka yang baru. Konfigurasi yang benar hasilnya seperti ini</p>

<p><img src="http://lh3.googleusercontent.com/-t4G5eQTWL4I/UpVtZPYbJ5I/AAAAAAAACfI/LLj_LzB9H2s/s600/09.+Test+JDK+dan+Maven.png"></p>

<p>Kalau tidak seperti itu, periksa lagi isi <code>JAVA_HOME</code>, <code>M2_HOME</code>, dan <code>PATH</code>.</p>

<p>Selamat coding.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kumpulan Tutorial Spring Framework]]></title>
    <link href="http://software.endy.muhardin.com/java/kumpulan-tutorial-spring-framework/"/>
    <updated>2013-11-25T11:40:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/kumpulan-tutorial-spring-framework</id>
    <content type="html"><![CDATA[<p>Seringkali di milis dan forum banyak yang menanyakan tentang tutorial <a href="http://projects.spring.io/spring-framework/">Spring Framework</a>. Sebetulnya di blog ini banyak, tapi repot juga kalau harus cari-cari di arsip. Jadi, saya buatkan indeks seluruh artikel tentang Spring Framework dalam blog ini. Selamat menikmati :D</p>

<!--more-->


<ol>
<li><p>Fundamental</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/intro-framework/">Alasan menggunakan framework</a></li>
<li><a href="http://software.endy.muhardin.com/java/memahami-dependency-injection/">Konsep Inversion of Control</a></li>
</ul>
</li>
<li><p>Konfigurasi Spring Framework</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur folder project</a></li>
<li><a href="http://software.endy.muhardin.com/java/log4j-spring-mvc/">Konfigurasi Logging</a></li>
<li><a href="http://software.endy.muhardin.com/java/staged-deployment/">Konfigurasi Deployment</a></li>
</ul>
</li>
<li><p>Akses Database</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/insert-update-delete-dengan-spring-jdbc/">Insert Update Delete</a></li>
<li><a href="http://software.endy.muhardin.com/java/query-dengan-spring-jdbc/">Query</a></li>
<li><a href="http://software.endy.muhardin.com/java/mengetes-akses-database/">Testing Kode Akses Database</a></li>
</ul>
</li>
<li><p>Aplikasi Web dengan Spring MVC</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-1/">Membuat halaman web dinamis</a></li>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-2/">Membuat form input</a></li>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-3/">Membuat template aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-4/">Upload File</a></li>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-5/">Session Management</a></li>
<li><a href="http://software.endy.muhardin.com/java/aplikasi-web-spring25-6/">Internationalization (i18n) dan Localization (l10n)</a></li>
</ul>
</li>
<li><p>Integrasi Aplikasi</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/integrasi-aplikasi/">Konsep Integrasi Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/remoting-dengan-spring/">Remoting : Menyediakan akses dan mengakses aplikasi dari aplikasi lain</a></li>
<li><a href="http://software.endy.muhardin.com/java/integrasi-pusat-cabang-1/">Studi Kasus Integrasi Aplikasi</a></li>
<li><a href="http://software.endy.muhardin.com/java/integrasi-pusat-cabang-2/">Integrasi Aplikasi melalui Gmail</a></li>
<li><a href="http://software.endy.muhardin.com/java/integrasi-pusat-cabang-3/">Messaging dan Routing</a></li>
<li><a href="http://software.endy.muhardin.com/java/spring-httpinvoker-sun-jre6-httpserver/">Menjalankan HTTP Server dengan Spring</a></li>
</ul>
</li>
</ol>


<p>Kalau pusing membaca, bisa nonton <a href="https://www.youtube.com/playlist?list=PL9oC_cq7OYbxOX-SxNPsi4r17GOVyHYJI">videonya di Youtube</a>. Source code yang dibahas dalam video bisa diambil <a href="https://github.com/endymuhardin/belajar-spring">di sini</a> dan <a href="https://github.com/endymuhardin/training-2013-01">di sini</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tugas Kuliah Pemrograman 1]]></title>
    <link href="http://software.endy.muhardin.com/java/tugas-kuliah-pemrograman-1/"/>
    <updated>2013-11-21T19:54:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/tugas-kuliah-pemrograman-1</id>
    <content type="html"><![CDATA[<p>Pada posting sebelumnya, kita sudah membahas:</p>

<ul>
<li><a href="http://software.endy.muhardin.com/life/otodidak/">bagaimana cara belajar secara otodidak</a></li>
<li><a href="http://software.endy.muhardin.com/life/lan-na-zha/">pentingnya menguasai konsep dasar / fundamental dari segala sesuatu</a></li>
<li>pentingnya latihan <a href="http://software.endy.muhardin.com/life/rtfm/">membaca dokumentasi</a>, <a href="http://software.endy.muhardin.com/life/problem-solving/">menyelesaikan masalah</a>, dan <a href="http://software.endy.muhardin.com/aplikasi/teknik-menggunakan-google/">mencari solusi</a></li>
</ul>


<blockquote><p>Lalu bagaimana kalau kita baru menguasai dasar-dasar Java? Bagaimana latihannya?</p></blockquote>

<p>Nah, sebetulnya cuma masalah kreativitas saja. Banyak aplikasi yang bisa dibuat dengan teknik minimalis. Sebagai contoh, coba simak tugas kuliah yang saya berikan untuk mata kuliah Pemrograman 1 di Universitas Pancasila. Untuk bisa menyelesaikan tugas ini, skill yang dibutuhkan hanyalah:</p>

<ul>
<li>variabel dan tipe data</li>
<li>looping (for,while) dan percabangan (if-else)</li>
<li>menggunakan class <code>java.lang.String</code></li>
<li>baca/tulis file</li>
</ul>


<p>Referensi yang dibutuhkan hanyalah:</p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/index.html">Tutorial resmi dari Oracle</a> atau <a href="http://project-template.googlecode.com/files/Java%20Desktop%20-%20Ifnu%20Bima.pdf">buku Java Desktop karangan Ifnu Bima</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/api/index.html">Dokumentasi API Java (JavaDocs)</a></li>
</ul>


<p>Studi kasus pada tugas ini merupakan aplikasi yang benar-benar digunakan di dunia nyata.</p>

<p>Selamat mencoba.</p>

<!--more-->


<h1>Deskripsi Aplikasi</h1>

<p>Aplikasi ini akan memproses perhitungan take home pay pegawai tiap bulannya. Tidak digunakan antarmuka pengguna (user interface) karena aplikasi bersifat <code>batch</code>, yaitu berjalan otomatis pada waktu yang ditentukan tanpa membutuhkan intervensi manusia. Input aplikasi berupa file text, dan outputnya juga berupa file text.</p>

<p><img src="http://lh5.googleusercontent.com/-zREpwzUHZVs/Uo4B8sUpjdI/AAAAAAAACT4/3HgNUTbbu1s/w909-h314-no/tugas-kuliah.jpg"></p>

<p>Pada pemakaian sebenarnya, data tarif gaji pegawai bisa diambil dari database. Data absensi diambil dari mesin fingerprint. Hasil perhitungan take home pay akan diupload ke bank untuk proses payroll otomatis.</p>

<h1>Proses Bisnis</h1>

<h2>Input dan Output</h2>

<p>Aplikasi menerima input berupa file text sebagai berikut :</p>

<ul>
<li><code>tarif.csv</code> : berisi nomer induk, nama, tarif gaji pokok, tarif denda, tarif lembur, tarif tunjangan transport</li>
<li><code>absen-MM.csv</code> : berisi nomer induk, tanggal, jam datang, jam pulang</li>
</ul>


<p>Dari dua file input tersebut, aplikasi akan mengeluarkan file text sebagai berikut :</p>

<ul>
<li>takehome-MM.csv : berisi nomer induk, nama, gaji pokok, total denda, total lembur, total tunjangan transport, take home pay</li>
</ul>


<p><code>MM</code> adalah 2 digit bulan. Untuk bulan November, berarti <code>MM</code> akan terisi <code>11</code>.</p>

<h2>Aturan Bisnis</h2>

<ol>
<li>Hari kerja normal Senin - Jumat. Sabtu dan Minggu libur.</li>
<li>Jam kerja normal 09:00 - 17:00.</li>
<li>Bila hadir kerja pada hari normal, mendapatkan tunjangan transport harian sesuai tarif.</li>
<li>Bila datang terlambat, dikenakan denda per jam sesuai tarif denda per jam.</li>
<li>Bila pulang lebih cepat, dikenakan denda per jam sesuai tarif denda per jam.</li>
<li>Bila datang lebih cepat, tidak mendapatkan bonus.</li>
<li>Bila pulang lebih lambat dari jam normal, mendapatkan lembur sesuai tarif lembur per jam.</li>
<li>Bila masuk di hari libur, mendapatkan tunjangan transport dan bonus lembur dihitung per jam sesuai tarif.</li>
<li>Diasumsikan tidak ada hari libur di luar Sabtu-Minggu.</li>
<li>Rumus : <code>take home pay = gaji pokok - total denda + total lembur + total tunjangan transport</code></li>
</ol>


<h2>Contoh File</h2>

<h3>tarif.csv</h3>

<p><code>
no,nama,gaji,denda,lembur,transport
1001,Endy,2000,10,15,30
1002,Adi,3000,15,20,50
1003,Jimmy,3500,15,20,50
1004,Doni,3250,10,10,35
</code></p>

<h3>absen-11.csv</h3>

<p><code>
no,tanggal,datang,pulang
1001,2013-11-01,08:55,17:05
1002,2013-11-01,08:57,17:02
1003,2013-11-01,08:55,17:03
1004,2013-11-01,08:55,17:05
1001,2013-11-02,08:58,17:01
1002,2013-11-02,09:01,18:02
1003,2013-11-02,09:15,18:33
1004,2013-11-02,08:54,19:05
</code></p>

<h3>takehome-11.csv</h3>

<p><code>
no,nama,gaji,denda,lembur,transport,takehome
1001,Endy,2000,100,150,600,2650
1002,Adi,3000,200,300,1000,4100
1003,Jimmy,3500,150,200,950,4500
1004,Doni,3250,250,300,550,3850
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symmetric Encryption dengan Java]]></title>
    <link href="http://software.endy.muhardin.com/java/symmetric-encryption-dengan-java/"/>
    <updated>2013-11-21T12:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/symmetric-encryption-dengan-java</id>
    <content type="html"><![CDATA[<p>Beberapa hari terakhir ini, media massa ribut-ribut mengenai telepon si bos yang disadap orang ostrali. Karena ini blog programming, kita tidak akan membahas tentang implikasi politik dari urusan sadap-menyadap tersebut. Kita juga tidak akan membahas kelakuan ABG script-kiddies yang sudah merasa hebat hanya bermodal donlod script dan menjalankannya (di Windows lagi ;p)</p>

<p>Pada artikel ini, kita akan membahas tentang enkripsi dan dekripsi file. Bagaimana konsepnya, apa pilihan-pilihan yang tersedia, dan mana yang sebaiknya digunakan.</p>

<blockquote><p>Warning! Topik tingkat advanced. Minimal harus sudah menguasai <code>java.io</code>.</p></blockquote>

<!--more-->


<p>Enkripsi adalah proses mengacak data sehingga tidak bisa dibaca orang yang tidak berhak. Sebelum lebih jauh, kita bahas dulu beberapa istilah:</p>

<ul>
<li>enkripsi : proses mengacak data sehingga sulit dibaca</li>
<li>dekripsi : proses membalik data yang diacak sehingga bisa dibaca lagi</li>
<li>key : serangkaian angka/huruf yang digunakan untuk proses enkripsi dan dekripsi</li>
<li>plaintext : data yang ingin dienkripsi. Biasanya data rahasia dan penting, kalau tidak buat apa repot2 dienkripsi.</li>
<li>ciphertext : data yang sudah dienkripsi. Cipher text ini secara teori tidak bisa dibaca oleh orang yang tidak punya key.</li>
</ul>


<p>Prosesnya sederhana.</p>

<ul>
<li>Untuk mengenkripsi :</li>
</ul>


<p><code>
plaintext + key =&gt; ciphertext
</code></p>

<ul>
<li>Untuk mendekripsi :</li>
</ul>


<p><code>
ciphertext + key =&gt; plaintext
</code></p>

<h2>Berbagai Jenis Enkripsi</h2>

<p>Sebenarnya cuma ada dua, jadi tidak perlu pusing ;)</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Symmetric-key_algorithm">Symmetric Encryption</a> : key untuk enkripsi <strong>sama</strong> dengan key untuk dekripsi</li>
<li><a href="http://en.wikipedia.org/wiki/Public-key_cryptography">Asymmetric Encryption</a> : key untuk enkripsi <strong>berbeda</strong> dengan key untuk dekripsi</li>
</ul>


<p>Pada prakteknya, kedua jenis enkripsi ini dipakai secara bersamaan. Jadi bukan pilih yang mana, tapi pakai dua-duanya.</p>

<blockquote><p>Kenapa begitu?</p></blockquote>

<p>Dengan asymmetric encryption <a href="http://stackoverflow.com/questions/10007147/getting-a-illegalblocksizeexception-data-must-not-be-longer-than-256-bytes-when">sulit untuk mengenkripsi data yang besar</a> dan juga <a href="http://en.wikipedia.org/wiki/RSA_(algorithm)#Attacks_against_plain_RSA">tidak aman</a>. Oleh karena itu, biasanya asymmetric encryption hanya digunakan untuk mengenkripsi <code>key</code> saja untuk kemudian dikirim ke pihak lain yang berkomunikasi dengan kita. <code>Key</code> inilah yang nantinya akan digunakan untuk mengenkripsi data sebenarnya menggunakan metode symmetric.</p>

<p>Asymmetric encryption akan kita bahas pada kesempatan lain.</p>

<p>Ada dua metode dalam symmetric encryption, yaitu:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a> : mengenkripsi tiap byte data</li>
<li><a href="http://en.wikipedia.org/wiki/Block_cipher">block cipher</a> : membagi data menjadi beberapa blok, kemudian mengenkripsi masing-masing blok.</li>
</ul>


<p>Kali ini kita hanya membahas block cipher saja.</p>

<h2>Cara Kerja Block Cipher</h2>

<p>Pertama, kita bagi dulu data menjadi blok-blok. Satu blok ukurannya berbeda-beda tergantung algoritma yang digunakan. Misalnya, algoritma AES bloknya berisi 128 bit (atau 16 byte) data. Jadi kalau data kita ada 1 KB, maka akan dibagi menjadi 1024 * 16 = 64 blok.</p>

<p>Masing-masing blok lalu dienkripsi secara terpisah, seperti ilustrasi berikut yang <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">diambil dari Wikipedia</a></p>

<p><img src="https://lh3.googleusercontent.com/-4-C-V41PDlM/Uo2LxRnUjOI/AAAAAAAACSw/JzcKfGUMsAQ/w600-h245-no/Ecb_encryption.png"></p>

<p>Ada berbagai metode dalam mengenkripsi blok-blok data ini. Gambar di atas menunjukkan metode Electronic Codebook yang paling sederhana. Banyak metode lain dengan berbagai plus dan minusnya. Kita tidak akan bahas di sini, silahkan lihat penjelasannya <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">di Wikipedia</a> atau <a href="http://stackoverflow.com/a/1220869">di Stack Overflow</a>.</p>

<p>Setelah memahami cara kerjanya, kita buat dulu rekapitulasi komponen apa saja yang kita butuhkan dalam proses enkripsi ini:</p>

<ul>
<li>plaintext yang ingin dienkripsi</li>
<li>key. Untuk symmetric encryption, key ini harus dirahasiakan. Sebab siapapun yang memiliki key akan bisa melakukan dekripsi</li>
<li><a href="http://en.wikipedia.org/wiki/Initialization_vector">initialization vector</a> : random input supaya hasil enkripsi terlihat berbeda walaupun plain text dan key sama. Initialization vector tidak harus dirahasiakan. Kita bisa kirim IV bersama dengan ciphertext. Walaupun demikian, IV ini harus unik dan sulit ditebak (random). Mengapa? Silahkan baca diskusinya <a href="http://stackoverflow.com/questions/3008139/why-is-using-a-non-random-iv-with-cbc-mode-a-vulnerability">di Stack Overflow</a></li>
<li>algoritma</li>
<li>block cipher mode : metode untuk menggabungkan blok data yang dienkripsi. Block encryption bekerja dengan cara memotong data seukuran blok yang dia mau. Kemudian masing-masing blok dienkripsi. Hasil akhirnya digabungkan menjadi satu lagi. Metode potong-enkripsi-gabung ini <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">memiliki beberapa implementasi berbeda dengan konsekuensi berbeda pula</a>.</li>
<li>padding : Karena ukuran data yang akan dienkripsi bervariasi, kemungkinan besar blok paling akhir tidak terisi penuh. Padahal block encryption mengharuskan semua bloknya terisi. Untuk itu kita harus <em>menambal</em> data jika tidak pas memenuhi ukuran blok. Metode manapun yang dipilih <a href="http://crypto.stackexchange.com/a/1488">tidak berpengaruh terhadap security</a>. Jadi pilih mana saja yang bisa dipakai.</li>
</ul>


<h2>Memilih Algoritma</h2>

<p>Ada beberapa pilihan algoritma untuk melakukan enkripsi, diantaranya:</p>

<ul>
<li>DES</li>
<li>Triple Des / 3DES</li>
<li>AES</li>
<li>Blowfish</li>
<li>dsb</li>
</ul>


<p>Masing-masing memiliki plus-minus, untuk menyingkat pembahasan, kita akan menggunakan AES saja. Perbandingan dan alasan pemilihan AES bisa dibaca <a href="http://www.javamex.com/tutorials/cryptography/ciphers.shtml">di artikel ini</a>.</p>

<p>Selain AES, 3DES juga banyak digunakan di industri perbankan untuk mengamankan transaksi ATM, EDC, dan berbagai bentuk transaksi elektronik lainnya. Algoritma manapun yang digunakan tidak masalah, langkah-langkah dan prinsipnya tetap sama. Untuk mengubah dari algoritma satu ke yang lain cuma perlu mengubah satu baris kode program saja.</p>

<p>Pilihan algoritma yang didukung oleh Java bisa dibaca <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher">di daftar ini</a>.</p>

<h2>Generate Key</h2>

<p>Sebelum membuat key, kita harus menentukan dulu panjang keynya.</p>

<blockquote><p>Berapa panjang key yang ideal?</p></blockquote>

<p>Menurut NSA, 256 bit. <a href="https://twitter.com/SteveBellovin/status/311545287313330176">Katanya supaya kebal dari serangan quantum computer</a>. Nah, sudah jelas bahwa saya tidak lebih pintar daripada NSA, yang mengajari orang ostrali bagaimana cara menyadap bos kita. Jadi ya kita terima saja sarannya untuk menggunakan 256 bit. Toh ngetik 128 dan 256 sama-sama efisien dari sisi jumlah tombol yang ditekan ;)</p>

<p>Dengan menggunakan 256 bit, kita akan mendapatkan <a href="http://blog.agilebits.com/2013/03/09/guess-why-were-moving-to-256-bit-aes-keys/">keuntungan tambahan</a> jika nantinya kita menggunakan <a href="http://blog.agilebits.com/2013/01/18/authenticated-encryption-and-how-not-to-get-caught-chasing-a-coyote/">message authentication</a> dan <a href="http://blog.agilebits.com/2011/05/05/defending-against-crackers-peanut-butter-keeps-dogs-friendly-too/">password derivation</a>.</p>

<p>Berdasarkan cara membuatnya, kita bedakan menjadi dua macam key:</p>

<ul>
<li>key yang dibuat secara random</li>
<li>key yang ditentukan user (password)</li>
</ul>


<p>Random key biasanya digunakan tanpa user input. Misalnya aplikasi A ingin mengirim data ke aplikasi B. Supaya aman, data ini ingin dienkripsi. Supaya lebih aman, key yang digunakan untuk enkripsi diganti secara periodik, supaya tidak bisa ditebak oleh penyadap. Nah tentunya akan sangat merepotkan kalau key ini harus diinput user tiap kali dia harus diganti. Untuk keperluan ini, kita gunakan random key. Karena tidak perlu dihafalkan manusia, maka key ini bentuknya bebas saja.</p>

<p>Berbeda halnya dengan key yang ditentukan user. Karena key ini harus dihafalkan user, maka biasanya user mencari rangkaian huruf/angka yang mudah dia hafalkan. Untuk itu, perlu ada tindakan tambahan supaya lebih aman. Tindakan tambahan ini disebut dengan istilah <a href="http://en.wikipedia.org/wiki/Key_stretching">key stretching</a>.</p>

<p>Cara kerja key stretching intinya adalah <a href="http://en.wikipedia.org/wiki/Key_derivation_function">key derivation</a>, yaitu mengkonversi key asli menjadi key turunan. Key turunan inilah yang sebenarnya digunakan untuk melakukan enkripsi, bukan key asli. Proses key derivation dirancang sedemikian rupa untuk menghindari <a href="http://en.wikipedia.org/wiki/Weak_key">kelemahan</a> yang biasa ditemukan di password biasa, misalnya:</p>

<ul>
<li>jumlah karakternya kurang</li>
<li>variasi angka/huruf/karakter kurang banyak</li>
<li>biasanya menggunakan kata-kata yang ada di kamus, sehingga mudah ditebak</li>
<li>urutan karakter tidak random (misalnya abcd4321, cobacoba1234)</li>
</ul>


<p>Melalui proses <em>key stretching</em> password yang biasanya tidak memenuhi syarat kriptografi dikonversi sehingga memenuhi syarat. Algoritma yang biasa digunakan antara lain:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bcrypt">Bcrypt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Scrypt">Scrypt</a></li>
</ul>


<p>Kita hanya akan bahas PBKDF2 saja karena:</p>

<ul>
<li>populer</li>
<li>tersedia di Java tanpa perlu donlod paket tambahan</li>
<li>kebutuhan resource tidak terlalu besar, sehingga tersedia di berbagai platform (misalnya smartphone dan tablet)</li>
</ul>


<h3>Generate Random Key</h3>

<p>Berikut kode program untuk membuat key yang random.</p>

<p>```java
KeyGenerator keygen = KeyGenerator.getInstance("AES");
keygen.init(256);
SecretKey key = keygen.generateKey();</p>

<p>System.out.println("Generated Key : " + Base64.encodeBase64String(key.getEncoded()));
```</p>

<p>Key yang digenerate harus sesuai dengan algoritma enkripsi yang digunakan.</p>

<h3>Key Stretching</h3>

<p>Berikut kode program untuk key stretching. Kita akan membuat key turunan dari password yang lemah (hanya ada huruf, tidak ada angka dan karakter aneh).</p>

<p>```java
String password = "sangat rahasia sekali";</p>

<p>// generate random salt
SecureRandom randomizer = new SecureRandom();
BigInteger random = new BigInteger(32, randomizer);
String salt = random.toString(64);</p>

<p>int perulangan = 1000;
String algoritma = "PBKDF2WithHmacSHA1";
int panjangKey = 256;</p>

<p>PBEKeySpec keyspec = new PBEKeySpec(password.toCharArray(), salt.getBytes("UTF-8"), perulangan, panjangKey);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algoritma);
SecretKey key = keyFactory.generateSecret(keyspec);</p>

<p>System.out.println("Password asli : "+password);
System.out.println("Salt : "+salt);
System.out.println("Generated Key : " + Base64.encodeBase64String(key.getEncoded()));
```</p>

<p>Secara fungsi, salt mirip dengan initialization vector. Yaitu agar password yang sama hasil hash-nya berbeda. Salt juga tidak perlu dirahasiakan, tapi perlu disimpan supaya bisa dipakai untuk memeriksa password. Jika kita simpan password di database dengan mekanisme <em>key stretching</em> ini, yang harus kita simpan adalah:</p>

<ul>
<li>salt</li>
<li>jumlah perulangan</li>
<li>panjang key</li>
<li>key yang dihasilkan (ciphertext)</li>
</ul>


<blockquote><p>Perhatian! Key stretching ini bekerja satu arah. Artinya kita tidak bisa mendapatkan password plaintext dari ciphertextnya.</p></blockquote>

<h2>Contoh Kasus</h2>

<p>Sebagai contoh, kita ingin mengenkripsi file text. Supaya mudah, kita buat saja file text berisi lirik lagu yang bisa kita dapatkan di internet. Sepanjang prosedur enkripsi-dekripsi, ada beberapa file yang kita akan buat:</p>

<ul>
<li><code>lyric.txt</code> : file plaintext yang ingin kita enkripsi</li>
<li><code>key.txt</code> : file berisi key untuk enkripsi. Key ini bisa dibuat secara random ataupun dari input user yang sudah melalui proses <em>key stretching</em>.</li>
<li><code>iv.txt</code> : initialization vector</li>
<li><code>lyric-enc.txt</code> : file ciphertext hasil enkripsi</li>
<li><code>lyric-dec.txt</code> : file plaintext hasil dekripsi lyric-enc.txt</li>
</ul>


<p>Berikut langkah-langkah enkripsi:</p>

<ol>
<li>Generate key</li>
<li>Inisialisasi object yang akan melakukan enkripsi (<code>java.crypto.Cipher</code>) menggunakan key</li>
<li>Generate IV</li>
<li>Lakukan prosedur enkripsi, hasilnya tulis ke <code>lyric-enc.txt</code>.</li>
<li>Tulis juga key ke file <code>key.txt</code> dan IV ke file <code>iv.txt</code> untuk digunakan dalam proses dekripsi. Pada kondisi riil, IV bisa kita kirimkan melalui jalur publik, sedangkan key harus kita kirim melalui jalur aman. Biasanya key dienkripsi lagi menggunakan asymmetric encryption agar bisa dikirim dengan aman.</li>
</ol>


<p>Langkah-langkah dekripsi kebalikannya:</p>

<ol>
<li>Baca key dari file <code>key.txt</code></li>
<li>Baca IV dari file <code>iv.txt</code></li>
<li>Inisialisasi object yang akan melakukan dekripsi (<code>java.crypto.Cipher</code>) menggunakan key <strong>dan</strong> IV</li>
<li>Lakukan proses dekripsi</li>
</ol>


<p>Kalau sudah paham langkahnya, mari kita coding. Sebelum masuk ke kriptografi, kita bereskan dulu masalah tampilan.</p>

<h2>String Conversion</h2>

<p>Proses enkripsi menghasilkan binary data, dalam Java ini ditampung dalam tipe data <code>byte[]</code>. Binary data ini tidak bisa kita buka di text editor, sehingga menyulitkan kita untuk debug. Oleh karena itu, kita perlu menggunakan <a href="http://en.wikipedia.org/wiki/Base64">encoding Base 64</a> untuk mengkonversinya menjadi <code>String</code>. Kalau kita langsung memasukkannya ke dalam constructor String, hasilnya akan kacau karena <a href="http://stackoverflow.com/a/10759422">constructor String bingung ketika menghadapi karakter-karakter aneh</a> (non-printable).</p>

<p>Encoding Base64 kita lakukan dengan <a href="http://commons.apache.org/proper/commons-codec/">library <code>commons-codec</code> dari Apache</a>.</p>

<h2>Inisialisasi Cipher untuk Enkripsi</h2>

<p>Pertama, kita generate dulu key. Untuk enkripsi, object <code>cipher</code> harus diinisialisasi dengan key.</p>

<p>```java
String algoritmaKey = "AES";</p>

<p>// generate random key
KeyGenerator keygen = KeyGenerator.getInstance(algoritmaKey);
keygen.init(256);
SecretKey key = keygen.generateKey();</p>

<p>// tulis key ke file untuk keperluan dekripsi
Files.write(keyFile.toPath(), Base64.encodeBase64String(key.getEncoded()).getBytes(), StandardOpenOption.CREATE);
```</p>

<p>Pada kode program di atas, kita lihat bahwa sebelum ditulis ke file, kita encode dulu dengan method <code>Base64.encodeBase64String</code> supaya filenya bisa dibuka di text editor.</p>

<p>Setelah punya key, kita buat object <code>cipher</code></p>

<p><code>java
String algoritmaEnkripsi = "AES/CBC/PKCS5Padding";
Cipher cipher = Cipher.getInstance(algoritmaEnkripsi);
cipher.init(Cipher.ENCRYPT_MODE, key);
</code></p>

<p>Dari kode program di atas, kita bisa lihat bahwa:</p>

<ul>
<li>algoritma yang digunakan adalah <code>AES</code></li>
<li>block cipher mode menggunakan <code>CBC</code></li>
<li>padding menggunakan <code>PKCS5</code></li>
</ul>


<h2>Generate Initialization Vector</h2>

<p>IV kita generate menggunakan object <code>cipher</code></p>

<p><code>java
// generate IV
byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
</code></p>

<p>Jangan lupa ditulis ke file karena nanti akan kita butuhkan di proses dekripsi.</p>

<p><code>java
Files.write(ivFile.toPath(), Base64.encodeBase64String(iv).getBytes(), StandardOpenOption.CREATE);
</code></p>

<h2>Proses Enkripsi</h2>

<p>Kelengkapan sudah siap, mari kita lakukan proses enkripsi</p>

<p>```java
// tujuan hasil enkripsi
CipherOutputStream writer =</p>

<pre><code>        new CipherOutputStream(
            new FileOutputStream(encryptedFile), cipher);
</code></pre>

<p>// enkripsi isi file
FileReader reader = new FileReader(plain);
int data;
while((data = reader.read()) != -1){</p>

<pre><code>System.out.print((char)data);
writer.write(data);
</code></pre>

<p>}</p>

<p>reader.close();
writer.close();
```</p>

<p>Seharusnya, pada tahap ini kita sudah memiliki file berikut:</p>

<ol>
<li><code>lyric.txt</code></li>
<li><code>key.txt</code></li>
<li><code>iv.txt</code></li>
<li><code>lyric-enc.txt</code></li>
</ol>


<p>File <code>lyric-enc.txt</code> dan <code>iv.txt</code> kita kirimkan ke penerima. Dia harusnya sudah memiliki file <code>key.txt</code>.</p>

<p>Proses enkripsi selesai. Kode program lengkapnya bisa dilihat <a href="https://github.com/endymuhardin/belajar-enkripsi/blob/master/src/main/java/com/muhardin/endy/belajar/enkripsi/AESEncryptionDemo.java">di Github</a>.</p>

<p>Mari kita lanjutkan dengan proses dekripsi.</p>

<h2>Membaca key dan IV dari file</h2>

<p>Berikut kode programnya</p>

<p>```java
// load key
List<String> keys = Files.readAllLines(keyFile.toPath(), Charset.forName("UTF-8"));
if(keys.isEmpty()){</p>

<pre><code>throw new IllegalStateException("File key invalid");
</code></pre>

<p>}
String key = keys.get(0);
System.out.println("Key : "+key);
SecretKeySpec keySpec = new SecretKeySpec(Base64.decodeBase64(key), algoritmaKey);</p>

<p>// load IV
List<String> ivs = Files.readAllLines(ivFile.toPath(), Charset.forName("UTF-8"));
if(ivs.isEmpty()){</p>

<pre><code>throw new IllegalStateException("File IV invalid");
</code></pre>

<p>}
String iv = ivs.get(0);
System.out.println("IV : "+iv);
IvParameterSpec ivSpec = new IvParameterSpec(Base64.decodeBase64(iv));
```</p>

<h2>Inisialisasi Cipher</h2>

<p>Untuk proses dekripsi, inisialisasi <code>cipher</code> membutuhkan key dan IV.</p>

<p><code>java
// inisialisasi AES
Cipher cipher = Cipher.getInstance(algoritmaEnkripsi);
cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
</code></p>

<p>Jangan lupa gunakan mode <code>Cipher.DECRYPT_MODE</code>.</p>

<h2>Proses Dekripsi</h2>

<p>Tidak sulit, tinggal membalik saja prosedur enkripsi.</p>

<p>```java
// output hasil dekripsi
FileWriter output = new FileWriter(decryptedFile);</p>

<p>// dekripsi isi file
CipherInputStream cis = new CipherInputStream(new FileInputStream(encryptedFile), cipher);
int data;
while((data = cis.read()) != -1){</p>

<pre><code>output.write(data);
</code></pre>

<p>}
cis.close();
output.close();
```</p>

<h2>Verifikasi</h2>

<p>Setelah kita punya hasil dekripsi, tentu kita harus verifikasi apakah sama persis dengan aslinya. Caranya adalah dengan membandingkan <code>hash</code> file asli dan file hasil dekripsi. Kita bisa gunakan berbagai algoritma seperti <code>MD5</code> atau <code>SHA</code>. Berikut contohnya</p>

<p><code>java
// bandingkan apakah hasil dekripsi sama dengan file asli
String md5sumAsli = DigestUtils.md5Hex(new FileInputStream(plainFile));
String md5sumHasilDekripsi = DigestUtils.md5Hex(new FileInputStream(decryptedFile));
System.out.println("MD5 Sum File Asli           : "+md5sumAsli);
System.out.println("MD5 Sum File Hasil Dekripsi : "+md5sumHasilDekripsi);
System.out.println(md5sumAsli.equals(md5sumHasilDekripsi) ? "Cocok" : "Tidak cocok");
</code></p>

<p>Proses dekripsi selesai. Kode program lengkapnya bisa dilihat <a href="https://github.com/endymuhardin/belajar-enkripsi/blob/master/src/main/java/com/muhardin/endy/belajar/enkripsi/AESDecryptionDemo.java">di Github</a>.</p>

<h3>Message Authentication</h3>

<p>Message authentication cara kerjanya kira-kira sama dengan metode verifikasi di atas. Intinya adalah:</p>

<ol>
<li>Generate hash dari file A</li>
<li>Generate hash dari file B</li>
<li>Bandingkan, jika hash sama berarti file A dan B isinya sama</li>
</ol>


<p>Dalam kaitannya dengan enkripsi, kita menambahkan key pada proses hash ini supaya lebih aman. Tanpa key, orang lain bisa mencoba-coba generate hash dari file yang dia miliki. Kalau berhasil membuat hash yang sama, maka dia bisa menebak atau memalsukan data yang dikirim. Dengan menggunakan key yang hanya diketahui pihak yang berkomunikasi, maka orang lain sulit untuk membuat hash yang sama.</p>

<p>Proses ini nama kerennya adalah <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC (hash-based message authentication code)</a>.</p>

<p>Berikut kode program untuk menghasilkan hash dari data yang sudah dienkripsi</p>

<p>```java
// HMAC untuk memastikan integritas data
String algoritmaHmac = "HmacSHA512";
KeyGenerator keygenHmac = KeyGenerator.getInstance(algoritmaHmac);
keygenHmac.init(256);</p>

<p>// key untuk HMAC
SecretKey keyHmac = keygenHmac.generateKey();
Files.write(hmacKeyFile.toPath(),</p>

<pre><code>    Base64.encodeBase64String(keyHmac.getEncoded()).getBytes(), 
    StandardOpenOption.CREATE);
</code></pre>

<p>// buat HMAC
Mac hmacGenerator = Mac.getInstance(algoritmaHmac);
hmacGenerator.init(keyHmac);
byte[] hmac = hmacGenerator.doFinal(Files.readAllBytes(encryptedFile.toPath()));
Files.write(hmacFile.toPath(), hmac, StandardOpenOption.CREATE);
```</p>

<p>Perhatikan bahwa kita terlebih dulu menghasilkan key untuk membuat hash. Key ini harus dimiliki juga oleh pihak penerima data.</p>

<p>Sekarang, kita lakukan verifikasi di sisi penerima.</p>

<p>```java
// sebelum dekripsi, cek dulu HMAC apakah datanya otentik
List<String> hmacKeys = Files.readAllLines(hmacKeyFile.toPath(), Charset.forName("UTF-8"));
if(hmacKeys.isEmpty()) {</p>

<pre><code>throw new IllegalStateException("No mac key");
</code></pre>

<p>}
String hmacKey = hmacKeys.get(0);
SecretKeySpec hmacKeySpec = new SecretKeySpec(Base64.decodeBase64(hmacKey), algoritmaHmac);
Mac hmacGenerator = Mac.getInstance(algoritmaHmac);
hmacGenerator.init(hmacKeySpec);</p>

<p>// generate hmac dari data yang diterima
byte[] hmacDiterima = hmacGenerator.doFinal(Files.readAllBytes(encryptedFile.toPath()));
// baca hmac yang disertakan bersama data
byte[] hmacSeharusnya = Files.readAllBytes(hmacFile.toPath());
boolean cocok = Arrays.equals(hmacDiterima, hmacSeharusnya);
System.out.println(cocok ? "HMAC Cocok" : "HMAC Tidak Cocok");
if(!cocok){</p>

<pre><code>throw new IllegalStateException("Data tidak otentik, mungkin sudah dioprek orang ditengah jalan");
</code></pre>

<p>}
```</p>

<p>Verifikasi HMAC ini kita lakukan <strong>sebelum</strong> melakukan dekripsi. Tidak ada gunanya dan menambah resiko kalau kita melakukan proses dekripsi (di mana kita membuka dan menggunakan key rahasia) terhadap data yang invalid.</p>

<h1>Kesimpulan</h1>

<p>Pengirim dan penerima harus terlebih dulu memiliki:</p>

<ul>
<li>key enkripsi</li>
<li>key HMAC</li>
</ul>


<p>Kedua file ini harus dirahasiakan dari pihak yang tidak berkepentingan. Distribusinya bisa dilakukan dengan enkripsi menggunakan asymmetric encryption.</p>

<p>Pada saat berkomunikasi, pengirim akan memberikan:</p>

<ul>
<li>initialization vector</li>
<li>data yang terenkripsi</li>
<li>HMAC</li>
</ul>


<p>Ketiga data di atas boleh dikirim melalui jalur publik.</p>

<p>Setelah menerima ketiga file tersebut, penerima akan melakukan:</p>

<ol>
<li>Generate HMAC dari data terenkripsi</li>
<li>Bandingkan HMAC hasil generate dengan HMAC yang dikirim bersama data. Kalau tidak cocok, jangan diteruskan.</li>
<li>Kalau cocok, barulah lakukan dekripsi menggunakan key dan IV.</li>
</ol>


<blockquote><p>Bagaimana, pusing?</p></blockquote>

<p>Ya tinggal pilih, pusing belajar atau kena sadap :D</p>

<p>Kode program selengkapnya (seperti biasa) ada <a href="https://github.com/endymuhardin/belajar-enkripsi">di Github</a></p>
]]></content>
  </entry>
  
</feed>
