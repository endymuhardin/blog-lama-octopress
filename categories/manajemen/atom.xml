<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: manajemen | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/manajemen/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-11-27T11:48:38+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Training CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/training-cmmi/"/>
    <updated>2013-05-10T14:13:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/training-cmmi</id>
    <content type="html"><![CDATA[<p>Saya akan mengisi <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">training CMMI di Brainmatics</a> minggu depan, Senin - Rabu, 13 - 15 Mei 2013. Buat yang belum paham apa itu CMMI, bisa baca <a href="http://software.endy.muhardin.com/manajemen/apa-itu-cmmi/">artikel saya mengenai masalah ini</a>.</p>

<p>Sebenarnya, materi tentang CMMI banyak bertebaran secara gratis di internet. Bahkan spesifikasi resminya gratis bisa diunduh di <a href="http://cmmiinstitute.com/">websitenya Carnegie Mellon University</a>. Lalu buat apa ikut training lagi kalau di internet sudah banyak materinya?</p>

<!--more-->


<p>Berikut beberapa alasannya:</p>

<ul>
<li>Materi CMMI yang ada di website sangat abstrak dan penjelasannya bersifat umum.</li>
<li>Agar bisa diimplementasikan di perusahaan, aturan CMMI ini harus dibuatkan dulu padanan/mapping dengan proses bisnis di internal perusahaan.</li>
<li>Proses bisnis di internal perusahaan belum tentu selengkap yang diminta CMMI, sehingga harus didesain dan dibuat dulu.</li>
<li>Seringkali terjadi, cara mendesain proses bisnis yang baik juga belum dikuasai. Ini akan kita bahas pada sesi training.</li>
<li>Setelah dibuat, proses bisnis harus diimplementasikan ke seluruh perusahaan. Implementasi proses bisnis ada metodologinya sendiri.</li>
<li>Di website CMMI, dijelaskan proses appraisal, yaitu proses untuk menilai perusahaan apakah sudah sesuai dengan aturan CMMI. Penjelasan di kertas tentu jauh berbeda dengan pengalaman nyata yang saya alami pada waktu implementasi CMMI.</li>
<li>Ada banyak <a href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/">mitos dan urban legend tentang CMMI</a>, terutama yang berkaitan dengan metodologi agile seperti Scrum, Kanban, XP, dan lainnya. Pada sesi training, kita akan bahas mana yang mitos mana yang nyata.</li>
</ul>


<p>Silabus lengkap bisa dilihat di <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">website Brainmatics</a>. Tapi banyak jargon teknis di sana yang baru bisa kita pahami kalau sudah mengerti CMMI. Untuk yang masih awam, berikut adalah hal yang akan kita pelajari/lakukan selama training:</p>

<ol>
<li><p>Apa itu CMMI</p>

<ul>
<li>sejarah</li>
<li>use case</li>
<li>manfaat buat kita</li>
</ul>
</li>
<li><p>Isi perut CMMI</p>

<ul>
<li>apa itu process area</li>
<li>apa itu goals</li>
<li>apa itu practices</li>
<li>apa yang dimaksud generic goals/practices</li>
<li>apa yang dimaksud specific goals/practices</li>
<li>apa itu maturity level</li>
<li>apa yang dimaksud staged representation dan continuous representation</li>
<li>bagaimana proses appraisal</li>
</ul>
</li>
<li><p>Metodologi implementasi</p>

<ul>
<li>menentukan target maturity level yang realistis untuk dicapai perusahaan kita</li>
<li>melakukan gap analysis, antara kondisi perusahaan kita sekarang dan kondisi yang diminta CMMI</li>
<li>membuat mapping antara kebutuhan CMMI dan proses bisnis di perusahaan kita</li>
<li>cara mendesain proses bisnis perusahaan yang efektif dan komprehensif</li>
<li>cara implementasi proses bisnis yang sudah dibuat</li>
<li>tips dan trik dalam proses appraisal</li>
</ul>
</li>
</ol>


<p>Trainingnya akan berbentuk workshop. Saya akan menjelaskan teori secara singkat, lalu kita lanjutkan dengan praktek dan diskusi. Target training ini adalah, peserta pulang dengan membawa :</p>

<ul>
<li>strategi implementasi</li>
<li>daftar proses bisnis yang harus dibuat/direvisi</li>
<li>contoh dokumen dan template</li>
<li>action plan yang harus mereka lakukan di perusahaannya untuk berhasil mencapai target maturity level yang diinginkan.</li>
</ul>


<p>Jadi, tunggu apa lagi, ayo segera daftar. Sampai ketemu di sesi training :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release Management]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/release-management/"/>
    <updated>2012-08-29T18:01:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/release-management</id>
    <content type="html"><![CDATA[<p>Release, atau di-Indonesia-kan menjadi rilis, adalah tahap yang paling penting dalam software development. Segala kegiatan hulu (upstream activity) lainnya seperti <a href="/manajemen/fase-requirement/" title="Fase Requirement">requirement</a>, desain aplikasi, coding, testing, dan lainnya, semua dilakukan demi untuk menghasilkan software yang bisa dirilis. Sebagus apapun kita melakukan kegiatan lainnya, jika rilisnya tidak bagus, maka semua yang kita kerjakan menjadi tidak bagus. Sebaliknya, berbagai kesalahan dan kekurangan di kegiatan lain akan mudah dimaafkan dan dilupakan kalau kita menghasilkan rilis yang baik. Walaupun demikian, perlu diingat bahwa bila kita melakukan kegiatan hulu dengan baik, biasanya kita bisa menghasilkan rilis yang berkualitas baik secara konsisten.</p>

<p>Pada artikel ini, kita akan membahas pernak-pernik yang berkaitan dengan rilis. Apa itu rilis, berbagai jenis rilis, syarat dan ketentuan rilis, dan juga prosedur yang kita gunakan di ArtiVisi.</p>

<!--more-->


<h1>Apa itu rilis</h1>

<p>Rilis pada intinya adalah menyerahkan software yang sudah kita kerjakan ke pihak lain. Berdasarkan siapa yang dimaksud dengan pihak lain, kita membedakan rilis menjadi :</p>

<ul>
<li>rilis internal : menyerahkan software ke pihak internal tim pengembang, misalnya dari programmer ke tester.</li>
<li>rilis eksternal : menyerahkan ke pihak luar seperti client atau customer.</li>
</ul>


<p>Kita tidak harus menunggu sampai software selesai dikerjakan 100% untuk melakukan rilis. Berdasarkan tingkat penyelesaian pekerjaan, kita bisa membedakan rilis menjadi :</p>

<ul>
<li><p>development release : Ini adalah rilis yang dilakukan sebelum software selesai dikerjakan. Rilis ini dibuat untuk menunjukkan kemajuan dalam proses development, misalnya menunjukkan tambahan fitur baru ataupun sekedar menunjukkan perbedaan dengan rilis sebelumnya. Development release biasa dilakukan secara rutin dan periodik. Ada yang melakukannya secara mingguan, harian, bahkan dua kali sehari. Rilis jenis ini juga biasa disebut dengan unstable release (karena softwarenya belum stabil - sering hang atau error), milestone release, daily/nightly build release, atau alpha release.</p></li>
<li><p>testing release : Ini adalah rilis yang dilakukan setelah aplikasi siap untuk dites. Pada titik ini biasanya sudah tidak ada penambahan fitur lagi. Software yang dibuat diserahkan ke tester untuk dicari bugnya. Hasil laporan bug itu kemudian akan ditindak lanjuti sehingga menghasilkan testing release berikutnya. Kalau kita pernah mendengar istilah beta release, biasanya itu maksudnya adalah testing release. Orang sering membagi lagi testing release menjadi beta release dan release candidate. Pada prinsipnya, beta dan release candidate sama saja, bedanya ada di cakupan tester. Beta release khusus untuk dites oleh tester, sedangkan release candidate bisa juga dites oleh end-user.</p></li>
<li><p>final release : Rilis jenis ini menyatakan bahwa software sudah selesai dikerjakan, dites, dan laporan bugnya sudah ditindak lanjuti. Biasa disebut juga stable release, karena software yang dihasilkan bisa digunakan dengan lancar dan nyaman (stabil).</p></li>
</ul>


<h1>Manfaat Rilis</h1>

<p>Manfaat rilis tentunya adalah supaya software yang sudah susah payah kita buat, bisa bermanfaat bagi penggunanya dan sukur-sukur bisa menghasilkan uang bagi pembuatnya. Karena di atas kita sudah membahas berbagai jenis rilis, tentu juga ada macam-macam manfaat dari berbagai jenis rilis tersebut.</p>

<p>Development release sebaiknya dilakukan sesering mungkin. Agar tidak merepotkan, dilakukan menggunakan perangkat otomasi seperti <a href="http://jenkins-ci.org/" title="Jenkins Continuous Integration">Jenkins</a>. Manfaat dari development release adalah untuk memastikan integrasi antara fitur berjalan dengan baik. Sering kali pada saat membuat fitur X, secara tidak sengaja mempengaruhi fitur Y sehingga tidak berjalan dengan baik. Hal inilah yang coba dicegah dengan development release.</p>

<p>Testing release manfaatnya adalah supaya software yang kita buat bisa diperiksa oleh orang lain dengan perspektif yang berbeda dan lebih fresh. Programmer yang membuat aplikasi pastinya sudah hafal perilaku aplikasi yang dibuatnya, sehingga bisa menghindari error yang mungkin terjadi. Tapi tester atau user tidak memiliki pengetahuan tentang cara kerja internal aplikasi, sehingga lebih mungkin menemukan skenario yang belum diantisipasi oleh software.</p>

<p>Final release tentunya berguna supaya software kita bisa digunakan oleh masyarakat umum. Para pengguna (end user) biasanya menunggu sampai suatu software dinyatakan selesai, baru dia mau menggunakannya. Demikian juga bila aplikasi yang kita buat akan dibundel oleh orang lain (contohnya distro Linux, integrasi dengan aplikasi lain, dsb), tentu mereka akan menunggu keluarnya rilis final.</p>

<h1>Aturan Rilis</h1>

<p>Seperti kita bahas sebelumnya, tujuan rilis adalah supaya software kita bisa digunakan oleh orang lain. Oleh karena itu, kita harus memudahkan pengguna dalam memahami rilis yang kita keluarkan.</p>

<p>Hal paling penting dalam melakukan rilis adalah aturan penamaan. Dengan aturan penamaan yang baik, kita bisa:</p>

<ul>
<li>menjelaskan status rilis, apakah ini development release, testing, atau final.</li>
<li>menjelaskan kompatibilitas dengan versi sebelumnya dan aplikasi lain. Ini akan dijelaskan secara lebih detail sebentar lagi.</li>
<li>menjelaskan hubungan dengan rilis lainnya. Bila kita memiliki dua rilis, kita bisa membedakan mana rilis yang duluan dan mana yang belakangan.</li>
</ul>


<h1>Studi Kasus</h1>

<p>Untuk memudahkan pemahaman tentang penamaan rilis, mari kita karang studi kasusnya, yaitu Facebook Contact Backup.</p>

<blockquote><p>Aplikasi Facebook Contact Backup (FCB) adalah aplikasi yang bisa mendownload daftar contact kita di facebook, kemudian menuliskannya ke dalam text file. Contoh textfile akan dilampirkan di bawah. Untuk versi pertama, informasi kontak yang ditampilkan adalah : nama, email, no HP.</p></blockquote>

<p>Berikut contoh file yang dihasilkan oleh aplikasi FCB</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;081298000468&lt;/mobile&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<blockquote><p>Karena aplikasi FCB kemudian menjadi populer, ada orang lain yang membuat aplikasi untuk mengisi phonebook di handphone bernama Handphone Contact Importer (HCI). Aplikasi HCI ini menggunakan aplikasi FCB untuk connect ke facebook dan mengambil data contact. Setelah datanya ada dalam format textfile, aplikasi HCI akan membaca text file tersebut dan kemudian mengisinya ke phonebook handphone.</p></blockquote>

<p>Aplikasi FCB dikembangkan dengan cepat sehingga menghasilkan beberapa rilis sebagai berikut:</p>

<h2>Rilis Pertama</h2>

<p>Memperbaiki format nomer handphone, sehingga semua diseragamkan menjadi format internasional. Nomer <code>081298000468</code> pada contoh di atas akan dikonversi menjadi <code>+6281298000468</code></p>

<h2>Rilis Kedua</h2>

<p>Fix protokol komunikasi ke Facebook, karena ada perubahan di Facebook API.</p>

<h2>Rilis Ketiga</h2>

<p>Menambahkan field ulang tahun sehingga format text file menjadi sebagai berikut :</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281298000468&lt;/mobile&gt;
    &lt;birthdate&gt;1945-08-17&lt;/birthdate&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
    &lt;birthdate&gt;2011-11-11&lt;/birthdate&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<h2>Rilis Keempat</h2>

<p>Ganti format xml menjadi json, mengikuti trend masa kini.
``` js facebook_contact.json
[</p>

<pre><code>{
    name: "Endy Muhardin",
    email: "endy@geemail.com",
    mobile: "+6281298000468",
    birthdate: "1945-08-17"
},
{
    name: "Ifnu Bima",
    email: "ifnu@geemail.com",
    mobile: "+6281234567890",
    birthdate: "2011-11-11"
}
</code></pre>

<p>]
```</p>

<p>Dengan studi kasus di atas, kita harus mempertimbangkan penomoran rilis untuk aplikasi FCB dengan benar, supaya aplikasi HCI bisa tahu apa yang harus dilakukan pada saat aplikasi FCB mengeluarkan rilis baru.</p>

<h1>Kompatibilitas</h1>

<p>Dalam mengeluarkan rilis untuk aplikasi FCB, kita harus mempertimbangkan aplikasi HCI agar tidak rusak. Pengaruh aplikasi FCB terhadap HCI dikenal dengan istilah kompatibilitas. Kompatibilitas dibedakan berdasarkan ketergantungan secara programmatic:</p>

<ul>
<li>binary compatibility : FCB terbaru disebut binary-compatible dengan HCI bila FCB yang sudah dicompile bisa langsung ditaruh di folder dan dipakai oleh HCI.</li>
<li>source compatibility : FCB terbaru disebut source-compatible dengan HCI bila FCB yang sudah dicompile tidak bisa langsung ditaruh begitu saja. HCI harus dicompile ulang dulu dengan FCB terbaru, baru HCI bisa dijalankan.</li>
</ul>


<p>Lebih lanjut tentang binary vs source compatibility bisa dibaca <a href="http://blogs.msdn.com/b/jmstall/archive/2008/03/10/binary-vs-source-compatibility.aspx">di artikel ini</a>.</p>

<p>Dan juga bisa dibedakan berdasarkan hubungannya dengan rilis terdahulu.</p>

<ul>
<li>backward compatibility : bila HCI versi terbaru bisa menggunakan format data FCB yang terdahulu. Misalnya, aplikasi HCI terbaru bisa membaca data versi baru (json), versi sebelumnya (xml), dan sebelumnya lagi (xml tanpa field birthdate)</li>
<li>forward compatibility : bila HCI versi jadul bisa membaca format data FCB yang lama (xml tanpa birthdate) dan yang lebih baru yang dirilis setelah HCI jadul tersebut (xml dengan birhtdate).</li>
</ul>


<p>Setelah kita memahami urusan kompatibilitas, kita bisa menentukan skema penamaan rilis, atau dikenal dengan istilah version numbering.</p>

<h1>Version Numbering</h1>

<p>Kita akan menggunakan <a href="http://apr.apache.org/versioning.html" title="Version Numbering APR">aturan dari Apache Portable Runtime</a> yang sudah diakui sebagai best-practices dalam version numbering. Aturan APR mengharuskan ada tiga komponen version number, yaitu :</p>

<ul>
<li>major number</li>
<li>minor number</li>
<li>patch number</li>
</ul>


<p>Contohnya, waktu pertama kita merilis FCB, kita beri nama <code>FCB-1.0.0</code>. Major numbernya 1, minor numbernya 0, patch numbernya 0.</p>

<p>Untuk rilis selanjutnya, kita menaikkan major/minor/patch number sesuai dengan pengaruhnya terhadap kompatibilitas. Aturannya sebagai berikut:</p>

<ul>
<li>major number dinaikkan bila FCB baru tidak kompatibel dengan FCB rilis sebelumnya. Bila HCI dipasang dengan FCB terbaru ini, HCI akan error.</li>
<li>minor number dinaikkan bila FCB baru mengandung penambahan fitur, tapi tetap kompatibel dengan HCI yang dibuat berdasarkan FCB lama. HCI versi lama tetap bisa jalan, walaupun tidak bisa memanfaatkan fitur yang baru.</li>
<li>patch dinaikkan bila tidak ada perubahan secara fitur, tapi cuma ada perbaikan di internal FCB yang tidak terlihat dari luar (misalnya optimasi koneksi jaringan, perubahan protokol ke arah Facebook, dsb)</li>
</ul>


<p>Selanjutnya, mari kita beri nomer sesuai studi kasus kita di atas.</p>

<ol>
<li>Rilis Pertama : diberi nama <code>1.1.0</code>, karena cuma terjadi perubahan di content saja. HCI yang dibuat dengan FCB versi <code>1.0.0</code> akan tetap berjalan lancar</li>
<li>Rilis Kedua : diberi nama <code>1.1.1</code>, karena perubahan protokol komunikasi dengan Facebook tidak mempengaruhi HCI sama sekali. HCI versi lama tetap bisa jalan dengan lancar.</li>
<li>Rilis Ketiga : diberi nama <code>1.2.0</code>, sama dengan rilis pertama. Ada penambahan fitur, tapi tidak membuat HCI jadi error. Dengan rilis ini, programmer HCI bisa menambahkan fitur baru misalnya reminder ulang tahun. Tapi HCI versi lama (tanpa reminder ulang tahun) tetap bisa digunakan dengan <code>FCB-1.2.0</code></li>
<li>Rilis Keempat : diberi nama <code>2.0.0</code>. Ini adalah perubahan signifikan. Untuk dapat menggunakan <code>FCB-2.0.0</code> ini, HCI harus mengalami perubahan signifikan. HCI versi lama tidak bisa digunakan dengan <code>FCB-2.0.0</code>. Agar dapat digunakan, programmer HCI harus mengeluarkan rilis baru yang bisa mengakomodasi format data JSON.</li>
</ol>


<p>Berikutnya, mari kita lihat pengaruhnya untuk HCI.</p>

<ol>
<li><code>HCI-1.0.0</code> : versi pertama, dibuat dengan <code>FCB-1.0.0</code></li>
<li>Rilis <code>FCB-1.1.0</code> : tidak ada tambahan fitur yang bisa dibuat di HCI, sehingga programmernya tidak coding.</li>
<li>Rilis <code>FCB-1.1.1</code> : tidak ada perubahan yang terlihat. Programmer HCI makan gaji buta sambil update status Facebook. Nganggurnya programmer HCI ini berarti <code>HCI-1.0.0</code> forward-compatible dengan <code>FCB-1.0.0</code>, <code>FCB-1.1.0</code>, hingga <code>FCB-1.1.1</code>.</li>
<li>Rilis <code>FCB-1.2.0</code> : ada field baru (birthdate) yang bisa dimanfaatkan, programmer HCI mulai coding.</li>
<li><code>HCI-1.1.0</code> : tambahan fitur reminder ulang tahun. <code>HCI-1.1.0</code> ini backward-compatible dengan <code>FCB-1.1.1</code>, <code>FCB-1.1.0</code>, maupun <code>FCB-1.0.0</code>.</li>
<li>Rilis <code>FCB-2.0.0</code> : HCI semua versi tidak dapat digunakan bila user meng-upgrade FCB-nya. Programmer HCI harus segera mengeluarkan rilis baru, tidak boleh coding sambil facebookan.</li>
<li><code>HCI-1.1.1</code> : bagi end-user, HCI terbaru ini tidak ada tambahan fiturnya. Tapi dia fixing bug, yang tadinya error pada waktu dijalankan (karena FCB-nya tidak kompatibel), menjadi tidak error.</li>
</ol>


<p>Selain major.minor.patch, ada kalanya orang juga menambahkan satu informasi lagi yang menyatakan kestabilan rilis. Berikut beberapa contohnya:</p>

<ul>
<li><code>FCB-1.0.1-SNAPSHOT</code> : ini biasanya digunakan untuk mencerminkan rilis daily build terbaru</li>
<li><code>FCB-1.0.0-20121212080808</code> : ini biasanya digunakan untuk menunjukkan hasil daily build tertentu</li>
<li><code>FCB-1.0.1-RC-01</code> : release candidate pertama</li>
<li><code>FCB-1.0.0-M2</code> : milestone kedua</li>
<li><code>FCB-1.0.0-Final</code> : final release. Ada orang yang menambahkan keyword Final, ada juga yang tidak.</li>
<li><code>FCB-1.0.0-GA</code> : generally available, sama dengan final release</li>
<li><code>FCB-1.0.0-RELEASE</code> : sama dengan GA dan Final</li>
</ul>


<p>Penomoran versi ini terlihat sepele saja. Tapi kalau kita tidak punya aturan penamaan yang jelas, maka orang lain akan bingung setiap kali ada rilis baru. Mereka tidak bisa menentukan apakah harus upgrade atau tidak, karena mereka tidak bisa tahu bagaimana kompatibilitas rilis ini dengan aplikasi lainnya. Salah satu contoh populer kekacauan yang disebabkan penomoran versi yang sembarangan <a href="http://news.ycombinator.com/item?id=1734936">bisa dilihat di komunitas Ruby</a>. Akibat aturan rilis Ruby tidak jelas, sehingga dibutuhkan aplikasi lain seperti RVM atau rbenv supaya antar versi Ruby tidak saling bentrok. Effort yang dikeluarkan untuk membuat dan memantain RVM dan rbenv tentu tidak sedikit. Ini semua disebabkan <em>hanya karena</em> penomoran versi belaka. Hasil akhir dari semua ini, sampai saat artikel ini ditulis, <a href="http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/">Ruby belum bisa dipaket dengan benar di distro Debian</a> dan turunannya (termasuk Ubuntu).</p>

<h1>Release Notes</h1>

<p>Tentunya penomoran versi saja tidak bisa memuat informasi yang detail. Kita membutuhkan sarana lain untuk memberikan informasi yang detail tentang isi dari suatu rilis. Untuk keperluan ini, biasanya orang membuat dokumen yang disebut Release Notes. Beberapa hal yang biasanya dicantumkan dalam release notes antara lain:</p>

<ul>
<li>fitur baru</li>
<li>bug yang diperbaiki</li>
<li>enhancement/improvement, yaitu perbaikan pada fitur yang ada</li>
<li>known issues, yaitu bug atau error yang sudah teridentifikasi tapi belum difix. Informasi ini menunjukkan bahwa programmernya sudah tahu bahwa ada bug, tapi karena satu dan lain hal belum memperbaikinya</li>
<li>kontributor, yaitu siapa saja yang berkontribusi di rilis ini.</li>
<li>to do, yaitu fitur apa yang direncanakan akan dibuat pada rilis berikut. Informasi ini bisa juga ditulis di dokumen terpisah bernama roadmap</li>
</ul>


<p>Contoh release notes bisa dilihat <a href="/images/uploads/2012/08/RELEASE.txt" title="Contoh Release Notes">di sini</a>.</p>

<h1>Tools</h1>

<p>Ada beberapa hal yang perlu dilakukan pada waktu kita akan melakukan rilis, yaitu:</p>

<ul>
<li>menaikkan nomor versi di source code. Biasanya kita ada mencantumkan nomor versi di aplikasi, misalnya di halaman About.</li>
<li>membuat rekap perubahan yang terjadi sejak rilis sebelumnya</li>
<li>membuat tag di version control database</li>
</ul>


<p>Semua kegiatan di atas dapat dioptimasi dengan tools misalnya <a href="http://maven.apache.org/plugins/maven-release-plugin/" title="Maven Release Plugin">maven-release-plugin</a>. Cara pakainya bisa dilihat <a href="http://java.dzone.com/articles/automating-releases-maven-0">di sini</a>. Tapi beberapa orang melihat bahwa maven-release-plugin ini tidak memenuhi kebutuhannya, sehingga dia pakai <a href="http://www.axelfontaine.com/2011/01/maven-releases-on-steroids-adios.html">cara yang lain</a>.</p>

<p>Di ArtiVisi, kita sudah mencoba maven-release-plugin, dan berpendapat bahwa dia <a href="http://www.sonatype.com/people/2011/01/using-the-maven-release-plugin-things-to-know/">terlalu kaku</a> sehingga sulit dikonfigurasi agar sesuai dengan kebutuhan kita. Akhirnya kita menggunakan cara manual dengan prosedur sebagai berikut:</p>

<h2>Prosedur Rilis ArtiVisi</h2>

<p>Contoh skenario :</p>

<ul>
<li>Rilis sebelumnya : <code>1.2.0</code></li>
<li>Rilis sekarang : <code>1.2.1</code></li>
</ul>


<p>Langkah-langkah melakukan rilis :</p>

<ol>
<li><p>Generate Changelog dengan perintah <code>git shortlog 1.2.0..HEAD</code></p></li>
<li><p>Copy paste output dari langkah 1 ke dalam release notes.</p></li>
<li><p>Naikkan version number di dalam source code menggunakan Eclipse. Search file <code>pom.xml</code>, find <code>1.2.0</code> dan replace menjadi <code>1.2.1</code>.</p></li>
<li><p>Save semua file, kemudian commit ke Git dengan perintah <code>git commit -m "release 1.2.1"</code></p></li>
<li><p>Buat tag di Git dengan perintah <code>git tag -a -F RELEASE.txt 1.2.1</code></p></li>
</ol>


<h1>Penutup</h1>

<p>Demikianlah penjelasan tentang serba-serbi release management dalam software development. Mudah-mudahan bisa membuat project dan produk yang kita hasilkan lebih mudah dikelola.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Meluruskan Mitos CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/"/>
    <updated>2011-08-10T15:01:25+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi</id>
    <content type="html"><![CDATA[<p>Di milis manajemen proyek IT sedang rame diskusi tentang CMMI dan Scrum.
Seperti layaknya diskusi yang rame, perdebatan dibumbui dengan segala macam mitos dan 'FUDification'.</p>

<p>Berikut adalah tanggapan saya tentang mitos yang berkembang mengenai CMMI, dicopy-paste dari posting milis dengan sedikit penyesuaian.</p>

<p>Beberapa mitos yang akan diluruskan :</p>

<ul>
<li>CMMI adalah metodologi manajemen proyek yang cenderung waterfall</li>
<li>CMMI mewajibkan kita bikin banyak dokumen</li>
</ul>


<p>Pada artikel ini, kita akan meluruskan mitos-mitos tersebut.</p>

<h2>CMMI = metodologi, cenderung waterfall</h2>

<p>CMMI bukanlah metodologi manajemen proyek seperti
<a href="http://en.wikipedia.org/wiki/Scrum_(development">Scrum</a>), <a href="http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process">IBM Rational Unified Process</a>, <a href="http://en.wikipedia.org/wiki/Extreme_Programming">XP</a>, apalagi <a href="http://en.wikipedia.org/wiki/Waterfall_model">Waterfall</a>.</p>

<p>CMMI sebetulnya sudah pernah saya jelaskan <a href="http://endy.artivisi.com/blog/manajemen/apa-itu-cmmi/">di posting saya sebelumnya</a>. Tapi untuk lebih menyederhanakan lagi, kita bisa analogikan CMMI seperti akreditasi perguruan tinggi. Kalau kita mau daftar kuliah, biasanya kita cari tahu akreditasi kampus yang kita tuju. Semakin tinggi akreditasinya, semakin tinggi ekspektasi kita terhadap kualitas perguruan tinggi tersebut. <a href="http://ban-pt.kemdiknas.go.id/">Akreditasi perguruan tinggi</a> <a href="http://ban-pt.kemdiknas.go.id/index.php?option=com_content&amp;view=article&amp;id=57&amp;Itemid=63&amp;lang=in">ditentukan oleh banyak hal</a>, diantaranya :</p>

<ul>
<li>berapa jumlah dosen yang S3</li>
<li>berapa karya ilmiah dan penelitian yang dihasilkan dalam satu periode</li>
<li>dsb</li>
</ul>


<p>Untuk menentukan suatu kampus mendapat level A, B, atau lainnya, maka ada tim assessor yang akan memeriksa apakah kampus tersebut sudah memenuhi apa yang dipersyaratkan.</p>

<p>Demikian juga dengan CMMI, berisi seperangkat checklist yang bentuknya kira-kira seperti ini:</p>

<table>
<thead>
<tr>
<th></th>
<th> Level  </th>
<th> Process Area </th>
<th> OK </th>
<th> Not OK </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>   2    </td>
<td> REQM         </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PP           </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PMC          </td>
<td>    </td>
<td>   v</td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> MA           </td>
<td>    </td>
<td>   v</td>
</tr>
</tbody>
</table>


<p>Nah, checklist itu nanti akan dicentang sesuai dengan kapabilitas perusahaan yang diperiksa.</p>

<p>Adapun urusan Scrum, Waterfall, XP, whatever metodologi yang kita gunakan,
hanyalah mencakup sebagian saja dari CMMI.</p>

<p>CMMI itu model untuk menggambarkan organisasi pembuat software yang mature. Apa itu mature? Salah satu karakteristiknya adalah konsistensi. Perusahaan yang gak mature, hasil kerjanya gak konsisten. Project A ontime, Project B molor 3 tahun. Project X bugnya dikit, Project Y isinya bug doang gak ada fiturnya.</p>

<p>Kalau kita bisa mengeksekusi project dengan sukses, kita hanya bisa lulus CMMI level 2. Untuk bisa mendapatkan level 3, kita harus bisa mengeksekusi project dengan sukses <strong>secara konsisten</strong>.
Untuk bisa konsisten, maka kita harus bisa menduplikasi project sukses ke seluruh perusahaan. Jadi, kalau kita sudah sukses pakai Scrum di project kita sekarang, tetap saja baru level 2. Hanya setelah kesuksesan Scrum bisa direplikasi di keseluruhan perusahaan, barulah bisa level 3.</p>

<p>Seperti juga halnya replikasi resep McDonalds ke seluruh cabang, untuk bisa mereplikasi project sukses ke seluruh perusahaan,
dibutuhkan kegiatan tambahan di level organisasi, misalnya :</p>

<ul>
<li>Menulis SOP (OPD)</li>
<li>Membuat program pelatihan internal (OT)</li>
<li>Selalu menganalisas prosedur yang sekarang berlaku, supaya bisa diimprove (OPF)</li>
</ul>


<p>Yang di dalam kurung adalah process area yang bersesuaian di CMMI.</p>

<p>Berurusan dengan perusahaan yang mature akan mengurangi resiko di client. Apa itu resiko?</p>

<p>Buat orang awam seperti kita, resiko adalah simply sekian persen kemungkinan adanya masalah di kemudian hari. Nah, ada perspektif finansial yang kita orang teknis biasanya gak kepikiran. Buat orang finance, persentase tersebut bisa diuangkan. Misalnya kita mau bikin aplikasi costnya 100 M, uangnya minjem ke bank. Karena pada dasarnya bank gak mau rugi, 100 M itu akan diasuransikan sama dia. Jadi kalo projectnya bubaran, kita gak sanggup bayar, hutangnya akan ditalangin sama asuransi.</p>

<p>Asuransi akan lihat, kita pakai vendor siapa. Kalo vendornya gak mature (baca: resiko tinggi) maka premi asuransinya akan tinggi. Akibatnya, biaya pinjaman kita (cost of money) juga tinggi.</p>

<p>Bisa aja kita bayar 100 M (pokok) + 20 M (bunga) + 20 M (asuransi). Padahal kalo vendornya mature, premi asuransinya cuma 5 M. Nah, jadi urusan resiko dan maturity ini bukan semata jargon2 aja, tapi ada duit beneran yang tersangkut di dalamnya.</p>

<p>Demikianlah mitos pertama, CMMI bukan metodologi manajemen proyek, melainkan manajemen keseluruhan perusahaan.</p>

<h2>CMMI mewajibkan kita bikin banyak dokumen</h2>

<p>CMMI sama sekali tidak mengharuskan kita bikin dokumen apa-apa.</p>

<p>Yang ada, kita harus :</p>

<ul>
<li><strong>melakukan</strong> project planning (level 2)</li>
<li><strong>melakukan</strong> project monitoring &amp; control (level 2)</li>
<li><strong>mendefinisikan</strong> project life cycle : bisa waterfall, scrum, spiral, cowboy programming juga boleh</li>
</ul>


<p>Berikut beberapa definisi singkat</p>

<ul>
<li>Planning : merencanakan apa yang akan dilakukan</li>
<li>Monitoring : melihat kondisi aktual, apakah sesuai dengan plan</li>
<li>Control : melakukan tindakan kalau kondisi aktual tidak sesuai dengan plan</li>
</ul>


<p>Nah, kita harus membuktikan bahwa kita benar2 melakukan apa yang disuruh. Gimana cara membuktikannya?</p>

<p>Kita bisa :</p>

<ol>
<li>Tunjukkan dokumen hardcopy, atau</li>
<li>Tunjukkan bahwa kita melakukan planning, monitoring, dan control di aplikasi yang kita pakai (Redmine, planningpoker.com, pivotaltracker.com, basecamphq.com, fogbugz, whatever)</li>
</ol>


<p>Nah, dari 2 cara di atas, kalo kita <strong>benar-benar</strong> melakukan, akan lebih mudah menunjukkan yang #2. Tapi kalo akal2an, sebenarnya gak planning tapi mau ngakunya planning, akan lebih mudah memalsukan yang #1. Soalnya #2 gak bisa di-back-dated, sedangkan #1 bisa.</p>

<p>Jadi, fokusnya lebih ke <strong>melakukan proses</strong>, bukan <strong>membuat dokumen</strong></p>

<p>Kemudian, ada kesalah-kaprahan juga yang umum terjadi tentang planning. Planning itu tidak sekali saja lalu dipakai sepanjang project. Project plan harus mencerminkan kondisi yang terbaru dari project. Misalnya, kita bikin plan awal (versi 1) selesai 3 bulan. Ternyata waktu monitoring di akhir bulan 1, kita udah tau bahwa gak bakalan selesai dalam 2 bulan sisanya. Kita harus melakukan controlling terhadap projectnya. Tindakan control bisa macam2, bisa kita tambah orang biar tetap selesai dalam 3 bulan, bisa juga revisi plannya sehingga mencerminkan kondisi setelah 1 bulan berjalan.</p>

<p>UUD 45 aja bisa diamandemen, masa project plan gak bisa :D</p>

<p>Contoh lain, mengelola requirement (Requirement Management), Level 2.</p>

<p><blockquote><p>S.P 1.1 : Understand Requirement : kita harus memastikan bahwa requirement dipahami.</p></blockquote></p>

<p>Gimana cara membuktikannya?</p>

<p>Kalo prosesnya benar-benar dijalankan, kita bisa tunjukkan email dari BA ke Client yang isinya mengkonfirmasi pemahaman BA tentang requirement yang diminta Client.</p>

<p>Atau kalo seperti Scrum, Clientnya hadir di ruangan yang sama, gak nyatet apa2, rekaman audio juga boleh. Intinya, ada sesuatu yang bisa ditunjukkan ke auditor bahwa kita sudah Understanding Requirement.</p>

<p>Kalo prosesnya palsu, artinya sebenarnya gak dilakukan, tapi mau lulus Level 2, maka dibuatlah dokumen palsu. Bentuknya biasanya review report, isinya item2 requirement, lalu nanti ada tandatangan client palsu.</p>

<p>So, overhead dokumen (mis: review report) itu ada kalo kita memalsukan proses.</p>

<p>Selama kita benar-benar menjalankan apa yang disuruh, pasti ada evidence bahwa kita menjalankan, entah itu bentuknya chat YM, email, Skype call, apalah terserah, tidak ada CMMI mewajibkan formatnya harus mp3 atau apa.</p>

<p><blockquote><p>SP 1.2 : Obtain Commitment to Requirement : semua pihak harus commit terhadap requirement yang sudah dibuat.</p></blockquote></p>

<p>Gimana cara membuktikan bahwa kita comply dengan SP ini?</p>

<p>Paling gampang, BA kirim email ke Client, "Pak, di iterasi ini, kita kerjakan req #12, #14, sama #15 ya. #13 pending dulu aja"</p>

<p>Client reply, "Ok"</p>

<p>That's it, tunjukkan emailnya ke auditor, beres.</p>

<p>Kalau proses ini tidak dijalankan, akan menimbulkan masalah di kemudian hari. Usernya client bilang A, bosnya user bilang A+, programmer bilang C, PM bilang lain lagi. Sekali lagi, selama prosesnya dilakukan, emailnya pasti ada.</p>

<p>Kalo prosesnya palsu, atau clientnya gaptek gak kenal email, ya dibuatlah dokumen requirement sign off. Orang2 tandatangan. Dokumennya dijadikan evidence.</p>

<p><blockquote><p>SP 1.3 : Manage Requirement Changes : kalo requirement berubah, harus di-manage.</p></blockquote></p>

<p>Apa itu dimanage?</p>

<p>Dimanage artinya harus jelas :
- apa yang berubah
- siapa yang minta berubah
- siapa yang approve
- apa impactnya ke schedule/cost/effort/cuaca hari ini</p>

<p>Apa buktinya? Email boleh, chat log boleh, rekaman cctv boleh.</p>

<p>Ok, lalu kenapa semua harus ada evidence ??</p>

<p>Berikut joke dari auditor kita dulu,</p>

<p><blockquote><p>In God We Trust, everybody else brings data.</p></blockquote></p>

<p>Jadi, CMMI = banyak dokumen hanyalah mitos belaka. Untuk bisa melakukan verifikasi, auditor tentu butuh melihat evidence. Di jaman modern seperti sekarang, evidence bentuknya tidak harus dokumen tertulis yang dibuat dengan aplikasi office.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Estimasi Proyek Software]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/estimasi-proyek-software/"/>
    <updated>2011-05-11T06:37:12+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/estimasi-proyek-software</id>
    <content type="html"><![CDATA[<blockquote><p>Saya ingin membuat aplikasi akunting, berapa lama dan berapa biayanya?</p></blockquote>

<p>Demikian pertanyaan yang amat sering kita temui di profesi software developer.</p>

<p>Topik estimasi proyek merupakan topik yang sulit. Steve McConnell menyebutnya Black Art,
sehingga dia mengarang buku yang sangat bagus tentang topik ini,
judulnya Software Estimation, Demystifying the Black Art.</p>

<p>Menurut Steve, dalam membuat estimasi, ada 3 metode yang dilakukan, yaitu</p>

<ul>
<li><p>count</p></li>
<li><p>compute</p></li>
<li><p>judge</p></li>
</ul>


<p>Kita harus selalu berusaha count, karena ini yang paling akurat.
Kalo ditanya berapa tinggi pohon, paling baik adalah ambil meteran dan ukur pohonnya.
Dimana kita tidak bisa count, maka kita compute.
Contohnya, di sebelah pohon ada pagar dan di atas pagar ada tiang lampu.
Kita compute jumlah tinggi pagar dan tinggi tiang lampu, sehingga dapat tinggi pohon.
Hanya kalau tidak ada cara lain, baru kita judge.
Dikira2 tingginya berapa.</p>

<p>Dalam kaitannya dalam estimasi, idealnya yang kita estimasi hanyalah project size.
Metric lainnya akan kita compute dari project size ini.</p>

<h2>Apa itu project size?</h2>

<p>Project size merupakan ukuran suatu project.
Dengan project size, kita bisa membandingkan dua aplikasi yang berbeda,
misalnya aplikasi akunting dan aplikasi toko online.</p>

<p>Ada banyak metric untuk mengukur ukuran project. Metric yang paling lazim digunakan
adalah jumlah baris kode program, dalam bahasa Inggris disebut Source Lines of Code (SLOC)
atau Non Commenting Source Code (NCSS).</p>

<p>Walaupun SLOC sangat akurat dalam menentukan ukuran project, tapi jumlah baris kode sulit diperkirakan di awal project.
Oleh karena itu, beberapa orang kreatif lalu mengarang metode baru yang disebut Function Point Calculation.
Metode ini pada intinya adalah menghitung berapa screen input, screen output, jumlah tabel database, dan interaksinya dengan aplikasi lain.</p>

<p>Setelah kita mendapatkan estimasi ukuran project, kita akan menggunakannya untuk mengestimasi effort, durasi, dan cost.</p>

<p>Sebelum lebih jauh, mari kita jelaskan istilah-istilahnya.</p>

<p>Effort, adalah kerja real yang kita lakukan dalam menyelesaikan project. Satuannya adalah mandays atau manhour.
Misalnya suatu aplikasi diestimasi membutuhkan effort 10 mandays. Artinya aplikasi ini akan selesai bila dikerjakan 1 orang selama 10 hari terus menerus.
Atau 5 hari bila ada 2 pekerja. Effort tidak mempertimbangkan libur ataupun cuti.</p>

<p>Durasi (bahasa Inggrisnya schedule), adalah jangka waktu penyelesaian project. Ini biasanya dinyatakan dalam satuan hari kerja atau hari kalender.
Bila durasi project dinyatakan 10 hari kalender, maka bila dimulai tanggal 1, akan selesai tanggal 10.</p>

<p>Jadi, untuk mendapatkan durasi, kita harus punya asumsi berikut :</p>

<ul>
<li><p>berapa orang yang dipekerjakan</p></li>
<li><p>berapa hari libur</p></li>
<li><p>berapa alokasi waktu non-pekerjaan seperti meeting, presentasi, dsb</p></li>
</ul>


<p>Asumsi tersebut, digabungkan dengan estimasi effort, akan menghasilkan estimasi durasi.</p>

<p>Setelah durasi didapatkan, menghitung estimasi cost mudah saja. Kita membutuhkan matriks gaji per role.
Berapa gaji project manager, gaji programmer, dan role lain dalam setahun, termasuk THR, tunjangan kesehatan, benefit lain dan bonus.
Bagilah dengan hari kerja setahun sehingga didapatkan nilai gaji sehari.
Kemudian petakan penggunaan masing-masing role dalam schedule yang sudah kita estimasi, dan kita akan mendapat biaya personel.
Tambahkan dengan biaya lain-lain seperti transport, komunikasi, dsb untuk mendapatkan biaya total.
Masukkan juga faktor resiko project, misalnya kalau clientnya terkenal sulit ditagih, tentu perlu ada koefisien pengali.
Karena tagihan macet sama dengan kita memberi hutang ke client.</p>

<p>Nah, akhirnya biaya total sudah didapatkan, silahkan tambahkan profit yang diinginkan, buffer negosiasi, dan voila, dapatlah harga penawaran.</p>

<p>Selesai? Belum dong :D</p>

<p>Pembaca yang teliti tentu akan menemukan satu celah di penjelasan di atas. Bagaimana mengkonversi estimasi project size menjadi estimasi effort?
Nah disinilah bedanya perusahaan besar kaya pengalaman dengan startup mahasiswa baru lulus. Perusahaan dengan jam terbang tinggi biasanya punya data historis.
Dia punya data misalnya berapa mandays yang dibutuhkan programmer untuk membuat aplikasi dengan 3 tabel database.
Tentunya data ini harus dikumpulkan, diolah, dan diupdate agar bisa dijadikan pedoman. Ini sebabnya tidak semua perusahaan besar punya data ini.
Dengan bermodalkan data ini, perusahaan tinggal mengkonversi project size menjadi effort.
Setidaknya ada dua jenis data yang kita butuhkan, yaitu berapa effort yang dibutuhkan untuk menyelesaikan satu baris kode, dan bagaimana distribusi effort selama fase project. Maksudnya, bila project kita diestimasi 100 mandays, berapa mandays habis di analisa, coding, testing, implementasi, dan maintenance.
Selain itu, juga perlu ada matriks distribusi effort per role. Dengan adanya matriks ini, kita akan lebih mudah menkonversi effort menjadi durasi dan cost.</p>

<p>Startup mahasiswa, karena tidak punya data, maka cuma bisa tebak-tebak buah manggis. Atau kalo mau sedikit ilmiah, bisa mengikuti cara kami di ArtiVisi waktu baru mulai dulu. Kita membuat aplikasi kecil, kemudian datanya dikumpulkan dan dijadikan pedoman.</p>

<p>Jadi, kesimpulannya, begini metode estimasinya.</p>

<p><strong>Kebutuhan Data</strong></p>

<ol>
<li><p>Tabel konversi size ke mandays</p></li>
<li><p>Tabel gaji pegawai per role per hari</p></li>
<li><p>Tabel distribusi effort per fase</p></li>
<li><p>Tabel distribusi effort per role</p></li>
</ol>


<p>Flow Estimasi</p>

<ol>
<li><p>Estimasi Size</p></li>
<li><p>Dari size, gunakan tabel #1 untuk mendapatkan effort</p></li>
<li><p>Dari effort, gunakan tabel #3 untuk mendapatkan durasi</p></li>
<li><p>Dari effort, gunakan tabel #4 untuk mendapatkan effort per personel</p></li>
<li><p>Dari effort per personel, gunakan tabel #2 untuk menghitung biaya personel</p></li>
<li><p>Gunakan durasi untuk menghitung biaya lain-lain</p></li>
</ol>


<p>Demikian metodologi untuk melakukan estimasi project software. Membuat estimasi saja tidak cukup, kita juga harus bisa mempresentasikan dan mempertahankannya dari negosiasi pihak lain. Ini akan dibahas di lain kesempatan.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/prototyping/"/>
    <updated>2010-07-07T01:41:17+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/prototyping</id>
    <content type="html"><![CDATA[<p>Pada waktu kita melakukan requirement gathering, harapan kita adalah agar requirement yang kita dapatkan di fase requirement tidak jauh bergeser dari requirement final setelah project closing. Kalau pergeserannya jauh, akan mengakibatkan waktu dan biaya pengerjaan project menjadi molor dan akibatnya kedua belah pihak akan dirugikan.</p>

<p>Pergeseran requirement ini bisa disebabkan beberapa hal, misalnya :</p>

<ol>
<li><p>business analyst (BA) kurang pengalaman, sehingga tidak bisa mengidentifikasi varian-varian skenario. Akibatnya terjadi banyak 'hidden requirement'</p></li>
<li><p>business analyst kurang teliti, sehingga salah memahami penjelasan user</p></li>
<li><p>Perubahan bisnis client, sehingga requirementnya juga berubah</p></li>
<li><p>perbedaan persepsi antara user dan analyst atau programmer</p></li>
</ol>


<p>Untuk masalah 1 dan 2, solusinya adalah dengan mengganti BA dengan orang yang lebih berpengalaman. Newbie sebaiknya tidak menjadi BA. Bolehlah magang BA, tapi jangan diandalkan untuk jadi BA utama.</p>

<p>Poin 3 juga biasanya tidak masalah. Client biasanya cukup tahu diri kalau terjadi hal ini, sehingga tidak keberatan dimintai charge tambahan.</p>

<p>Nah untuk poin 4, biasanya sulit dideteksi sampai aplikasi kita deliver. Sering terjadi, usernya OK OK saja pada fase requirement, dan tiba-tiba pada waktu kita deliver aplikasinya, dia langsung bingung karena aplikasinya 'aneh'.</p>

<p>Agar poin 4 ini tidak terjadi, sebaiknya kita melakukan prototyping. Bagaimana cara melakukan prototyping yang baik?</p>

<p>Prototyping itu idealnya :</p>

<ol>
<li><p>Murah meriah dan cepat
Dalam 1 hari kita harus bisa menggambar minimal 10 screen.
Begitu usernya selesai ngomong/gambar di papan tulis, screennya juga harus langsung jadi.
Jangan sampai effort untuk prototyping lebih besar dari effort untuk coding.</p></li>
<li><p>Gampang diubah
Tujuan prototype adalah supaya user bisa merasakan seperti apa aplikasinya nanti.
Kalau dirasakan kurang sesuai, tentunya dia ingin mengubahnya.
Nah, jangan sampai minta geser tombol aja harus nunggu 30 menit.</p></li>
<li><p>Mirip aslinya.
Kalo ini lebih ke sisi development.
Biar efisien, begitu prototype sign off, kita bisa mulai paralel coding dan bikin user manual.
Kalo prototypenya udah bener2 mirip, bisa langsung discreenshot dan dipasang di user manual.
Jadi begitu aplikasi jadi, user manual juga selesai.</p></li>
<li><p>Terlihat belum selesai
Ini agak kontradiktif dengan tips #3. Kalau prototype kita sangat mirip aplikasi betulan, client akan memiliki persepsi bahwa aplikasinya sudah hampir selesai. Padahal belum ada coding sama sekali. Oleh karena itu, sangat penting kita tekankan ke client bahwa masih ada jangka waktu yang lama sebelum aplikasi betulannya selesai.</p></li>
</ol>


<p>Ada beberapa tools yang bisa digunakan untuk prototyping, yaitu</p>

<h2><a href="http://www.netbeans.org">Netbeans</a></h2>

<p>Untuk project aplikasi desktop, inilah yang biasa kami gunakan di ArtiVisi. Screen dapat dibuat dengan sangat cepat, lengkap dengan behavior standar seperti popup dialog, scroll table, dsb.</p>

<p>Untuk project web, biasanya kita langsung coding di HTML dan Dojo, tentunya tanpa koneksi ke back end.</p>

<p>Sebagai nilai tambah lain, setelah prototype di-approve client, programmer bisa langsung meneruskan coding.</p>

<h2><a href="http://www.balsamiq.com/products/mockups">Balsamiq Mockup</a></h2>

<p>Tools ini berbayar dan dijalankan menggunakan Adobe AIR.</p>

<p><a href="http://pencil.evolus.vn/en-US/Home.aspx">Pencil</a>
Tools ini lumayan bagus, dijalankan sebagai Firefox Add Ons. Sudah ada palette untuk berbagai UI component seperti combo box, text area, dsb. Setelah selesai menggambar, kita bisa langsung mengekspornya menjadi image.</p>

<p>Berikut contoh mockup yang baru saja saya buat menggunakan Pencil.</p>

<p>Ini versi 'bagus' yang mirip aslinya.</p>

<p><img src="/images/uploads/2010/07/windows_login-300x238.png" title="Mockup Login Screen ala Windows XP" ></p>

<p>Supaya client sadar bahwa ini adalah prototype, kita bisa gunakan versi yang coret-coretan.</p>

<p><img src="/images/uploads/2010/07/sketchy_login-300x238.png" title="Mockup Versi Coretan" ></p>

<p>Source file untuk mockup di atas bisa <a href="http://endy.artivisi.com/downloads/contoh/mockup/pencil-demo.ep">diunduh di sini</a>.</p>

<p>Demikianlah sedikit tips dan trik. Semoga bermanfaat.</p>
]]></content>
  </entry>
  
</feed>
