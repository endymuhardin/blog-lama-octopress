<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: manajemen | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/manajemen/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2014-04-15T22:31:14+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Aplikasi Prakarya vs Aplikasi Production]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/"/>
    <updated>2014-04-15T22:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production</id>
    <content type="html"><![CDATA[<p>Salah satu pertanyaan yang sering ditanyakan di forum programmer adalah</p>

<blockquote><p>Saya ingin belajar bahasa pemrograman [isi bahasa yang Anda sukai di sini], bagaimana ya caranya supaya bisa mahir?</p></blockquote>

<p>Dan jawaban saya selalu sama</p>

<blockquote><p>Coba buatlah aplikasi berkualitas production barang 5 - 10 kali, setelah itu insya Allah akan mahir.</p></blockquote>

<p>Jawaban di atas memang singkat, tapi jalan untuk menuju kesana <a href="http://endy.muhardin.com/education/tahapan-belajar/">sungguh tidak mudah dan tidak singkat</a>. Apalagi untuk pemula, setidaknya ada dua pertanyaan besar:</p>

<ol>
<li>Apa sih aplikasi production itu?</li>
<li>Bagaimana cara membuat aplikasi?</li>
</ol>


<p>Pertanyaan pertama akan kita jawab pada artikel ini. Sedangkan pertanyaan kedua akan kita jawab pada artikel selanjutnya.</p>

<!--more-->


<p>Dalam siklus pembuatan aplikasi, biasanya ada beberapa tahapan rilis:</p>

<ol>
<li>Development : ini adalah work in progress yang sedang dikerjakan programmer. Aplikasinya belum selesai sehingga wajar kalau banyak errornya.</li>
<li>Testing : programmer sudah mengetes bagian-bagian yang penting. Tinggal bug pada kasus-kasus dan kondisi <em>'ajaib'</em> yang biasanya cuma bisa ditemukan oleh tester yang handal. Testing biasanya juga ada berbagai tahapan, mulai dari internal tester sampai ke tester dari client/end user.</li>
<li>Production : aplikasi sudah digunakan sehari-hari oleh end user dan berjalan lancar tanpa ada bug yang signifikan (show-stopper).</li>
</ol>


<p>Lebih detail mengenai tahapan rilis bisa dibaca di <a href="http://software.endy.muhardin.com/manajemen/release-management/">artikel terdahulu tentang Release Management</a>.</p>

<p>Tahapan di atas biasanya dijalankan di perusahaan. Di lingkungan akademik (kampus, SMK), saya punya satu kategori lagi yang dinamakan <strong>Aplikasi Prakarya</strong>. Wah apa lagi tuh <strong>Aplikasi Prakarya</strong>??</p>

<blockquote><p>Aplikasi Prakarya adalah aplikasi yang cuma bisa digunakan untuk tugas kuliah ataupun skripsi. Itupun cuma bisa lulus kalau dosennya bermurah hati. Aplikasi prakarya ini tidak akan mungkin digunakan oleh end-user, walaupun daftar fiturnya sama dengan aplikasi production.</p></blockquote>

<p>Masih belum paham? Baiklah kita coba ilustrasikan dengan cerita.</p>

<p>Pada suatu hari, saya menyuruh mahasiswa saya membuat aplikasi. Mereka saat ini sedang semester 4. Seperti umumnya kampus di negeri kita ini, mahasiswa semester 4 belum pernah membuat aplikasi utuh. Jam terbangnya paling hanya beberapa looping/branching atau paling maksimal beberapa function/method untuk belajar algoritma. Saya beri tugas:</p>

<blockquote><p>Coba buat aplikasi user management. Tidak perlu full coding, cukup UI mockup (rancangan screen) saja.</p></blockquote>

<p>Aplikasi user management adalah aplikasi yang paling mendasar. Apapun aplikasi yang ingin kita buat, pasti ada modul ini. Fiturnya pun tidak rumit-rumit. Cukup insert-update-delete-display data user saja. Untuk menyederhanakan masalah, tidak perlulah kita buat group dan permission.</p>

<p>Source file UI mockup yang saya buat di artikel ini bisa diunduh <a href="../../downloads/prakarya-production.ep">di sini</a> dan dibuka menggunakan <a href="http://pencil.evolus.vn/">aplikasi Pencil</a>.</p>

<p>Nah kita lihat evolusi dari aplikasi prakarya menjadi aplikasi production. Kita mulai dengan menampilkan data user.</p>

<h2>Menampilkan Data</h2>

<p>Inilah screen daftar user yang dipresentasikan ke saya</p>

<p><img src="https://lh4.googleusercontent.com/-25Yeh5ay_RY/U01LMUEObTI/AAAAAAAAFpA/p45UmrhH9-4/w888-h408-no/tabelprakarya01.png"></p>

<blockquote><p>Bagaimana menurut Anda? Apakah Anda melihat ada masalah pada screen di atas? Apa masalahnya?</p></blockquote>

<p>Masalahnya ada di jumlah data. Aplikasi prakarya biasanya dites menggunakan 1 - 5 baris data saja. Tentu saja tidak ada masalah yang terlihat kalau datanya cuma 1 - 5 baris. Nah, bagaimana kalau tidak ada data? Biasanya begini jadinya.</p>

<p><img src="https://lh3.googleusercontent.com/-mvMdRuXasxU/U01LNOysKkI/AAAAAAAAFpQ/wkv2gyBpzCs/w882-h363-no/tabelprakarya03.png"></p>

<p>Ini menunjukkan programmer malas. Padahal dengan menambah beberapa baris <code>if-else</code>, tampilan di atas bisa terkesan lebih <em>'serius'</em> seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-g1HzK09B3W0/U01LOCrimhI/AAAAAAAAFpg/yXw_NJX3OIQ/w654-h306-no/tabelproduction02.png"></p>

<p>Ok, kita sudah handle kasus tidak ada data. Nah sekarang, pada waktu dipakai di kondisi riil, berapa datanya? Misalnya kita membuat aplikasi perpustakaan untuk kampus. Berapa jumlah anggotanya? Apakah 1-5 saja? Tentu tidak mungkin. Kisaran datanya antara ratusan sampai puluhan ribu tergantung ukuran kampus. Belum lagi kalau perpustakaannya menerima anggota masyarakat umum.</p>

<p>Dengan data ratusan/ribuan, screen di atas akan mengalami masalah:</p>

<ul>
<li>data tentu ditarik dengan query <code>select * from tabel_user</code>. Kalau satu user datanya 1KB, maka untuk 10 ribu user 10MB harus dikirim dari database server ke webserver, dan kemudian dari webserver ke browser.</li>
<li>asumsikan koneksi internet user 1 MB/s, maka dia harus menunggu 10 detik sampai daftar user bisa dia lihat. Pakai GPRS? Nah, silahkan kembali lagi besok sore ;)</li>
<li>bila ada 10 concurrent user (user yang mengakses aplikasi secara bersamaan), maka kita harus siapkan bandwidth 100 MB/s di sisi server hanya untuk menampilkan daftar user.</li>
</ul>


<blockquote><p>Lalu bagaimana solusinya?</p></blockquote>

<p>Solusi pertama, paging. Kita bagi data menjadi beberapa halaman. Toh user juga tidak mungkin melihat 10 ribu data sekaligus. Bisa-bisa stres dia kayak caleg kalah pemilu.</p>

<p><img src="https://lh6.googleusercontent.com/-CgyzCMA-Foc/U01LMwcZhfI/AAAAAAAAFpM/8PCtzho72xA/w852-h462-no/tabelprakarya02.png"></p>

<blockquote><p>Selesai?</p></blockquote>

<p>Belum. Untuk 10 ribu data, bila satu halaman isinya 20, maka ada 500 halaman. Mana ada orang mau klik satu persatu halamannya. Jadi bagaimana? Ya tentu harus bisa dicari.</p>

<p><img src="https://lh3.googleusercontent.com/-OGKJDR3nnSk/U01LN9OAzmI/AAAAAAAAFpc/Z5mYYDj-O9s/w888-h465-no/tabelproduction01.png"></p>

<p>Nah, dari sini kita sudah bisa membedakan antara aplikasi prakarya dan aplikasi production. Aplikasi prakarya tidak dites secara menyeluruh. Dengan 1-5 data saja sudah puas, cukuplah untuk dapat A kalau dosennya murah hati. Tapi aplikasi production tidak bisa seperti itu kalau aplikasinya mau dipakai orang. Kita harus tes dengan 0 data dan 10 ribu data.</p>

<p>Selanjutnya, mari kita lihat form input data.</p>

<h2>Entri Data</h2>

<p>Inilah screen iterasi pertama</p>

<p><img src="https://lh4.googleusercontent.com/-gwFv3Yp1hMY/U01LKyx9OcI/AAAAAAAAFoo/pjiHEIjgRYc/w687-h510-no/formprakarya01.png"></p>

<blockquote><p>Apa masalahnya?</p></blockquote>

<p>Untuk input data, ada dua hal yang wajib dilakukan dengan benar:</p>

<ul>
<li>validasi</li>
<li>menampilkan pesan kesalahan</li>
</ul>


<p>Mari kita perbaiki. Ini hasil revisinya</p>

<p><img src="https://lh5.googleusercontent.com/-ptivii5-b3I/U01LLWa7lZI/AAAAAAAAFo0/PMTqrd83k9c/w917-h487-no/formprakarya02.png"></p>

<p>Sudah ada pesan error pada screen di atas. Tapi kalau berhenti sampai di sini, usernya bisa marah-marah, soalnya nilai yang sudah dia isikan hilang semua. Harusnya tetap ditampilkan, sehingga dia cukup edit yang salah saja. Tidak perlu entri ulang semuanya. Revisi lagi menjadi seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-pzWfTxTPSaY/U01LLyVPxcI/AAAAAAAAFo4/Qo19dzxO8uM/w900-h459-no/formproduction.png"></p>

<p>Nah, jauh lebih baik.</p>

<p>Selain masalah di atas, ada beberapa hal lagi yang perlu kita perhatikan, yaitu:</p>

<ul>
<li>validasi server-side vs client-side</li>
<li>pemilihan jenis komponen</li>
</ul>


<blockquote><p>Mana validasi yang harus kita buat? Apakah di sisi server atau di sisi client?</p></blockquote>

<p>Validasi yang wajib adalah di sisi server. Kita harus cek semua data yang dikirim client. Kita juga tidak boleh hanya mengandalkan validasi di sisi client, karena berada di luar kendali kita. Bisa saja JavaScript dimatikan, form input di-bypass <a href="http://software.endy.muhardin.com/java/mendebug-aplikasi-ajax/">menggunakan aplikasi debugger</a>, dan berbagai teknik lainnya. Baik secara sengaja, ataupun karena keterbatasan perangkat di sisi client (misalnya browsernya versi jadul).</p>

<blockquote><p>Kalau begitu, buat apa kita buat lagi validasi di sisi client? Buang-buang energi saja.</p></blockquote>

<p>Validasi di sisi client tujuannya supaya user lebih nyaman. Akan lebih enak kalau setelah kursor pindah, data yang barusan diinput langsung ketahuan benar/salahnya. Daripada isi seluruh form, submit, dan ternyata ada error. Sama seperti tampilan tabel tanpa data di atas. Aplikasi yang hal-hal detailnya diurus dengan baik akan terkesan lebih profesional.</p>

<p>Pemilihan jenis komponen akan kita bahas pada artikel selanjutnya.</p>

<h2>Pesan Error</h2>

<p>Kita semua tentu kenal Rambo. Dia bisa survive dimanapun dia diterjunkan dan seburuk apapun perlakuan orang kepadanya.</p>

<p><img src="https://lh3.googleusercontent.com/-kWEJAXJQqiY/U01NMQkQ7_I/AAAAAAAAFp0/099uScfrhP0/w768-h576-no/rambo-wallpaper-800x600.jpg"></p>

<p><em>Fotonya Rambo diambil <a href="http://wallpaperswide.com/rambo-wallpapers.html">dari sini</a></em></p>

<p>Aplikasi production juga demikian. Apapun yang diinput user, dia bisa handle dengan baik. Harddisk penuh? Bandwidth lemot? RAM overload? Semua bisa ditangani dengan baik.</p>

<blockquote><p>Bagaimana caranya? Apakah aplikasi tidak boleh error?</p></blockquote>

<p>Tentu tidak. Mana ada yang sempurna di dunia ini. Kita mengatasi kondisi buruk dengan error handling yang baik. Kalau ada sesuatu yang tidak sesuai kondisi yang dibutuhkan aplikasi, kita tampilkan pesan error yang informatif.</p>

<p>Mari kita lihat error handling aplikasi prakarya, ketika usernya mengetikkan alamat yang tidak ada di aplikasi.</p>

<p><img src="https://lh6.googleusercontent.com/-aZa_dcU50c4/U001E2SUhMI/AAAAAAAAFm4/x502FobAP3s/w614-h238-no/404-prakarya.png"></p>

<p>Nah, jelek sekali bukan? Sangat menunjukkan kemalasan programmernya. Padahal dengan beberapa baris tambahan (di Java cuma 4 baris saja), kita bisa buat yang lebih baik seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-o_w5mMRrh1Q/U001mWLAvAI/AAAAAAAAFnI/lS3c42pYdWc/w616-h465-no/404-production.png"></p>

<p>Waktu yang dibutuhkan tidak lama. Maksimal 5 menit saja. Itupun lama karena kita bimbang apakah mau pakai gambar kucing atau Peter Parker.</p>

<p>Nah kalau pesan error di atas hanya sebatas faktor estetika, pesan error berikut konsekuensinya lebih fatal</p>

<p><img src="https://lh3.googleusercontent.com/-YbMALc355TM/U001Gd2IjAI/AAAAAAAAFnA/6tanv9Q5u8I/w621-h350-no/500-prakarya.png"></p>

<blockquote><p>Kenapa fatal?</p></blockquote>

<p>Karena dari pesan error di atas, pemirsa bisa mengetahui:</p>

<ul>
<li>cara menimbulkan error di atas. Tentu dia ingat langkah-langkah yang dia lakukan sehingga terjadi error seperti di atas.</li>
<li>bahasa pemrograman yang digunakan, yaitu Java. Dilihat dari model stacktracenya.</li>
<li>merek dan versi application server yang digunakan, yaitu Tomcat 6.0.29.</li>
<li>lokasi akurat dari kode program yang error, yaitu class <code>ErrorServlet</code> yang berada dalam package <code>com.muhardin.endy.servlet</code> di baris <code>12</code>.</li>
<li>penyebab error, yaitu <code>IllegalStateException</code>.</li>
<li>estimasi cara kerja program pada waktu error</li>
</ul>


<p>Informasi di atas cukup sebagai titik awal cracker yang akan menjebol aplikasi kita. Dengan informasi tersebut, dia tinggal google:</p>

<ul>
<li>bug yang ada di Tomcat versi 6.0.29.</li>
<li>cara mengeksploitasi bug tersebut</li>
</ul>


<p>Nah, cukup mengerikan bukan? Padahal cukup dengan tambahan 4 baris, kita bisa ganti pesan errornya seperti ini</p>

<p><img src="https://lh4.googleusercontent.com/-JoVmx6mjuNg/U00184vMCTI/AAAAAAAAFnk/PpyXQXOqAyU/w619-h372-no/500-production.png"></p>

<p>Screen di atas akan sangat mengurangi informasi yang bisa disalahgunakan orang yang berniat jahat. Lagipula pesan error <code>IllegalStateException</code> tidak ada gunanya buat user. Error 500 artinya tidak ada perbaikan yang bisa dilakukan end-user. Beda dengan error validasi input dimana user bisa memperbaiki isiannya dan kemudian mencoba submit lagi.</p>

<h2>Pesan Moral</h2>

<p>Perbedaan antara aplikasi prakarya dan production sudah dibahas dalam <a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">buku legendaris <code>The Mythical Man Month</code> karya Fred Brooks</a>. Berikut saya kutipkan satu paragraf dari bab pertama</p>

<blockquote><p>Moving down across the horizontal boundary, a program
becomes a programming product. This is a program that can be run,
tested, repaired, and extended by anybody. It is usable in many
operating environments, for many sets of data.
To become a generally usable programming product,
a program must be written in a
generalized fashion. In particular the range and form of inputs
must be generalized as much as the basic algorithm will reasonably
allow. Then the program must be thoroughly tested, so that it can
be depended upon. This means that a substantial bank of test
cases, exploring the input range and probing its boundaries, must
be prepared, run, and recorded. Finally, promotion of a program
to a programming product requires its thorough documentation, so
that anyone may use it, fix it, and extend it. As a rule of thumb,
I estimate that a programming product costs at least three times as
much as a debugged program with the same function.</p></blockquote>

<p>Dari paparan Eyang Fred di atas, kita bisa mendapatkan beberapa poin penting:</p>

<ul>
<li>membuat aplikasi production biayanya 3x lipat dibandingkan membuat aplikasi prakarya</li>
<li>aplikasi production dapat dipakai di berbagai kondisi (operating environment)</li>
<li>aplikasi production dapat menangani data dalam jumlah besar (many sets of data)</li>
<li>aplikasi production dites secara menyeluruh (thoroughly tested)</li>
<li>tidak hanya urusan coding saja, untuk naik kelas ke kasta production aplikasi juga harus dilengkapi dokumentasi yang lengkap</li>
</ul>


<p>Jadi, untuk set fitur yang sama:</p>

<ul>
<li>tambah user</li>
<li>edit user</li>
<li>hapus user</li>
<li>tampilkan data user</li>
</ul>


<p>terdapat perbedaan kualitas yang signifikan antara level prakarya dan level production. Kalau aplikasi prakarya dibuat dalam waktu 1 bulan, maka untuk membuatnya berkualitas production butuh tambahan 2 bulan lagi.</p>

<p>Tapi untungnya, untuk naik kelas dari prakarya menjadi production syaratnya tidak sulit, sederhana saja yaitu:</p>

<blockquote><p>Jangan malas</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Training CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/training-cmmi/"/>
    <updated>2013-05-10T14:13:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/training-cmmi</id>
    <content type="html"><![CDATA[<p>Saya akan mengisi <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">training CMMI di Brainmatics</a> minggu depan, Senin - Rabu, 13 - 15 Mei 2013. Buat yang belum paham apa itu CMMI, bisa baca <a href="http://software.endy.muhardin.com/manajemen/apa-itu-cmmi/">artikel saya mengenai masalah ini</a>.</p>

<p>Sebenarnya, materi tentang CMMI banyak bertebaran secara gratis di internet. Bahkan spesifikasi resminya gratis bisa diunduh di <a href="http://cmmiinstitute.com/">websitenya Carnegie Mellon University</a>. Lalu buat apa ikut training lagi kalau di internet sudah banyak materinya?</p>

<!--more-->


<p>Berikut beberapa alasannya:</p>

<ul>
<li>Materi CMMI yang ada di website sangat abstrak dan penjelasannya bersifat umum.</li>
<li>Agar bisa diimplementasikan di perusahaan, aturan CMMI ini harus dibuatkan dulu padanan/mapping dengan proses bisnis di internal perusahaan.</li>
<li>Proses bisnis di internal perusahaan belum tentu selengkap yang diminta CMMI, sehingga harus didesain dan dibuat dulu.</li>
<li>Seringkali terjadi, cara mendesain proses bisnis yang baik juga belum dikuasai. Ini akan kita bahas pada sesi training.</li>
<li>Setelah dibuat, proses bisnis harus diimplementasikan ke seluruh perusahaan. Implementasi proses bisnis ada metodologinya sendiri.</li>
<li>Di website CMMI, dijelaskan proses appraisal, yaitu proses untuk menilai perusahaan apakah sudah sesuai dengan aturan CMMI. Penjelasan di kertas tentu jauh berbeda dengan pengalaman nyata yang saya alami pada waktu implementasi CMMI.</li>
<li>Ada banyak <a href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/">mitos dan urban legend tentang CMMI</a>, terutama yang berkaitan dengan metodologi agile seperti Scrum, Kanban, XP, dan lainnya. Pada sesi training, kita akan bahas mana yang mitos mana yang nyata.</li>
</ul>


<p>Silabus lengkap bisa dilihat di <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">website Brainmatics</a>. Tapi banyak jargon teknis di sana yang baru bisa kita pahami kalau sudah mengerti CMMI. Untuk yang masih awam, berikut adalah hal yang akan kita pelajari/lakukan selama training:</p>

<ol>
<li><p>Apa itu CMMI</p>

<ul>
<li>sejarah</li>
<li>use case</li>
<li>manfaat buat kita</li>
</ul>
</li>
<li><p>Isi perut CMMI</p>

<ul>
<li>apa itu process area</li>
<li>apa itu goals</li>
<li>apa itu practices</li>
<li>apa yang dimaksud generic goals/practices</li>
<li>apa yang dimaksud specific goals/practices</li>
<li>apa itu maturity level</li>
<li>apa yang dimaksud staged representation dan continuous representation</li>
<li>bagaimana proses appraisal</li>
</ul>
</li>
<li><p>Metodologi implementasi</p>

<ul>
<li>menentukan target maturity level yang realistis untuk dicapai perusahaan kita</li>
<li>melakukan gap analysis, antara kondisi perusahaan kita sekarang dan kondisi yang diminta CMMI</li>
<li>membuat mapping antara kebutuhan CMMI dan proses bisnis di perusahaan kita</li>
<li>cara mendesain proses bisnis perusahaan yang efektif dan komprehensif</li>
<li>cara implementasi proses bisnis yang sudah dibuat</li>
<li>tips dan trik dalam proses appraisal</li>
</ul>
</li>
</ol>


<p>Trainingnya akan berbentuk workshop. Saya akan menjelaskan teori secara singkat, lalu kita lanjutkan dengan praktek dan diskusi. Target training ini adalah, peserta pulang dengan membawa :</p>

<ul>
<li>strategi implementasi</li>
<li>daftar proses bisnis yang harus dibuat/direvisi</li>
<li>contoh dokumen dan template</li>
<li>action plan yang harus mereka lakukan di perusahaannya untuk berhasil mencapai target maturity level yang diinginkan.</li>
</ul>


<p>Jadi, tunggu apa lagi, ayo segera daftar. Sampai ketemu di sesi training :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release Management]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/release-management/"/>
    <updated>2012-08-29T18:01:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/release-management</id>
    <content type="html"><![CDATA[<p>Release, atau di-Indonesia-kan menjadi rilis, adalah tahap yang paling penting dalam software development. Segala kegiatan hulu (upstream activity) lainnya seperti <a href="/manajemen/fase-requirement/" title="Fase Requirement">requirement</a>, desain aplikasi, coding, testing, dan lainnya, semua dilakukan demi untuk menghasilkan software yang bisa dirilis. Sebagus apapun kita melakukan kegiatan lainnya, jika rilisnya tidak bagus, maka semua yang kita kerjakan menjadi tidak bagus. Sebaliknya, berbagai kesalahan dan kekurangan di kegiatan lain akan mudah dimaafkan dan dilupakan kalau kita menghasilkan rilis yang baik. Walaupun demikian, perlu diingat bahwa bila kita melakukan kegiatan hulu dengan baik, biasanya kita bisa menghasilkan rilis yang berkualitas baik secara konsisten.</p>

<p>Pada artikel ini, kita akan membahas pernak-pernik yang berkaitan dengan rilis. Apa itu rilis, berbagai jenis rilis, syarat dan ketentuan rilis, dan juga prosedur yang kita gunakan di ArtiVisi.</p>

<!--more-->


<h1>Apa itu rilis</h1>

<p>Rilis pada intinya adalah menyerahkan software yang sudah kita kerjakan ke pihak lain. Berdasarkan siapa yang dimaksud dengan pihak lain, kita membedakan rilis menjadi :</p>

<ul>
<li>rilis internal : menyerahkan software ke pihak internal tim pengembang, misalnya dari programmer ke tester.</li>
<li>rilis eksternal : menyerahkan ke pihak luar seperti client atau customer.</li>
</ul>


<p>Kita tidak harus menunggu sampai software selesai dikerjakan 100% untuk melakukan rilis. Berdasarkan tingkat penyelesaian pekerjaan, kita bisa membedakan rilis menjadi :</p>

<ul>
<li><p>development release : Ini adalah rilis yang dilakukan sebelum software selesai dikerjakan. Rilis ini dibuat untuk menunjukkan kemajuan dalam proses development, misalnya menunjukkan tambahan fitur baru ataupun sekedar menunjukkan perbedaan dengan rilis sebelumnya. Development release biasa dilakukan secara rutin dan periodik. Ada yang melakukannya secara mingguan, harian, bahkan dua kali sehari. Rilis jenis ini juga biasa disebut dengan unstable release (karena softwarenya belum stabil - sering hang atau error), milestone release, daily/nightly build release, atau alpha release.</p></li>
<li><p>testing release : Ini adalah rilis yang dilakukan setelah aplikasi siap untuk dites. Pada titik ini biasanya sudah tidak ada penambahan fitur lagi. Software yang dibuat diserahkan ke tester untuk dicari bugnya. Hasil laporan bug itu kemudian akan ditindak lanjuti sehingga menghasilkan testing release berikutnya. Kalau kita pernah mendengar istilah beta release, biasanya itu maksudnya adalah testing release. Orang sering membagi lagi testing release menjadi beta release dan release candidate. Pada prinsipnya, beta dan release candidate sama saja, bedanya ada di cakupan tester. Beta release khusus untuk dites oleh tester, sedangkan release candidate bisa juga dites oleh end-user.</p></li>
<li><p>final release : Rilis jenis ini menyatakan bahwa software sudah selesai dikerjakan, dites, dan laporan bugnya sudah ditindak lanjuti. Biasa disebut juga stable release, karena software yang dihasilkan bisa digunakan dengan lancar dan nyaman (stabil).</p></li>
</ul>


<h1>Manfaat Rilis</h1>

<p>Manfaat rilis tentunya adalah supaya software yang sudah susah payah kita buat, bisa bermanfaat bagi penggunanya dan sukur-sukur bisa menghasilkan uang bagi pembuatnya. Karena di atas kita sudah membahas berbagai jenis rilis, tentu juga ada macam-macam manfaat dari berbagai jenis rilis tersebut.</p>

<p>Development release sebaiknya dilakukan sesering mungkin. Agar tidak merepotkan, dilakukan menggunakan perangkat otomasi seperti <a href="http://jenkins-ci.org/" title="Jenkins Continuous Integration">Jenkins</a>. Manfaat dari development release adalah untuk memastikan integrasi antara fitur berjalan dengan baik. Sering kali pada saat membuat fitur X, secara tidak sengaja mempengaruhi fitur Y sehingga tidak berjalan dengan baik. Hal inilah yang coba dicegah dengan development release.</p>

<p>Testing release manfaatnya adalah supaya software yang kita buat bisa diperiksa oleh orang lain dengan perspektif yang berbeda dan lebih fresh. Programmer yang membuat aplikasi pastinya sudah hafal perilaku aplikasi yang dibuatnya, sehingga bisa menghindari error yang mungkin terjadi. Tapi tester atau user tidak memiliki pengetahuan tentang cara kerja internal aplikasi, sehingga lebih mungkin menemukan skenario yang belum diantisipasi oleh software.</p>

<p>Final release tentunya berguna supaya software kita bisa digunakan oleh masyarakat umum. Para pengguna (end user) biasanya menunggu sampai suatu software dinyatakan selesai, baru dia mau menggunakannya. Demikian juga bila aplikasi yang kita buat akan dibundel oleh orang lain (contohnya distro Linux, integrasi dengan aplikasi lain, dsb), tentu mereka akan menunggu keluarnya rilis final.</p>

<h1>Aturan Rilis</h1>

<p>Seperti kita bahas sebelumnya, tujuan rilis adalah supaya software kita bisa digunakan oleh orang lain. Oleh karena itu, kita harus memudahkan pengguna dalam memahami rilis yang kita keluarkan.</p>

<p>Hal paling penting dalam melakukan rilis adalah aturan penamaan. Dengan aturan penamaan yang baik, kita bisa:</p>

<ul>
<li>menjelaskan status rilis, apakah ini development release, testing, atau final.</li>
<li>menjelaskan kompatibilitas dengan versi sebelumnya dan aplikasi lain. Ini akan dijelaskan secara lebih detail sebentar lagi.</li>
<li>menjelaskan hubungan dengan rilis lainnya. Bila kita memiliki dua rilis, kita bisa membedakan mana rilis yang duluan dan mana yang belakangan.</li>
</ul>


<h1>Studi Kasus</h1>

<p>Untuk memudahkan pemahaman tentang penamaan rilis, mari kita karang studi kasusnya, yaitu Facebook Contact Backup.</p>

<blockquote><p>Aplikasi Facebook Contact Backup (FCB) adalah aplikasi yang bisa mendownload daftar contact kita di facebook, kemudian menuliskannya ke dalam text file. Contoh textfile akan dilampirkan di bawah. Untuk versi pertama, informasi kontak yang ditampilkan adalah : nama, email, no HP.</p></blockquote>

<p>Berikut contoh file yang dihasilkan oleh aplikasi FCB</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;081298000468&lt;/mobile&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<blockquote><p>Karena aplikasi FCB kemudian menjadi populer, ada orang lain yang membuat aplikasi untuk mengisi phonebook di handphone bernama Handphone Contact Importer (HCI). Aplikasi HCI ini menggunakan aplikasi FCB untuk connect ke facebook dan mengambil data contact. Setelah datanya ada dalam format textfile, aplikasi HCI akan membaca text file tersebut dan kemudian mengisinya ke phonebook handphone.</p></blockquote>

<p>Aplikasi FCB dikembangkan dengan cepat sehingga menghasilkan beberapa rilis sebagai berikut:</p>

<h2>Rilis Pertama</h2>

<p>Memperbaiki format nomer handphone, sehingga semua diseragamkan menjadi format internasional. Nomer <code>081298000468</code> pada contoh di atas akan dikonversi menjadi <code>+6281298000468</code></p>

<h2>Rilis Kedua</h2>

<p>Fix protokol komunikasi ke Facebook, karena ada perubahan di Facebook API.</p>

<h2>Rilis Ketiga</h2>

<p>Menambahkan field ulang tahun sehingga format text file menjadi sebagai berikut :</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281298000468&lt;/mobile&gt;
    &lt;birthdate&gt;1945-08-17&lt;/birthdate&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
    &lt;birthdate&gt;2011-11-11&lt;/birthdate&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<h2>Rilis Keempat</h2>

<p>Ganti format xml menjadi json, mengikuti trend masa kini.
``` js facebook_contact.json
[</p>

<pre><code>{
    name: "Endy Muhardin",
    email: "endy@geemail.com",
    mobile: "+6281298000468",
    birthdate: "1945-08-17"
},
{
    name: "Ifnu Bima",
    email: "ifnu@geemail.com",
    mobile: "+6281234567890",
    birthdate: "2011-11-11"
}
</code></pre>

<p>]
```</p>

<p>Dengan studi kasus di atas, kita harus mempertimbangkan penomoran rilis untuk aplikasi FCB dengan benar, supaya aplikasi HCI bisa tahu apa yang harus dilakukan pada saat aplikasi FCB mengeluarkan rilis baru.</p>

<h1>Kompatibilitas</h1>

<p>Dalam mengeluarkan rilis untuk aplikasi FCB, kita harus mempertimbangkan aplikasi HCI agar tidak rusak. Pengaruh aplikasi FCB terhadap HCI dikenal dengan istilah kompatibilitas. Kompatibilitas dibedakan berdasarkan ketergantungan secara programmatic:</p>

<ul>
<li>binary compatibility : FCB terbaru disebut binary-compatible dengan HCI bila FCB yang sudah dicompile bisa langsung ditaruh di folder dan dipakai oleh HCI.</li>
<li>source compatibility : FCB terbaru disebut source-compatible dengan HCI bila FCB yang sudah dicompile tidak bisa langsung ditaruh begitu saja. HCI harus dicompile ulang dulu dengan FCB terbaru, baru HCI bisa dijalankan.</li>
</ul>


<p>Lebih lanjut tentang binary vs source compatibility bisa dibaca <a href="http://blogs.msdn.com/b/jmstall/archive/2008/03/10/binary-vs-source-compatibility.aspx">di artikel ini</a>.</p>

<p>Dan juga bisa dibedakan berdasarkan hubungannya dengan rilis terdahulu.</p>

<ul>
<li>backward compatibility : bila HCI versi terbaru bisa menggunakan format data FCB yang terdahulu. Misalnya, aplikasi HCI terbaru bisa membaca data versi baru (json), versi sebelumnya (xml), dan sebelumnya lagi (xml tanpa field birthdate)</li>
<li>forward compatibility : bila HCI versi jadul bisa membaca format data FCB yang lama (xml tanpa birthdate) dan yang lebih baru yang dirilis setelah HCI jadul tersebut (xml dengan birhtdate).</li>
</ul>


<p>Setelah kita memahami urusan kompatibilitas, kita bisa menentukan skema penamaan rilis, atau dikenal dengan istilah version numbering.</p>

<h1>Version Numbering</h1>

<p>Kita akan menggunakan <a href="http://apr.apache.org/versioning.html" title="Version Numbering APR">aturan dari Apache Portable Runtime</a> yang sudah diakui sebagai best-practices dalam version numbering. Aturan APR mengharuskan ada tiga komponen version number, yaitu :</p>

<ul>
<li>major number</li>
<li>minor number</li>
<li>patch number</li>
</ul>


<p>Contohnya, waktu pertama kita merilis FCB, kita beri nama <code>FCB-1.0.0</code>. Major numbernya 1, minor numbernya 0, patch numbernya 0.</p>

<p>Untuk rilis selanjutnya, kita menaikkan major/minor/patch number sesuai dengan pengaruhnya terhadap kompatibilitas. Aturannya sebagai berikut:</p>

<ul>
<li>major number dinaikkan bila FCB baru tidak kompatibel dengan FCB rilis sebelumnya. Bila HCI dipasang dengan FCB terbaru ini, HCI akan error.</li>
<li>minor number dinaikkan bila FCB baru mengandung penambahan fitur, tapi tetap kompatibel dengan HCI yang dibuat berdasarkan FCB lama. HCI versi lama tetap bisa jalan, walaupun tidak bisa memanfaatkan fitur yang baru.</li>
<li>patch dinaikkan bila tidak ada perubahan secara fitur, tapi cuma ada perbaikan di internal FCB yang tidak terlihat dari luar (misalnya optimasi koneksi jaringan, perubahan protokol ke arah Facebook, dsb)</li>
</ul>


<p>Selanjutnya, mari kita beri nomer sesuai studi kasus kita di atas.</p>

<ol>
<li>Rilis Pertama : diberi nama <code>1.1.0</code>, karena cuma terjadi perubahan di content saja. HCI yang dibuat dengan FCB versi <code>1.0.0</code> akan tetap berjalan lancar</li>
<li>Rilis Kedua : diberi nama <code>1.1.1</code>, karena perubahan protokol komunikasi dengan Facebook tidak mempengaruhi HCI sama sekali. HCI versi lama tetap bisa jalan dengan lancar.</li>
<li>Rilis Ketiga : diberi nama <code>1.2.0</code>, sama dengan rilis pertama. Ada penambahan fitur, tapi tidak membuat HCI jadi error. Dengan rilis ini, programmer HCI bisa menambahkan fitur baru misalnya reminder ulang tahun. Tapi HCI versi lama (tanpa reminder ulang tahun) tetap bisa digunakan dengan <code>FCB-1.2.0</code></li>
<li>Rilis Keempat : diberi nama <code>2.0.0</code>. Ini adalah perubahan signifikan. Untuk dapat menggunakan <code>FCB-2.0.0</code> ini, HCI harus mengalami perubahan signifikan. HCI versi lama tidak bisa digunakan dengan <code>FCB-2.0.0</code>. Agar dapat digunakan, programmer HCI harus mengeluarkan rilis baru yang bisa mengakomodasi format data JSON.</li>
</ol>


<p>Berikutnya, mari kita lihat pengaruhnya untuk HCI.</p>

<ol>
<li><code>HCI-1.0.0</code> : versi pertama, dibuat dengan <code>FCB-1.0.0</code></li>
<li>Rilis <code>FCB-1.1.0</code> : tidak ada tambahan fitur yang bisa dibuat di HCI, sehingga programmernya tidak coding.</li>
<li>Rilis <code>FCB-1.1.1</code> : tidak ada perubahan yang terlihat. Programmer HCI makan gaji buta sambil update status Facebook. Nganggurnya programmer HCI ini berarti <code>HCI-1.0.0</code> forward-compatible dengan <code>FCB-1.0.0</code>, <code>FCB-1.1.0</code>, hingga <code>FCB-1.1.1</code>.</li>
<li>Rilis <code>FCB-1.2.0</code> : ada field baru (birthdate) yang bisa dimanfaatkan, programmer HCI mulai coding.</li>
<li><code>HCI-1.1.0</code> : tambahan fitur reminder ulang tahun. <code>HCI-1.1.0</code> ini backward-compatible dengan <code>FCB-1.1.1</code>, <code>FCB-1.1.0</code>, maupun <code>FCB-1.0.0</code>.</li>
<li>Rilis <code>FCB-2.0.0</code> : HCI semua versi tidak dapat digunakan bila user meng-upgrade FCB-nya. Programmer HCI harus segera mengeluarkan rilis baru, tidak boleh coding sambil facebookan.</li>
<li><code>HCI-1.1.1</code> : bagi end-user, HCI terbaru ini tidak ada tambahan fiturnya. Tapi dia fixing bug, yang tadinya error pada waktu dijalankan (karena FCB-nya tidak kompatibel), menjadi tidak error.</li>
</ol>


<p>Selain major.minor.patch, ada kalanya orang juga menambahkan satu informasi lagi yang menyatakan kestabilan rilis. Berikut beberapa contohnya:</p>

<ul>
<li><code>FCB-1.0.1-SNAPSHOT</code> : ini biasanya digunakan untuk mencerminkan rilis daily build terbaru</li>
<li><code>FCB-1.0.0-20121212080808</code> : ini biasanya digunakan untuk menunjukkan hasil daily build tertentu</li>
<li><code>FCB-1.0.1-RC-01</code> : release candidate pertama</li>
<li><code>FCB-1.0.0-M2</code> : milestone kedua</li>
<li><code>FCB-1.0.0-Final</code> : final release. Ada orang yang menambahkan keyword Final, ada juga yang tidak.</li>
<li><code>FCB-1.0.0-GA</code> : generally available, sama dengan final release</li>
<li><code>FCB-1.0.0-RELEASE</code> : sama dengan GA dan Final</li>
</ul>


<p>Penomoran versi ini terlihat sepele saja. Tapi kalau kita tidak punya aturan penamaan yang jelas, maka orang lain akan bingung setiap kali ada rilis baru. Mereka tidak bisa menentukan apakah harus upgrade atau tidak, karena mereka tidak bisa tahu bagaimana kompatibilitas rilis ini dengan aplikasi lainnya. Salah satu contoh populer kekacauan yang disebabkan penomoran versi yang sembarangan <a href="http://news.ycombinator.com/item?id=1734936">bisa dilihat di komunitas Ruby</a>. Akibat aturan rilis Ruby tidak jelas, sehingga dibutuhkan aplikasi lain seperti RVM atau rbenv supaya antar versi Ruby tidak saling bentrok. Effort yang dikeluarkan untuk membuat dan memantain RVM dan rbenv tentu tidak sedikit. Ini semua disebabkan <em>hanya karena</em> penomoran versi belaka. Hasil akhir dari semua ini, sampai saat artikel ini ditulis, <a href="http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/">Ruby belum bisa dipaket dengan benar di distro Debian</a> dan turunannya (termasuk Ubuntu).</p>

<h1>Release Notes</h1>

<p>Tentunya penomoran versi saja tidak bisa memuat informasi yang detail. Kita membutuhkan sarana lain untuk memberikan informasi yang detail tentang isi dari suatu rilis. Untuk keperluan ini, biasanya orang membuat dokumen yang disebut Release Notes. Beberapa hal yang biasanya dicantumkan dalam release notes antara lain:</p>

<ul>
<li>fitur baru</li>
<li>bug yang diperbaiki</li>
<li>enhancement/improvement, yaitu perbaikan pada fitur yang ada</li>
<li>known issues, yaitu bug atau error yang sudah teridentifikasi tapi belum difix. Informasi ini menunjukkan bahwa programmernya sudah tahu bahwa ada bug, tapi karena satu dan lain hal belum memperbaikinya</li>
<li>kontributor, yaitu siapa saja yang berkontribusi di rilis ini.</li>
<li>to do, yaitu fitur apa yang direncanakan akan dibuat pada rilis berikut. Informasi ini bisa juga ditulis di dokumen terpisah bernama roadmap</li>
</ul>


<p>Contoh release notes bisa dilihat <a href="/images/uploads/2012/08/RELEASE.txt" title="Contoh Release Notes">di sini</a>.</p>

<h1>Tools</h1>

<p>Ada beberapa hal yang perlu dilakukan pada waktu kita akan melakukan rilis, yaitu:</p>

<ul>
<li>menaikkan nomor versi di source code. Biasanya kita ada mencantumkan nomor versi di aplikasi, misalnya di halaman About.</li>
<li>membuat rekap perubahan yang terjadi sejak rilis sebelumnya</li>
<li>membuat tag di version control database</li>
</ul>


<p>Semua kegiatan di atas dapat dioptimasi dengan tools misalnya <a href="http://maven.apache.org/plugins/maven-release-plugin/" title="Maven Release Plugin">maven-release-plugin</a>. Cara pakainya bisa dilihat <a href="http://java.dzone.com/articles/automating-releases-maven-0">di sini</a>. Tapi beberapa orang melihat bahwa maven-release-plugin ini tidak memenuhi kebutuhannya, sehingga dia pakai <a href="http://www.axelfontaine.com/2011/01/maven-releases-on-steroids-adios.html">cara yang lain</a>.</p>

<p>Di ArtiVisi, kita sudah mencoba maven-release-plugin, dan berpendapat bahwa dia <a href="http://www.sonatype.com/people/2011/01/using-the-maven-release-plugin-things-to-know/">terlalu kaku</a> sehingga sulit dikonfigurasi agar sesuai dengan kebutuhan kita. Akhirnya kita menggunakan cara manual dengan prosedur sebagai berikut:</p>

<h2>Prosedur Rilis ArtiVisi</h2>

<p>Contoh skenario :</p>

<ul>
<li>Rilis sebelumnya : <code>1.2.0</code></li>
<li>Rilis sekarang : <code>1.2.1</code></li>
</ul>


<p>Langkah-langkah melakukan rilis :</p>

<ol>
<li><p>Generate Changelog dengan perintah <code>git shortlog 1.2.0..HEAD</code></p></li>
<li><p>Copy paste output dari langkah 1 ke dalam release notes.</p></li>
<li><p>Naikkan version number di dalam source code menggunakan Eclipse. Search file <code>pom.xml</code>, find <code>1.2.0</code> dan replace menjadi <code>1.2.1</code>.</p></li>
<li><p>Save semua file, kemudian commit ke Git dengan perintah <code>git commit -m "release 1.2.1"</code></p></li>
<li><p>Buat tag di Git dengan perintah <code>git tag -a -F RELEASE.txt 1.2.1</code></p></li>
</ol>


<h1>Penutup</h1>

<p>Demikianlah penjelasan tentang serba-serbi release management dalam software development. Mudah-mudahan bisa membuat project dan produk yang kita hasilkan lebih mudah dikelola.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Meluruskan Mitos CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/"/>
    <updated>2011-08-10T15:01:25+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi</id>
    <content type="html"><![CDATA[<p>Di milis manajemen proyek IT sedang rame diskusi tentang CMMI dan Scrum.
Seperti layaknya diskusi yang rame, perdebatan dibumbui dengan segala macam mitos dan 'FUDification'.</p>

<p>Berikut adalah tanggapan saya tentang mitos yang berkembang mengenai CMMI, dicopy-paste dari posting milis dengan sedikit penyesuaian.</p>

<p>Beberapa mitos yang akan diluruskan :</p>

<ul>
<li>CMMI adalah metodologi manajemen proyek yang cenderung waterfall</li>
<li>CMMI mewajibkan kita bikin banyak dokumen</li>
</ul>


<p>Pada artikel ini, kita akan meluruskan mitos-mitos tersebut.</p>

<h2>CMMI = metodologi, cenderung waterfall</h2>

<p>CMMI bukanlah metodologi manajemen proyek seperti
<a href="http://en.wikipedia.org/wiki/Scrum_(development">Scrum</a>), <a href="http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process">IBM Rational Unified Process</a>, <a href="http://en.wikipedia.org/wiki/Extreme_Programming">XP</a>, apalagi <a href="http://en.wikipedia.org/wiki/Waterfall_model">Waterfall</a>.</p>

<p>CMMI sebetulnya sudah pernah saya jelaskan <a href="http://endy.artivisi.com/blog/manajemen/apa-itu-cmmi/">di posting saya sebelumnya</a>. Tapi untuk lebih menyederhanakan lagi, kita bisa analogikan CMMI seperti akreditasi perguruan tinggi. Kalau kita mau daftar kuliah, biasanya kita cari tahu akreditasi kampus yang kita tuju. Semakin tinggi akreditasinya, semakin tinggi ekspektasi kita terhadap kualitas perguruan tinggi tersebut. <a href="http://ban-pt.kemdiknas.go.id/">Akreditasi perguruan tinggi</a> <a href="http://ban-pt.kemdiknas.go.id/index.php?option=com_content&amp;view=article&amp;id=57&amp;Itemid=63&amp;lang=in">ditentukan oleh banyak hal</a>, diantaranya :</p>

<ul>
<li>berapa jumlah dosen yang S3</li>
<li>berapa karya ilmiah dan penelitian yang dihasilkan dalam satu periode</li>
<li>dsb</li>
</ul>


<p>Untuk menentukan suatu kampus mendapat level A, B, atau lainnya, maka ada tim assessor yang akan memeriksa apakah kampus tersebut sudah memenuhi apa yang dipersyaratkan.</p>

<p>Demikian juga dengan CMMI, berisi seperangkat checklist yang bentuknya kira-kira seperti ini:</p>

<table>
<thead>
<tr>
<th></th>
<th> Level  </th>
<th> Process Area </th>
<th> OK </th>
<th> Not OK </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>   2    </td>
<td> REQM         </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PP           </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PMC          </td>
<td>    </td>
<td>   v</td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> MA           </td>
<td>    </td>
<td>   v</td>
</tr>
</tbody>
</table>


<p>Nah, checklist itu nanti akan dicentang sesuai dengan kapabilitas perusahaan yang diperiksa.</p>

<p>Adapun urusan Scrum, Waterfall, XP, whatever metodologi yang kita gunakan,
hanyalah mencakup sebagian saja dari CMMI.</p>

<p>CMMI itu model untuk menggambarkan organisasi pembuat software yang mature. Apa itu mature? Salah satu karakteristiknya adalah konsistensi. Perusahaan yang gak mature, hasil kerjanya gak konsisten. Project A ontime, Project B molor 3 tahun. Project X bugnya dikit, Project Y isinya bug doang gak ada fiturnya.</p>

<p>Kalau kita bisa mengeksekusi project dengan sukses, kita hanya bisa lulus CMMI level 2. Untuk bisa mendapatkan level 3, kita harus bisa mengeksekusi project dengan sukses <strong>secara konsisten</strong>.
Untuk bisa konsisten, maka kita harus bisa menduplikasi project sukses ke seluruh perusahaan. Jadi, kalau kita sudah sukses pakai Scrum di project kita sekarang, tetap saja baru level 2. Hanya setelah kesuksesan Scrum bisa direplikasi di keseluruhan perusahaan, barulah bisa level 3.</p>

<p>Seperti juga halnya replikasi resep McDonalds ke seluruh cabang, untuk bisa mereplikasi project sukses ke seluruh perusahaan,
dibutuhkan kegiatan tambahan di level organisasi, misalnya :</p>

<ul>
<li>Menulis SOP (OPD)</li>
<li>Membuat program pelatihan internal (OT)</li>
<li>Selalu menganalisas prosedur yang sekarang berlaku, supaya bisa diimprove (OPF)</li>
</ul>


<p>Yang di dalam kurung adalah process area yang bersesuaian di CMMI.</p>

<p>Berurusan dengan perusahaan yang mature akan mengurangi resiko di client. Apa itu resiko?</p>

<p>Buat orang awam seperti kita, resiko adalah simply sekian persen kemungkinan adanya masalah di kemudian hari. Nah, ada perspektif finansial yang kita orang teknis biasanya gak kepikiran. Buat orang finance, persentase tersebut bisa diuangkan. Misalnya kita mau bikin aplikasi costnya 100 M, uangnya minjem ke bank. Karena pada dasarnya bank gak mau rugi, 100 M itu akan diasuransikan sama dia. Jadi kalo projectnya bubaran, kita gak sanggup bayar, hutangnya akan ditalangin sama asuransi.</p>

<p>Asuransi akan lihat, kita pakai vendor siapa. Kalo vendornya gak mature (baca: resiko tinggi) maka premi asuransinya akan tinggi. Akibatnya, biaya pinjaman kita (cost of money) juga tinggi.</p>

<p>Bisa aja kita bayar 100 M (pokok) + 20 M (bunga) + 20 M (asuransi). Padahal kalo vendornya mature, premi asuransinya cuma 5 M. Nah, jadi urusan resiko dan maturity ini bukan semata jargon2 aja, tapi ada duit beneran yang tersangkut di dalamnya.</p>

<p>Demikianlah mitos pertama, CMMI bukan metodologi manajemen proyek, melainkan manajemen keseluruhan perusahaan.</p>

<h2>CMMI mewajibkan kita bikin banyak dokumen</h2>

<p>CMMI sama sekali tidak mengharuskan kita bikin dokumen apa-apa.</p>

<p>Yang ada, kita harus :</p>

<ul>
<li><strong>melakukan</strong> project planning (level 2)</li>
<li><strong>melakukan</strong> project monitoring &amp; control (level 2)</li>
<li><strong>mendefinisikan</strong> project life cycle : bisa waterfall, scrum, spiral, cowboy programming juga boleh</li>
</ul>


<p>Berikut beberapa definisi singkat</p>

<ul>
<li>Planning : merencanakan apa yang akan dilakukan</li>
<li>Monitoring : melihat kondisi aktual, apakah sesuai dengan plan</li>
<li>Control : melakukan tindakan kalau kondisi aktual tidak sesuai dengan plan</li>
</ul>


<p>Nah, kita harus membuktikan bahwa kita benar2 melakukan apa yang disuruh. Gimana cara membuktikannya?</p>

<p>Kita bisa :</p>

<ol>
<li>Tunjukkan dokumen hardcopy, atau</li>
<li>Tunjukkan bahwa kita melakukan planning, monitoring, dan control di aplikasi yang kita pakai (Redmine, planningpoker.com, pivotaltracker.com, basecamphq.com, fogbugz, whatever)</li>
</ol>


<p>Nah, dari 2 cara di atas, kalo kita <strong>benar-benar</strong> melakukan, akan lebih mudah menunjukkan yang #2. Tapi kalo akal2an, sebenarnya gak planning tapi mau ngakunya planning, akan lebih mudah memalsukan yang #1. Soalnya #2 gak bisa di-back-dated, sedangkan #1 bisa.</p>

<p>Jadi, fokusnya lebih ke <strong>melakukan proses</strong>, bukan <strong>membuat dokumen</strong></p>

<p>Kemudian, ada kesalah-kaprahan juga yang umum terjadi tentang planning. Planning itu tidak sekali saja lalu dipakai sepanjang project. Project plan harus mencerminkan kondisi yang terbaru dari project. Misalnya, kita bikin plan awal (versi 1) selesai 3 bulan. Ternyata waktu monitoring di akhir bulan 1, kita udah tau bahwa gak bakalan selesai dalam 2 bulan sisanya. Kita harus melakukan controlling terhadap projectnya. Tindakan control bisa macam2, bisa kita tambah orang biar tetap selesai dalam 3 bulan, bisa juga revisi plannya sehingga mencerminkan kondisi setelah 1 bulan berjalan.</p>

<p>UUD 45 aja bisa diamandemen, masa project plan gak bisa :D</p>

<p>Contoh lain, mengelola requirement (Requirement Management), Level 2.</p>

<p><blockquote><p>S.P 1.1 : Understand Requirement : kita harus memastikan bahwa requirement dipahami.</p></blockquote></p>

<p>Gimana cara membuktikannya?</p>

<p>Kalo prosesnya benar-benar dijalankan, kita bisa tunjukkan email dari BA ke Client yang isinya mengkonfirmasi pemahaman BA tentang requirement yang diminta Client.</p>

<p>Atau kalo seperti Scrum, Clientnya hadir di ruangan yang sama, gak nyatet apa2, rekaman audio juga boleh. Intinya, ada sesuatu yang bisa ditunjukkan ke auditor bahwa kita sudah Understanding Requirement.</p>

<p>Kalo prosesnya palsu, artinya sebenarnya gak dilakukan, tapi mau lulus Level 2, maka dibuatlah dokumen palsu. Bentuknya biasanya review report, isinya item2 requirement, lalu nanti ada tandatangan client palsu.</p>

<p>So, overhead dokumen (mis: review report) itu ada kalo kita memalsukan proses.</p>

<p>Selama kita benar-benar menjalankan apa yang disuruh, pasti ada evidence bahwa kita menjalankan, entah itu bentuknya chat YM, email, Skype call, apalah terserah, tidak ada CMMI mewajibkan formatnya harus mp3 atau apa.</p>

<p><blockquote><p>SP 1.2 : Obtain Commitment to Requirement : semua pihak harus commit terhadap requirement yang sudah dibuat.</p></blockquote></p>

<p>Gimana cara membuktikan bahwa kita comply dengan SP ini?</p>

<p>Paling gampang, BA kirim email ke Client, "Pak, di iterasi ini, kita kerjakan req #12, #14, sama #15 ya. #13 pending dulu aja"</p>

<p>Client reply, "Ok"</p>

<p>That's it, tunjukkan emailnya ke auditor, beres.</p>

<p>Kalau proses ini tidak dijalankan, akan menimbulkan masalah di kemudian hari. Usernya client bilang A, bosnya user bilang A+, programmer bilang C, PM bilang lain lagi. Sekali lagi, selama prosesnya dilakukan, emailnya pasti ada.</p>

<p>Kalo prosesnya palsu, atau clientnya gaptek gak kenal email, ya dibuatlah dokumen requirement sign off. Orang2 tandatangan. Dokumennya dijadikan evidence.</p>

<p><blockquote><p>SP 1.3 : Manage Requirement Changes : kalo requirement berubah, harus di-manage.</p></blockquote></p>

<p>Apa itu dimanage?</p>

<p>Dimanage artinya harus jelas :
- apa yang berubah
- siapa yang minta berubah
- siapa yang approve
- apa impactnya ke schedule/cost/effort/cuaca hari ini</p>

<p>Apa buktinya? Email boleh, chat log boleh, rekaman cctv boleh.</p>

<p>Ok, lalu kenapa semua harus ada evidence ??</p>

<p>Berikut joke dari auditor kita dulu,</p>

<p><blockquote><p>In God We Trust, everybody else brings data.</p></blockquote></p>

<p>Jadi, CMMI = banyak dokumen hanyalah mitos belaka. Untuk bisa melakukan verifikasi, auditor tentu butuh melihat evidence. Di jaman modern seperti sekarang, evidence bentuknya tidak harus dokumen tertulis yang dibuat dengan aplikasi office.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Estimasi Proyek Software]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/estimasi-proyek-software/"/>
    <updated>2011-05-11T06:37:12+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/estimasi-proyek-software</id>
    <content type="html"><![CDATA[<blockquote><p>Saya ingin membuat aplikasi akunting, berapa lama dan berapa biayanya?</p></blockquote>

<p>Demikian pertanyaan yang amat sering kita temui di profesi software developer.</p>

<p>Topik estimasi proyek merupakan topik yang sulit. Steve McConnell menyebutnya Black Art,
sehingga dia mengarang buku yang sangat bagus tentang topik ini,
judulnya Software Estimation, Demystifying the Black Art.</p>

<p>Menurut Steve, dalam membuat estimasi, ada 3 metode yang dilakukan, yaitu</p>

<ul>
<li><p>count</p></li>
<li><p>compute</p></li>
<li><p>judge</p></li>
</ul>


<p>Kita harus selalu berusaha count, karena ini yang paling akurat.
Kalo ditanya berapa tinggi pohon, paling baik adalah ambil meteran dan ukur pohonnya.
Dimana kita tidak bisa count, maka kita compute.
Contohnya, di sebelah pohon ada pagar dan di atas pagar ada tiang lampu.
Kita compute jumlah tinggi pagar dan tinggi tiang lampu, sehingga dapat tinggi pohon.
Hanya kalau tidak ada cara lain, baru kita judge.
Dikira2 tingginya berapa.</p>

<p>Dalam kaitannya dalam estimasi, idealnya yang kita estimasi hanyalah project size.
Metric lainnya akan kita compute dari project size ini.</p>

<h2>Apa itu project size?</h2>

<p>Project size merupakan ukuran suatu project.
Dengan project size, kita bisa membandingkan dua aplikasi yang berbeda,
misalnya aplikasi akunting dan aplikasi toko online.</p>

<p>Ada banyak metric untuk mengukur ukuran project. Metric yang paling lazim digunakan
adalah jumlah baris kode program, dalam bahasa Inggris disebut Source Lines of Code (SLOC)
atau Non Commenting Source Code (NCSS).</p>

<p>Walaupun SLOC sangat akurat dalam menentukan ukuran project, tapi jumlah baris kode sulit diperkirakan di awal project.
Oleh karena itu, beberapa orang kreatif lalu mengarang metode baru yang disebut Function Point Calculation.
Metode ini pada intinya adalah menghitung berapa screen input, screen output, jumlah tabel database, dan interaksinya dengan aplikasi lain.</p>

<p>Setelah kita mendapatkan estimasi ukuran project, kita akan menggunakannya untuk mengestimasi effort, durasi, dan cost.</p>

<p>Sebelum lebih jauh, mari kita jelaskan istilah-istilahnya.</p>

<p>Effort, adalah kerja real yang kita lakukan dalam menyelesaikan project. Satuannya adalah mandays atau manhour.
Misalnya suatu aplikasi diestimasi membutuhkan effort 10 mandays. Artinya aplikasi ini akan selesai bila dikerjakan 1 orang selama 10 hari terus menerus.
Atau 5 hari bila ada 2 pekerja. Effort tidak mempertimbangkan libur ataupun cuti.</p>

<p>Durasi (bahasa Inggrisnya schedule), adalah jangka waktu penyelesaian project. Ini biasanya dinyatakan dalam satuan hari kerja atau hari kalender.
Bila durasi project dinyatakan 10 hari kalender, maka bila dimulai tanggal 1, akan selesai tanggal 10.</p>

<p>Jadi, untuk mendapatkan durasi, kita harus punya asumsi berikut :</p>

<ul>
<li><p>berapa orang yang dipekerjakan</p></li>
<li><p>berapa hari libur</p></li>
<li><p>berapa alokasi waktu non-pekerjaan seperti meeting, presentasi, dsb</p></li>
</ul>


<p>Asumsi tersebut, digabungkan dengan estimasi effort, akan menghasilkan estimasi durasi.</p>

<p>Setelah durasi didapatkan, menghitung estimasi cost mudah saja. Kita membutuhkan matriks gaji per role.
Berapa gaji project manager, gaji programmer, dan role lain dalam setahun, termasuk THR, tunjangan kesehatan, benefit lain dan bonus.
Bagilah dengan hari kerja setahun sehingga didapatkan nilai gaji sehari.
Kemudian petakan penggunaan masing-masing role dalam schedule yang sudah kita estimasi, dan kita akan mendapat biaya personel.
Tambahkan dengan biaya lain-lain seperti transport, komunikasi, dsb untuk mendapatkan biaya total.
Masukkan juga faktor resiko project, misalnya kalau clientnya terkenal sulit ditagih, tentu perlu ada koefisien pengali.
Karena tagihan macet sama dengan kita memberi hutang ke client.</p>

<p>Nah, akhirnya biaya total sudah didapatkan, silahkan tambahkan profit yang diinginkan, buffer negosiasi, dan voila, dapatlah harga penawaran.</p>

<p>Selesai? Belum dong :D</p>

<p>Pembaca yang teliti tentu akan menemukan satu celah di penjelasan di atas. Bagaimana mengkonversi estimasi project size menjadi estimasi effort?
Nah disinilah bedanya perusahaan besar kaya pengalaman dengan startup mahasiswa baru lulus. Perusahaan dengan jam terbang tinggi biasanya punya data historis.
Dia punya data misalnya berapa mandays yang dibutuhkan programmer untuk membuat aplikasi dengan 3 tabel database.
Tentunya data ini harus dikumpulkan, diolah, dan diupdate agar bisa dijadikan pedoman. Ini sebabnya tidak semua perusahaan besar punya data ini.
Dengan bermodalkan data ini, perusahaan tinggal mengkonversi project size menjadi effort.
Setidaknya ada dua jenis data yang kita butuhkan, yaitu berapa effort yang dibutuhkan untuk menyelesaikan satu baris kode, dan bagaimana distribusi effort selama fase project. Maksudnya, bila project kita diestimasi 100 mandays, berapa mandays habis di analisa, coding, testing, implementasi, dan maintenance.
Selain itu, juga perlu ada matriks distribusi effort per role. Dengan adanya matriks ini, kita akan lebih mudah menkonversi effort menjadi durasi dan cost.</p>

<p>Startup mahasiswa, karena tidak punya data, maka cuma bisa tebak-tebak buah manggis. Atau kalo mau sedikit ilmiah, bisa mengikuti cara kami di ArtiVisi waktu baru mulai dulu. Kita membuat aplikasi kecil, kemudian datanya dikumpulkan dan dijadikan pedoman.</p>

<p>Jadi, kesimpulannya, begini metode estimasinya.</p>

<p><strong>Kebutuhan Data</strong></p>

<ol>
<li><p>Tabel konversi size ke mandays</p></li>
<li><p>Tabel gaji pegawai per role per hari</p></li>
<li><p>Tabel distribusi effort per fase</p></li>
<li><p>Tabel distribusi effort per role</p></li>
</ol>


<p>Flow Estimasi</p>

<ol>
<li><p>Estimasi Size</p></li>
<li><p>Dari size, gunakan tabel #1 untuk mendapatkan effort</p></li>
<li><p>Dari effort, gunakan tabel #3 untuk mendapatkan durasi</p></li>
<li><p>Dari effort, gunakan tabel #4 untuk mendapatkan effort per personel</p></li>
<li><p>Dari effort per personel, gunakan tabel #2 untuk menghitung biaya personel</p></li>
<li><p>Gunakan durasi untuk menghitung biaya lain-lain</p></li>
</ol>


<p>Demikian metodologi untuk melakukan estimasi project software. Membuat estimasi saja tidak cukup, kita juga harus bisa mempresentasikan dan mempertahankannya dari negosiasi pihak lain. Ini akan dibahas di lain kesempatan.</p>
]]></content>
  </entry>
  
</feed>
