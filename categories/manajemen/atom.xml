<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: manajemen | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/manajemen/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2014-07-27T00:25:53+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tahapan Membuat Aplikasi]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/tahapan-membuat-aplikasi/"/>
    <updated>2014-04-22T23:51:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/tahapan-membuat-aplikasi</id>
    <content type="html"><![CDATA[<p>Seperti sudah dijelaskan pada <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">artikel sebelumnya</a>, anjuran saya buat mereka yang ingin mahir pemrograman adalah</p>

<blockquote><p>Buatlah aplikasi production barang 5-10 buah. Insya Allah setelah itu Anda akan mahir.</p></blockquote>

<p>Setelah kita menguasai dasar-dasar pemrograman seperti:</p>

<ul>
<li>konsep variabel dan tipe data</li>
<li>control flow (looping, branching, jumps)</li>
<li>pengelompokan (function, class, package)</li>
</ul>


<p>tidak serta merta kita bisa langsung membuat aplikasi. Analoginya, walaupun kita mahir menggunakan pengolah dokumen seperti MS Word atau Open Office, tidak berarti kita bisa menulis seri lanjutan dari <a href="http://en.wikipedia.org/wiki/Harry_Potter_and_the_Deathly_Hallows">Harry Potter and the Deathly Hallows</a>.</p>

<p>Inilah sebabnya banyak pemegang sertifikasi pemrograman seperti Oracle Certified Java Programmer yang tidak bisa membuat aplikasi, walaupun mendapatkan nilai yang tinggi.</p>

<p>Ada berbagai macam aplikasi, diantaranya:</p>

<ul>
<li>aplikasi bisnis, yaitu aplikasi yang membantu pencatatan kegiatan bisnis. Contohnya aplikasi akunting, purchasing, perpustakaan, mini-market, bank, payment gateway, dan sebagainya</li>
<li>aplikasi sistem, yaitu aplikasi yang memungkinkan berbagai perangkat bekerja sama. Contohnya sistem operasi, device driver, embedded system, dan lainnya</li>
<li>dan berbagai kategori aplikasi lainnya.</li>
</ul>


<p>Artikel kali ini akan kita batasi hanya untuk membahas aplikasi bisnis. Mengapa demikian? Karena aplikasi bisnis adalah genre aplikasi yang paling banyak dibuat orang. Sebagai ilustrasi, kita hanya mengenal beberapa sistem operasi populer, yaitu Microsoft Windows, Linux, MacOS. Bandingkan dengan aplikasi bisnis, untuk proses akuntansi saja berapa ribu aplikasi yang tersedia. Bahkan walaupun sudah ada yang gratis dan lengkap, tetap saja banyak perusahaan yang minta dibuatkan aplikasi sejenis. Jadi dari sisi komersial dan ketersediaan lapangan kerja, pembuatan aplikasi bisnis tetaplah pangsa pasar terbesar.</p>

<p>Pada artikel ini, kita akan membahas proses berpikir dan tahapan mulai dari penjabaran aplikasi yang akan dibuat, sampai menjadi skema database dan desain aplikasi berorientasi objek (object-oriented).</p>

<!--more-->


<p>Berikut adalah tahapan yang biasa saya lakukan dalam mengembangkan aplikasi:</p>

<ol>
<li>Membuat deskripsi aplikasi. Berisi penjelasan tentang apa fungsi utama dari aplikasi yang akan kita kembangkan. Tuliskan juga siapa saja user yang terlibat, dan garis besar dari proses bisnis yang akan disediakan oleh aplikasi.</li>
<li>Membuat daftar fitur</li>
<li>Untuk proyek komersial, daftar fitur ini akan kita terjemahkan menjadi estimasi biaya dan waktu. Bila Anda adalah programmer dan tidak berurusan dengan masalah finansial, silahkan skip langkah ini. Bila Anda ingin tahu lebih jauh, silahkan baca <a href="http://software.endy.muhardin.com/manajemen/estimasi-proyek-software/">artikel yang khusus membahas masalah estimasi ini</a>.</li>
<li>Membuat UI Mockup</li>
<li>Membuat skema database</li>
<li>Membuat daftar class dan relasi antar class</li>
<li>Membuat kerangka aplikasi dalam bentuk source code</li>
<li>Membuat detail implementasi source code sampai selesai</li>
<li>User Acceptance Test, baik internal maupun external (kalau ada client/customer yang akan mengetes)</li>
</ol>


<p>Agar lebih mudah dipahami, kita akan menggunakan studi kasus aplikasi perpustakaan. Kita pilih aplikasi ini karena semua orang sudah paham proses bisnisnya. Kalau saya pilih aplikasi seperti misalnya payment gateway, banking, gps tracking, dan aplikasi-aplikasi 'bergengsi' lainnya, saya khawatir proses bisnisnya tidak dipahami oleh mayoritas pembaca. Tidak semua orang paham apa yang terjadi pada saat nasabah membuka rekening bank.</p>

<p>Ok mari kita mulai.</p>

<h2>Penjelasan Aplikasi</h2>

<p>Penjelasan atau deskripsi aplikasi adalah hal terpenting dalam pembuatan aplikasi. Bila kita membuatnya dengan benar, maka pekerjaan kita di tahap selanjutnya akan mudah. Sebagaimana halnya semua skill yang lain, kemahiran kita dalam mengarang penjelasan aplikasi ini hanya bisa didapatkan dari latihan. Berikut contoh penjelasan aplikasi perpustakaan.</p>

<p>```
Aplikasi perpustakaan ini, sesuai namanya berguna
untuk mengelola kegiatan operasional perpustakaan.
Aplikasi ini akan digunakan oleh penjaga perpustakaan untuk:</p>

<ul>
<li>entri data anggota</li>
<li>entri data buku</li>
<li>entri peminjaman buku</li>
<li>entri pengembalian buku</li>
</ul>


<p>Selain itu, anggota juga bisa menggunakan aplikasi ini untuk:</p>

<ul>
<li>mencari buku dengan kriteria tertentu
(misalnya judul, pengarang, topik, dan sebagainya)</li>
<li>melihat ketersediaan buku</li>
<li>mengetahui lokasi penyimpanan buku</li>
<li>booking buku secara online dari rumah agar tidak kehabisan
```</li>
</ul>


<p>Dari penjelasan aplikasi di atas, kita bisa menentukan apa saja usernya dan apa saja fitur dari aplikasi yang akan kita buat. Mari kita lanjutkan ke tahap selanjutnya.</p>

<h2>Daftar Fitur</h2>

<p>Aplikasi bisnis (aplikasi yang dibuat untuk melayani operasional bisnis) biasanya memiliki fitur yang dapat diklasifikasikan menjadi beberapa kategori:</p>

<ul>
<li>master data : data referensi yang jarang berubah. Misalnya kelurahan, kode pos, tingkat pendidikan, dan lainnya. Untuk mengubah data master biasanya tidak ada proses bisnis khusus. User langsung saja membuka datanya, kemudian mengedit isinya, dan tekan tombol save.</li>
<li>transaksi : fitur pencatatan transaksi bisnis. Di sini biasanya ada berbagai aturan bisnis yang rumit seperti penambahan/pengurangan stok, perhitungan pajak, dan lain sebagainya</li>
<li>laporan : rekap dan aggregasi dari data transaksi. Umumnya ada fitur pencarian berdasarkan tanggal, jumlah total, dan sejenisnya. Biasanya juga ada fitur export ke berbagai format file (CSV, XLS, PDF)</li>
<li>personalisasi / konfigurasi : fitur untuk memudahkan user. Contohnya daftar menu favorit, mengganti email / no handphone, tema warna, dan lain sebagainya</li>
<li>utilitas / administrasi : fitur untuk pemeliharaan aplikasi. Misalnya backup/restore.</li>
</ul>


<p>Untuk membuat daftar fitur biasanya kita mulai dari fitur transaksi. Setelah itu, kita tentukan master data apa saja yang dibutuhkan tiap transaksi. Selanjutnya, laporan-laporan yang dapat dibuat dari berbagai transaksi. Terakhir baru kita identifikasi fitur personalisasi dan utilitas.</p>

<p>Berikut adalah daftar fitur aplikasi perpustakaan:</p>

<p>```
* Transaksi</p>

<pre><code>* Registrasi Anggota
* Berhenti jadi anggota
* Peminjaman
* Pengembalian
* Booking
* Buku baru (beli, hibah, dsb)
* Penghapusan buku (hilang, rusak, dsb)
</code></pre>

<ul>
<li><p>Master Data</p>

<ul>
<li>Buku</li>
<li>Anggota</li>
<li>User</li>
<li>Group</li>
<li>Permission</li>
</ul>
</li>
<li><p>Laporan</p>

<ul>
<li>Rekap Buku Masuk per Periode</li>
<li>Rekap Buku Dihapus per Periode</li>
<li>Rekap Peminjaman per Periode</li>
<li>Rekap Pengembalian per Periode</li>
<li>Histori Peminjaman dan Pengembalian per Anggota</li>
<li>Rekap Jumlah Buku</li>
<li>Rekap Anggota</li>
</ul>
</li>
<li><p>Personalisasi</p>

<ul>
<li>Ganti Password</li>
<li>Ganti Email</li>
<li>Ganti HP</li>
<li>Pengaturan Notifikasi</li>
</ul>
</li>
<li><p>Utilitas</p>

<ul>
<li>Backup</li>
<li>Restore</li>
<li>Import Data Anggota</li>
<li>Import Data Buku
```</li>
</ul>
</li>
</ul>


<p>Selanjutnya, berbekal daftar fitur di atas, kita bisa mulai membuat UI Mockup.</p>

<h2>UI Mockup</h2>

<p>UI Mockup merupakan solusi murah meriah dan cepat untuk sinkronisasi pemahaman kita dan pemahaman user tentang aplikasi yang akan dibuat. Kalau kita tidak membuat UI mockup, kesalah pahaman kita baru diketahui setelah aplikasinya selesai dibuat. Ini akan memboroskan waktu dan tenaga.</p>

<p>Sebagai gambaran, untuk membuat UI mockup, satu orang bisa menyelesaikan 1 screen dalam waktu 5 menit. Sedangkan untuk mengimplementasikan screen tersebut dalam aplikasi, belum tentu selesai dalam 5 hari. Padahal screen tersebut belum tentu sesuai dengan kebutuhan user. Kan sayang kalau sudah dicoding 5 hari ternyata salah.</p>

<p>Untuk membuat UI Mockup, kita dapat menggunakan aplikasi <a href="http://pencil.evolus.vn/">Pencil</a> yang gratis dan mudah digunakan. Aplikasi Pencil ini memiliki <a href="http://pencil.evolus.vn/Stencils-Templates.html">berbagai template (stencil)</a> sesuai aplikasi yang akan kita buat, misalnya aplikasi desktop Windows, aplikasi desktop Linux, aplikasi web, aplikasi Android, dan sebagainya.</p>

<p>Ada beberapa pola umum dalam membuat aplikasi bisnis, yaitu:</p>

<ul>
<li>tampilan list</li>
<li>form entri sederhana</li>
<li>form entri header-detail</li>
<li>lookup dialog</li>
</ul>


<p>Untuk menyederhanakan pembahasan, kita hanya akan buat sebagian kecil saja screen dari aplikasi perpustakaan. Soalnya kalau kita buat semua, bisa-bisa artikel ini jadi satu buku sendiri ;)</p>

<p>Berikut daftar screen yang akan kita buat:</p>

<ul>
<li>Entri Anggota</li>
<li>Entri Peminjaman</li>
<li>Histori Peminjaman per Anggota</li>
</ul>


<p>File Pencil dari UI Mockup di artikel ini bisa diunduh <a href="../../downloads/aplikasi-perpustakaan.ep">di sini</a></p>

<h3>Entri Anggota</h3>

<p>Berikut adalah tampilan screen entri anggota.</p>

<p><img src="https://lh4.googleusercontent.com/-1hcFb859pOI/U1acWK5Y8YI/AAAAAAAAFqw/KxhM_jXmybE/w771-h474-no/entri_anggota.png"></p>

<p>Ada beberapa hal yang harus kita perhatikan di sini, yaitu:</p>

<ul>
<li>validasi input harus dilakukan, baik di sisi server maupun di sisi client.</li>
<li>pesan error harus ditampilkan secara jelas</li>
</ul>


<p>Pembahasan detailnya sudah kita jabarkan di <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">artikel sebelumnya</a>, jadi tidak perlu kita ulangi lagi di sini.</p>

<p>Form entri anggota ini termasuk form entri sederhana. Pola ini biasanya dipakai untuk entri data master, seperti misalnya:</p>

<ul>
<li>Form Entri Buku</li>
<li>Form Entri User</li>
<li>dan lainnya</li>
</ul>


<p>Selanjutnya, kita masuk ke form entri header detail yang lebih kompleks</p>

<h3>Entri Peminjaman</h3>

<p>Hampir semua kegiatan transaksi dalam aplikasi bisnis bisa direpresentasikan dengan model header-detail. Apa itu model header-detail?</p>

<blockquote><p>Satu transaksi akan terdiri dari satu record header dan banyak record detail. Record detail memiliki relasi foreign key ke record header.</p></blockquote>

<p>Sebagai contoh, kita lihat transaksi peminjaman. Satu kali pinjam, anggota bisa membawa banyak buku. Bagaimana representasinya?</p>

<p>Salah satu teknik yang sering saya gunakan dalam analisa dan desain aplikasi adalah <code>visualisasi dengan ilustrasi</code>. Kita buat contoh kasus yang menceritakan transaksi bisnis yang terjadi lengkap dengan datanya. Dengan menggunakan kasus konkrit, kita tidak perlu pusing membayangkan sesuatu yang abstrak. Ini adalah trik yang biasanya tidak diketahui programmer pemula sehingga mereka bingung gak tau mana ujung mana pangkal. Berikut contoh kasusnya.</p>

<p><code>``
Pada hari Senin 21 April 2014 pukul 13:45
anggota bernama</code>Endy Muhardin<code>
dilayani oleh petugas bernama</code>Anton Raharja`
meminjam tiga buku sebagai berikut:</p>

<ul>
<li>Java Desktop</li>
<li>Konsep dan Penggunaan Subversion</li>
<li>Pengenalan PHP
```</li>
</ul>


<blockquote><p>Bagaimana menyimpan data transaksi di atas dalam database?</p></blockquote>

<p>Pertama, kita tentukan dulu headernya. Header adalah satu record yang menjadi induk dari transaksi di atas. Kita buat tabel <code>peminjaman_header</code> sebagai berikut</p>

<table>
<thead>
<tr>
<th> id  </th>
<th> waktu               </th>
<th> id_petugas </th>
<th> id_anggota </th>
</tr>
</thead>
<tbody>
<tr>
<td>p001 </td>
<td> 2014-04-21 13:45:00 </td>
<td> u001       </td>
<td> u100</td>
</tr>
</tbody>
</table>


<p>User dengan id <code>u001</code> adalah relasi foreign key ke tabel <code>master_user</code> yang berisi record <code>Anton Raharja</code>, sedangkan user dengan id <code>u100</code> adalah relasi foreign key ke tabel <code>master_user</code> yang berisi record <code>Endy Muhardin</code>.</p>

<p>Sesuai dengan prinsip <code>visualisasi dengan ilustrasi</code>, dalam mendesain tabel kita isikan juga datanya. Itu sebabnya tabel di atas tidak saya tampilkan seperti biasanya orang mendesain database seperti ini:</p>

<table>
<thead>
<tr>
<th>Nama Kolom </th>
<th> Tipe Data   </th>
<th> Atribut</th>
</tr>
</thead>
<tbody>
<tr>
<td>id         </td>
<td> VARCHAR(32) </td>
<td> PRIMARY KEY</td>
</tr>
<tr>
<td>waktu      </td>
<td> DATETIME    </td>
<td> NOT NULL</td>
</tr>
<tr>
<td>id_petugas </td>
<td> VARCHAR(32) </td>
<td> FOREIGN KEY, NOT NULL</td>
</tr>
<tr>
<td>id_anggota </td>
<td> VARCHAR(32) </td>
<td> FOREIGN KEY, NOT NULL</td>
</tr>
</tbody>
</table>


<p>Karena kalau kita tampilkan seperti di atas, kita terpaksa harus membayangkan sesuatu yang abstrak.</p>

<blockquote><p>Lalu apakah saya harus menggunakan visualisasi dengan ilustrasi seumur hidup saya?</p></blockquote>

<p>Tentu tidak, nanti setelah membuat aplikasi production yang ke-sekian puluh, visualisasi ini sudah <em>terinstal</em> dalam sistem operasi otak kita. Demikian juga dengan prinsip-prinsip normalisasi database, desain berorientasi objek, pola header-detail, dan sebagainya. Pada tahap ini, kita akan bisa coding sambil usernya menceritakan requirement aplikasi yang dia inginkan.</p>

<p>Tapi itu nanti, ada waktunya. Bila Anda masih membaca artikel ini, berarti belum waktunya ;) Sementara ini, jangan malas membuat ilustrasi. Bahkan mahasiswa saya di mata kuliah Pemrograman 1 harus membuat ilustrasi di spreadsheet pada waktu looping menampilkan bilangan prima.</p>

<p>Baiklah, kita kembali ke masalah header-detail. Kita sudah mencatat waktu transaksi, petugas, dan anggota. Sekarang kita akan mencatat buku apa saja yang dipinjam. Untuk itu, kita membuat tabel <code>peminjaman_detail</code> sebagai berikut</p>

<table>
<thead>
<tr>
<th>id    </th>
<th> id_header </th>
<th> id_buku </th>
</tr>
</thead>
<tbody>
<tr>
<td>pd001 </td>
<td> p001      </td>
<td> b001</td>
</tr>
<tr>
<td>pd002 </td>
<td> p001      </td>
<td> b010</td>
</tr>
<tr>
<td>pd003 </td>
<td> p001      </td>
<td> b100</td>
</tr>
</tbody>
</table>


<p>Seperti kita lihat pada tabel di atas, ketiga record berelasi ke record <code>p001</code> di tabel <code>peminjaman_header</code> yaitu pada kolom <code>id_header</code>. Kolom <code>id_buku</code> tentu kita sudah bisa menebak bahwa dia mengacu ke tabel <code>master_buku</code>.</p>

<p>Untuk memasukkan data header dan detail, berikut adalah screen entri transaksinya:</p>

<p><img src="https://lh5.googleusercontent.com/-X3QeTFVgI04/U1adOQ65DlI/AAAAAAAAFrw/whTHBn110mw/w774-h588-no/entri_peminjaman.png"></p>

<p>Berbeda dengan form input sederhana, form entri header-detail memiliki tabel di dalamnya. Tabel inilah yang memuat data detail, sedangkan form inputnya menampung data header.</p>

<p>Karena adanya input ke dalam tabel ini, maka kita membutuhkan screen tambahan, yaitu dialog. Dialog ini akan muncul begitu kita tekan tombol <code>Tambah</code>. Setelah muncul, kita pilih satu atau lebih (tergantung proses bisnis) record dalam dialog. Kemudian setelah selesai, dialognya akan tertutup dan record yang kita pilih masuk ke dalam tabel.</p>

<p>Berikut tampilan dialog untuk memilih buku yang akan dipinjam. Karena yang dipinjam bisa banyak buku, maka kita sediakan checkbox agar user tidak perlu membuka dialog berkali-kali.</p>

<p><img src="https://lh3.googleusercontent.com/-lPHMx7VATXM/U1acVTFCtYI/AAAAAAAAFqg/xQYotfMd4Ns/w804-h420-no/dialog_tambah_buku.png"></p>

<p>Penggunaan dialog tidak terbatas hanya untuk entri detail. Dialog juga sebaiknya kita gunakan untuk data yang bersifat pilihan, kalau jumlah pilihannya lebih dari sepuluh record. Sebagai contoh, pada saat memilih anggota yang akan meminjam buku, tidak mungkin kita gunakan dropdown combo. Kalau anggotanya ada ribuan, usernya pasti kesulitan memilihnya. Apalagi dalam dropdown combo, informasi yang bisa ditampilkan terbatas. Paling hanya nama saja. Akan lebih mudah kalau kita sediakan dialog seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-ZgeS9pGZH-Y/U1acVOVr9HI/AAAAAAAAFqc/5hmU6uXWMAY/w768-h414-no/dialog_cari_anggota.png"></p>

<p>Pola header-detail ini berlaku untuk sebagian besar fitur transaksi. Mari kita ambil contoh lain, transaksi belanja di minimarket misalnya. Screennya seperti ini</p>

<p><img src="https://lh3.googleusercontent.com/LQsOccTBJ6_nHzLHirLdybAv8CMZ_gl6lw3WGIEfpX8=w820-h623-no"></p>

<p>Pada transaksi minimarket, ada tambahan data yaitu <code>quantity</code> untuk mengakomodasi orang beli permen 5 buah. Dialog tambah detailnya juga harus memiliki input field untuk <code>quantity</code>. Dan karena jumlah produknya ribuan, kita juga harus sediakan lookup dialog sekali lagi untuk memilih produk.</p>

<p>Dialog tambah detail seperti ini bentuknya</p>

<p><img src="https://lh5.googleusercontent.com/-fBQUV0F944w/U1acX5wjQ2I/AAAAAAAAFrM/5ZatJYsudL8/w666-h285-no/tambah_detail_minimarket.png"></p>

<p>Di situ ada tombol <code>Cari</code> yang bila diklik akan menampilkan dialog pilih produk seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-lmToPoVQHZ0/U1acWmCjTsI/AAAAAAAAFq4/3mFYG1Cpz1o/w762-h402-no/dialog_cari_produk.png"></p>

<p>Jadi, untuk mengentri satu detail, user akan membuka dialog dua tingkat: dialog entri quantity dan dialog pilih produk.</p>

<p>Adapun tabel di database cukup kita tambahkan satu field quantity seperti ini</p>

<table>
<thead>
<tr>
<th>id    </th>
<th> id_header </th>
<th> id_produk </th>
<th> qty </th>
</tr>
</thead>
<tbody>
<tr>
<td>pd001 </td>
<td> p001      </td>
<td> b001      </td>
<td>   1 </td>
</tr>
<tr>
<td>pd002 </td>
<td> p001      </td>
<td> b010      </td>
<td>   5 </td>
</tr>
<tr>
<td>pd003 </td>
<td> p001      </td>
<td> b100      </td>
<td>  12 </td>
</tr>
</tbody>
</table>


<p>Bisa juga detailnya lebih dari satu, seperti screen transaksi servis motor/mobil. Ada komponen sparepart dan ada komponen jasa. Begini bentuknya</p>

<p><img src="https://lh5.googleusercontent.com/-AFCYrZEZlWE/U1acY31B9wI/AAAAAAAAFrY/W3O2-B4mtyY/w598-h623-no/transaksi_servis_motor.png"></p>

<p>Skema databasenya berarti terdiri dari 3 tabel: <code>servis_header</code>, <code>servis_detail_sparepart</code>, dan <code>servis_detail_jasa</code>.</p>

<p>Selanjutnya, kita buat screen untuk rekap/laporan.</p>

<h3>Histori Peminjaman per Anggota</h3>

<p>Di screen laporan, inputan yang paling sering dipakai adalah periode. Inputannya berupa tanggal mulai dan tanggal sampai. Contohnya, kita ingin menampilkan histori peminjaman buku salah satu anggota untuk 3 bulan terakhir, screennya seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-UPULY4jYmVo/U1acXrfIiJI/AAAAAAAAFrE/IOenvvN8AzM/w867-h486-no/rekap_peminjaman.png"></p>

<p>Di situ kita lihat juga tombol <code>Cari</code>. Itu berfungsi untuk menampilkan dialog pencarian anggota, sama seperti pada screen transaksi peminjaman di atas.</p>

<p>Fitur yang biasa ada di tampilan rekap ini antara lain:</p>

<ul>
<li>pencarian transaksi dengan lebih spesifik. Misalnya menyebutkan buku yang dipinjam, jenis transaksi, nilai/jumlah tertentu, dan sebagainya</li>
<li>paging bila datanya banyak, seperti telah dijelaskan di artikel terdahulu.</li>
<li>sorting, biasanya diimplementasikan melalui kepala tabel yang bisa diklik. Misalnya kita ingin urut tanggal (baik transaksi baru di atas maupun sebaliknya), buku, dan lainnya.</li>
</ul>


<h2>Langkah Selanjutnya</h2>

<p>Setelah UI Mockup kita selesaikan, adakan sesi review bersama user untuk mendapatkan feedback. Setelah sepakat dengan user (untuk proyek komersial bisa juga disertai tanda tangan berita acara kesepakatan) barulah kita lanjutkan ke tahap desain skema database dan desain class/objek.</p>

<p>Banyak orang menyalah-artikan tahap desain dengan dokumen desain. Saya melakukan tahap desain aplikasi, tapi belum tentu membuat dokumen desain.</p>

<p>Proses desain kita lakukan dengan tujuan agar bisa melihat <em>the big picture</em>. Pada waktu mulai coding, perhatian kita akan terpusat ke satu function/method atau class saja. Ibaratnya masuk ke hutan, jarak pandang kita terbatas. Sangat mudah untuk tersesat, kita sudah implement fitur tertentu, ternyata tidak kompatibel dengan fitur selanjutnya.</p>

<p>Selain itu, dengan melihat <em>the big picture</em>, kita jadi tahu fitur mana yang penting dan mana yang <em>nice to have</em>. Jangan sampai kita menghabiskan waktu untuk mengimplementasikan fungsionalitas yang bersifat kosmetik saja, padahal fitur utama belum selesai.</p>

<p>Walaupun demikian, saya tidak membuat dokumen desain. Mengapa begitu? Jawabannya bisa disimak <a href="http://software.endy.muhardin.com/manajemen/dokumentasi-project/">di artikel ini</a>.</p>

<p>Proses mendesain skema database dan skema class/objek akan kita bahas pada artikel selanjutnya. Stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aplikasi Prakarya vs Aplikasi Production]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/"/>
    <updated>2014-04-15T22:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production</id>
    <content type="html"><![CDATA[<p>Salah satu pertanyaan yang sering ditanyakan di forum programmer adalah</p>

<blockquote><p>Saya ingin belajar bahasa pemrograman [isi bahasa yang Anda sukai di sini], bagaimana ya caranya supaya bisa mahir?</p></blockquote>

<p>Dan jawaban saya selalu sama</p>

<blockquote><p>Coba buatlah aplikasi berkualitas production barang 5 - 10 kali, setelah itu insya Allah akan mahir.</p></blockquote>

<p>Jawaban di atas memang singkat, tapi jalan untuk menuju kesana <a href="http://endy.muhardin.com/education/tahapan-belajar/">sungguh tidak mudah dan tidak singkat</a>. Apalagi untuk pemula, setidaknya ada dua pertanyaan besar:</p>

<ol>
<li>Apa sih aplikasi production itu?</li>
<li>Bagaimana cara membuat aplikasi?</li>
</ol>


<p>Pertanyaan pertama akan kita jawab pada artikel ini. Sedangkan pertanyaan kedua akan kita jawab pada artikel selanjutnya.</p>

<!--more-->


<p>Dalam siklus pembuatan aplikasi, biasanya ada beberapa tahapan rilis:</p>

<ol>
<li>Development : ini adalah work in progress yang sedang dikerjakan programmer. Aplikasinya belum selesai sehingga wajar kalau banyak errornya.</li>
<li>Testing : programmer sudah mengetes bagian-bagian yang penting. Tinggal bug pada kasus-kasus dan kondisi <em>'ajaib'</em> yang biasanya cuma bisa ditemukan oleh tester yang handal. Testing biasanya juga ada berbagai tahapan, mulai dari internal tester sampai ke tester dari client/end user.</li>
<li>Production : aplikasi sudah digunakan sehari-hari oleh end user dan berjalan lancar tanpa ada bug yang signifikan (show-stopper).</li>
</ol>


<p>Lebih detail mengenai tahapan rilis bisa dibaca di <a href="http://software.endy.muhardin.com/manajemen/release-management/">artikel terdahulu tentang Release Management</a>.</p>

<p>Tahapan di atas biasanya dijalankan di perusahaan. Di lingkungan akademik (kampus, SMK), saya punya satu kategori lagi yang dinamakan <strong>Aplikasi Prakarya</strong>. Wah apa lagi tuh <strong>Aplikasi Prakarya</strong>??</p>

<blockquote><p>Aplikasi Prakarya adalah aplikasi yang cuma bisa digunakan untuk tugas kuliah ataupun skripsi. Itupun cuma bisa lulus kalau dosennya bermurah hati. Aplikasi prakarya ini tidak akan mungkin digunakan oleh end-user, walaupun daftar fiturnya sama dengan aplikasi production.</p></blockquote>

<p>Masih belum paham? Baiklah kita coba ilustrasikan dengan cerita.</p>

<p>Pada suatu hari, saya menyuruh mahasiswa saya membuat aplikasi. Mereka saat ini sedang semester 4. Seperti umumnya kampus di negeri kita ini, mahasiswa semester 4 belum pernah membuat aplikasi utuh. Jam terbangnya paling hanya beberapa looping/branching atau paling maksimal beberapa function/method untuk belajar algoritma. Saya beri tugas:</p>

<blockquote><p>Coba buat aplikasi user management. Tidak perlu full coding, cukup UI mockup (rancangan screen) saja.</p></blockquote>

<p>Aplikasi user management adalah aplikasi yang paling mendasar. Apapun aplikasi yang ingin kita buat, pasti ada modul ini. Fiturnya pun tidak rumit-rumit. Cukup insert-update-delete-display data user saja. Untuk menyederhanakan masalah, tidak perlulah kita buat group dan permission.</p>

<p>Source file UI mockup yang saya buat di artikel ini bisa diunduh <a href="../../downloads/prakarya-production.ep">di sini</a> dan dibuka menggunakan <a href="http://pencil.evolus.vn/">aplikasi Pencil</a>.</p>

<p>Nah kita lihat evolusi dari aplikasi prakarya menjadi aplikasi production. Kita mulai dengan menampilkan data user.</p>

<h2>Menampilkan Data</h2>

<p>Inilah screen daftar user yang dipresentasikan ke saya</p>

<p><img src="https://lh4.googleusercontent.com/-25Yeh5ay_RY/U01LMUEObTI/AAAAAAAAFpA/p45UmrhH9-4/w888-h408-no/tabelprakarya01.png"></p>

<blockquote><p>Bagaimana menurut Anda? Apakah Anda melihat ada masalah pada screen di atas? Apa masalahnya?</p></blockquote>

<p>Masalahnya ada di jumlah data. Aplikasi prakarya biasanya dites menggunakan 1 - 5 baris data saja. Tentu saja tidak ada masalah yang terlihat kalau datanya cuma 1 - 5 baris. Nah, bagaimana kalau tidak ada data? Biasanya begini jadinya.</p>

<p><img src="https://lh3.googleusercontent.com/-mvMdRuXasxU/U01LNOysKkI/AAAAAAAAFpQ/wkv2gyBpzCs/w882-h363-no/tabelprakarya03.png"></p>

<p>Ini menunjukkan programmer malas. Padahal dengan menambah beberapa baris <code>if-else</code>, tampilan di atas bisa terkesan lebih <em>'serius'</em> seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-g1HzK09B3W0/U01LOCrimhI/AAAAAAAAFpg/yXw_NJX3OIQ/w654-h306-no/tabelproduction02.png"></p>

<p>Ok, kita sudah handle kasus tidak ada data. Nah sekarang, pada waktu dipakai di kondisi riil, berapa datanya? Misalnya kita membuat aplikasi perpustakaan untuk kampus. Berapa jumlah anggotanya? Apakah 1-5 saja? Tentu tidak mungkin. Kisaran datanya antara ratusan sampai puluhan ribu tergantung ukuran kampus. Belum lagi kalau perpustakaannya menerima anggota masyarakat umum.</p>

<p>Dengan data ratusan/ribuan, screen di atas akan mengalami masalah:</p>

<ul>
<li>data tentu ditarik dengan query <code>select * from tabel_user</code>. Kalau satu user datanya 1KB, maka untuk 10 ribu user 10MB harus dikirim dari database server ke webserver, dan kemudian dari webserver ke browser.</li>
<li>asumsikan koneksi internet user 1 MB/s, maka dia harus menunggu 10 detik sampai daftar user bisa dia lihat. Pakai GPRS? Nah, silahkan kembali lagi besok sore ;)</li>
<li>bila ada 10 concurrent user (user yang mengakses aplikasi secara bersamaan), maka kita harus siapkan bandwidth 100 MB/s di sisi server hanya untuk menampilkan daftar user.</li>
</ul>


<blockquote><p>Lalu bagaimana solusinya?</p></blockquote>

<p>Solusi pertama, paging. Kita bagi data menjadi beberapa halaman. Toh user juga tidak mungkin melihat 10 ribu data sekaligus. Bisa-bisa stres dia kayak caleg kalah pemilu.</p>

<p><img src="https://lh6.googleusercontent.com/-CgyzCMA-Foc/U01LMwcZhfI/AAAAAAAAFpM/8PCtzho72xA/w852-h462-no/tabelprakarya02.png"></p>

<blockquote><p>Selesai?</p></blockquote>

<p>Belum. Untuk 10 ribu data, bila satu halaman isinya 20, maka ada 500 halaman. Mana ada orang mau klik satu persatu halamannya. Jadi bagaimana? Ya tentu harus bisa dicari.</p>

<p><img src="https://lh3.googleusercontent.com/-OGKJDR3nnSk/U01LN9OAzmI/AAAAAAAAFpc/Z5mYYDj-O9s/w888-h465-no/tabelproduction01.png"></p>

<p>Nah, dari sini kita sudah bisa membedakan antara aplikasi prakarya dan aplikasi production. Aplikasi prakarya tidak dites secara menyeluruh. Dengan 1-5 data saja sudah puas, cukuplah untuk dapat A kalau dosennya murah hati. Tapi aplikasi production tidak bisa seperti itu kalau aplikasinya mau dipakai orang. Kita harus tes dengan 0 data dan 10 ribu data.</p>

<p>Selanjutnya, mari kita lihat form input data.</p>

<h2>Entri Data</h2>

<p>Inilah screen iterasi pertama</p>

<p><img src="https://lh4.googleusercontent.com/-gwFv3Yp1hMY/U01LKyx9OcI/AAAAAAAAFoo/pjiHEIjgRYc/w687-h510-no/formprakarya01.png"></p>

<blockquote><p>Apa masalahnya?</p></blockquote>

<p>Untuk input data, ada dua hal yang wajib dilakukan dengan benar:</p>

<ul>
<li>validasi</li>
<li>menampilkan pesan kesalahan</li>
</ul>


<p>Mari kita perbaiki. Ini hasil revisinya</p>

<p><img src="https://lh5.googleusercontent.com/-ptivii5-b3I/U01LLWa7lZI/AAAAAAAAFo0/PMTqrd83k9c/w917-h487-no/formprakarya02.png"></p>

<p>Sudah ada pesan error pada screen di atas. Tapi kalau berhenti sampai di sini, usernya bisa marah-marah, soalnya nilai yang sudah dia isikan hilang semua. Harusnya tetap ditampilkan, sehingga dia cukup edit yang salah saja. Tidak perlu entri ulang semuanya. Revisi lagi menjadi seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-pzWfTxTPSaY/U01LLyVPxcI/AAAAAAAAFo4/Qo19dzxO8uM/w900-h459-no/formproduction.png"></p>

<p>Nah, jauh lebih baik.</p>

<p>Selain masalah di atas, ada beberapa hal lagi yang perlu kita perhatikan, yaitu:</p>

<ul>
<li>validasi server-side vs client-side</li>
<li>pemilihan jenis komponen</li>
</ul>


<blockquote><p>Mana validasi yang harus kita buat? Apakah di sisi server atau di sisi client?</p></blockquote>

<p>Validasi yang wajib adalah di sisi server. Kita harus cek semua data yang dikirim client. Kita juga tidak boleh hanya mengandalkan validasi di sisi client, karena berada di luar kendali kita. Bisa saja JavaScript dimatikan, form input di-bypass <a href="http://software.endy.muhardin.com/java/mendebug-aplikasi-ajax/">menggunakan aplikasi debugger</a>, dan berbagai teknik lainnya. Baik secara sengaja, ataupun karena keterbatasan perangkat di sisi client (misalnya browsernya versi jadul).</p>

<blockquote><p>Kalau begitu, buat apa kita buat lagi validasi di sisi client? Buang-buang energi saja.</p></blockquote>

<p>Validasi di sisi client tujuannya supaya user lebih nyaman. Akan lebih enak kalau setelah kursor pindah, data yang barusan diinput langsung ketahuan benar/salahnya. Daripada isi seluruh form, submit, dan ternyata ada error. Sama seperti tampilan tabel tanpa data di atas. Aplikasi yang hal-hal detailnya diurus dengan baik akan terkesan lebih profesional.</p>

<p>Pemilihan jenis komponen akan kita bahas pada artikel selanjutnya.</p>

<h2>Pesan Error</h2>

<p>Kita semua tentu kenal Rambo. Dia bisa survive dimanapun dia diterjunkan dan seburuk apapun perlakuan orang kepadanya.</p>

<p><img src="https://lh3.googleusercontent.com/-kWEJAXJQqiY/U01NMQkQ7_I/AAAAAAAAFp0/099uScfrhP0/w768-h576-no/rambo-wallpaper-800x600.jpg"></p>

<p><em>Fotonya Rambo diambil <a href="http://wallpaperswide.com/rambo-wallpapers.html">dari sini</a></em></p>

<p>Aplikasi production juga demikian. Apapun yang diinput user, dia bisa handle dengan baik. Harddisk penuh? Bandwidth lemot? RAM overload? Semua bisa ditangani dengan baik.</p>

<blockquote><p>Bagaimana caranya? Apakah aplikasi tidak boleh error?</p></blockquote>

<p>Tentu tidak. Mana ada yang sempurna di dunia ini. Kita mengatasi kondisi buruk dengan error handling yang baik. Kalau ada sesuatu yang tidak sesuai kondisi yang dibutuhkan aplikasi, kita tampilkan pesan error yang informatif.</p>

<p>Mari kita lihat error handling aplikasi prakarya, ketika usernya mengetikkan alamat yang tidak ada di aplikasi.</p>

<p><img src="https://lh6.googleusercontent.com/-aZa_dcU50c4/U001E2SUhMI/AAAAAAAAFm4/x502FobAP3s/w614-h238-no/404-prakarya.png"></p>

<p>Nah, jelek sekali bukan? Sangat menunjukkan kemalasan programmernya. Padahal dengan beberapa baris tambahan (di Java cuma 4 baris saja), kita bisa buat yang lebih baik seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-o_w5mMRrh1Q/U001mWLAvAI/AAAAAAAAFnI/lS3c42pYdWc/w616-h465-no/404-production.png"></p>

<p>Waktu yang dibutuhkan tidak lama. Maksimal 5 menit saja. Itupun lama karena kita bimbang apakah mau pakai gambar kucing atau Peter Parker.</p>

<p>Nah kalau pesan error di atas hanya sebatas faktor estetika, pesan error berikut konsekuensinya lebih fatal</p>

<p><img src="https://lh3.googleusercontent.com/-YbMALc355TM/U001Gd2IjAI/AAAAAAAAFnA/6tanv9Q5u8I/w621-h350-no/500-prakarya.png"></p>

<blockquote><p>Kenapa fatal?</p></blockquote>

<p>Karena dari pesan error di atas, pemirsa bisa mengetahui:</p>

<ul>
<li>cara menimbulkan error di atas. Tentu dia ingat langkah-langkah yang dia lakukan sehingga terjadi error seperti di atas.</li>
<li>bahasa pemrograman yang digunakan, yaitu Java. Dilihat dari model stacktracenya.</li>
<li>merek dan versi application server yang digunakan, yaitu Tomcat 6.0.29.</li>
<li>lokasi akurat dari kode program yang error, yaitu class <code>ErrorServlet</code> yang berada dalam package <code>com.muhardin.endy.servlet</code> di baris <code>12</code>.</li>
<li>penyebab error, yaitu <code>IllegalStateException</code>.</li>
<li>estimasi cara kerja program pada waktu error</li>
</ul>


<p>Informasi di atas cukup sebagai titik awal cracker yang akan menjebol aplikasi kita. Dengan informasi tersebut, dia tinggal google:</p>

<ul>
<li>bug yang ada di Tomcat versi 6.0.29.</li>
<li>cara mengeksploitasi bug tersebut</li>
</ul>


<p>Nah, cukup mengerikan bukan? Padahal cukup dengan tambahan 4 baris, kita bisa ganti pesan errornya seperti ini</p>

<p><img src="https://lh4.googleusercontent.com/-JoVmx6mjuNg/U00184vMCTI/AAAAAAAAFnk/PpyXQXOqAyU/w619-h372-no/500-production.png"></p>

<p>Screen di atas akan sangat mengurangi informasi yang bisa disalahgunakan orang yang berniat jahat. Lagipula pesan error <code>IllegalStateException</code> tidak ada gunanya buat user. Error 500 artinya tidak ada perbaikan yang bisa dilakukan end-user. Beda dengan error validasi input dimana user bisa memperbaiki isiannya dan kemudian mencoba submit lagi.</p>

<h2>Pesan Moral</h2>

<p>Perbedaan antara aplikasi prakarya dan production sudah dibahas dalam <a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">buku legendaris <code>The Mythical Man Month</code> karya Fred Brooks</a>. Berikut saya kutipkan satu paragraf dari bab pertama</p>

<blockquote><p>Moving down across the horizontal boundary, a program
becomes a programming product. This is a program that can be run,
tested, repaired, and extended by anybody. It is usable in many
operating environments, for many sets of data.
To become a generally usable programming product,
a program must be written in a
generalized fashion. In particular the range and form of inputs
must be generalized as much as the basic algorithm will reasonably
allow. Then the program must be thoroughly tested, so that it can
be depended upon. This means that a substantial bank of test
cases, exploring the input range and probing its boundaries, must
be prepared, run, and recorded. Finally, promotion of a program
to a programming product requires its thorough documentation, so
that anyone may use it, fix it, and extend it. As a rule of thumb,
I estimate that a programming product costs at least three times as
much as a debugged program with the same function.</p></blockquote>

<p>Dari paparan Eyang Fred di atas, kita bisa mendapatkan beberapa poin penting:</p>

<ul>
<li>membuat aplikasi production biayanya 3x lipat dibandingkan membuat aplikasi prakarya</li>
<li>aplikasi production dapat dipakai di berbagai kondisi (operating environment)</li>
<li>aplikasi production dapat menangani data dalam jumlah besar (many sets of data)</li>
<li>aplikasi production dites secara menyeluruh (thoroughly tested)</li>
<li>tidak hanya urusan coding saja, untuk naik kelas ke kasta production aplikasi juga harus dilengkapi dokumentasi yang lengkap</li>
</ul>


<p>Jadi, untuk set fitur yang sama:</p>

<ul>
<li>tambah user</li>
<li>edit user</li>
<li>hapus user</li>
<li>tampilkan data user</li>
</ul>


<p>terdapat perbedaan kualitas yang signifikan antara level prakarya dan level production. Kalau aplikasi prakarya dibuat dalam waktu 1 bulan, maka untuk membuatnya berkualitas production butuh tambahan 2 bulan lagi.</p>

<p>Tapi untungnya, untuk naik kelas dari prakarya menjadi production syaratnya tidak sulit, sederhana saja yaitu:</p>

<blockquote><p>Jangan malas</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Training CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/training-cmmi/"/>
    <updated>2013-05-10T14:13:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/training-cmmi</id>
    <content type="html"><![CDATA[<p>Saya akan mengisi <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">training CMMI di Brainmatics</a> minggu depan, Senin - Rabu, 13 - 15 Mei 2013. Buat yang belum paham apa itu CMMI, bisa baca <a href="http://software.endy.muhardin.com/manajemen/apa-itu-cmmi/">artikel saya mengenai masalah ini</a>.</p>

<p>Sebenarnya, materi tentang CMMI banyak bertebaran secara gratis di internet. Bahkan spesifikasi resminya gratis bisa diunduh di <a href="http://cmmiinstitute.com/">websitenya Carnegie Mellon University</a>. Lalu buat apa ikut training lagi kalau di internet sudah banyak materinya?</p>

<!--more-->


<p>Berikut beberapa alasannya:</p>

<ul>
<li>Materi CMMI yang ada di website sangat abstrak dan penjelasannya bersifat umum.</li>
<li>Agar bisa diimplementasikan di perusahaan, aturan CMMI ini harus dibuatkan dulu padanan/mapping dengan proses bisnis di internal perusahaan.</li>
<li>Proses bisnis di internal perusahaan belum tentu selengkap yang diminta CMMI, sehingga harus didesain dan dibuat dulu.</li>
<li>Seringkali terjadi, cara mendesain proses bisnis yang baik juga belum dikuasai. Ini akan kita bahas pada sesi training.</li>
<li>Setelah dibuat, proses bisnis harus diimplementasikan ke seluruh perusahaan. Implementasi proses bisnis ada metodologinya sendiri.</li>
<li>Di website CMMI, dijelaskan proses appraisal, yaitu proses untuk menilai perusahaan apakah sudah sesuai dengan aturan CMMI. Penjelasan di kertas tentu jauh berbeda dengan pengalaman nyata yang saya alami pada waktu implementasi CMMI.</li>
<li>Ada banyak <a href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/">mitos dan urban legend tentang CMMI</a>, terutama yang berkaitan dengan metodologi agile seperti Scrum, Kanban, XP, dan lainnya. Pada sesi training, kita akan bahas mana yang mitos mana yang nyata.</li>
</ul>


<p>Silabus lengkap bisa dilihat di <a href="http://brainmatics.com/cmmi-capability-maturity-model-integration/">website Brainmatics</a>. Tapi banyak jargon teknis di sana yang baru bisa kita pahami kalau sudah mengerti CMMI. Untuk yang masih awam, berikut adalah hal yang akan kita pelajari/lakukan selama training:</p>

<ol>
<li><p>Apa itu CMMI</p>

<ul>
<li>sejarah</li>
<li>use case</li>
<li>manfaat buat kita</li>
</ul>
</li>
<li><p>Isi perut CMMI</p>

<ul>
<li>apa itu process area</li>
<li>apa itu goals</li>
<li>apa itu practices</li>
<li>apa yang dimaksud generic goals/practices</li>
<li>apa yang dimaksud specific goals/practices</li>
<li>apa itu maturity level</li>
<li>apa yang dimaksud staged representation dan continuous representation</li>
<li>bagaimana proses appraisal</li>
</ul>
</li>
<li><p>Metodologi implementasi</p>

<ul>
<li>menentukan target maturity level yang realistis untuk dicapai perusahaan kita</li>
<li>melakukan gap analysis, antara kondisi perusahaan kita sekarang dan kondisi yang diminta CMMI</li>
<li>membuat mapping antara kebutuhan CMMI dan proses bisnis di perusahaan kita</li>
<li>cara mendesain proses bisnis perusahaan yang efektif dan komprehensif</li>
<li>cara implementasi proses bisnis yang sudah dibuat</li>
<li>tips dan trik dalam proses appraisal</li>
</ul>
</li>
</ol>


<p>Trainingnya akan berbentuk workshop. Saya akan menjelaskan teori secara singkat, lalu kita lanjutkan dengan praktek dan diskusi. Target training ini adalah, peserta pulang dengan membawa :</p>

<ul>
<li>strategi implementasi</li>
<li>daftar proses bisnis yang harus dibuat/direvisi</li>
<li>contoh dokumen dan template</li>
<li>action plan yang harus mereka lakukan di perusahaannya untuk berhasil mencapai target maturity level yang diinginkan.</li>
</ul>


<p>Jadi, tunggu apa lagi, ayo segera daftar. Sampai ketemu di sesi training :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release Management]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/release-management/"/>
    <updated>2012-08-29T18:01:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/release-management</id>
    <content type="html"><![CDATA[<p>Release, atau di-Indonesia-kan menjadi rilis, adalah tahap yang paling penting dalam software development. Segala kegiatan hulu (upstream activity) lainnya seperti <a href="/manajemen/fase-requirement/" title="Fase Requirement">requirement</a>, desain aplikasi, coding, testing, dan lainnya, semua dilakukan demi untuk menghasilkan software yang bisa dirilis. Sebagus apapun kita melakukan kegiatan lainnya, jika rilisnya tidak bagus, maka semua yang kita kerjakan menjadi tidak bagus. Sebaliknya, berbagai kesalahan dan kekurangan di kegiatan lain akan mudah dimaafkan dan dilupakan kalau kita menghasilkan rilis yang baik. Walaupun demikian, perlu diingat bahwa bila kita melakukan kegiatan hulu dengan baik, biasanya kita bisa menghasilkan rilis yang berkualitas baik secara konsisten.</p>

<p>Pada artikel ini, kita akan membahas pernak-pernik yang berkaitan dengan rilis. Apa itu rilis, berbagai jenis rilis, syarat dan ketentuan rilis, dan juga prosedur yang kita gunakan di ArtiVisi.</p>

<!--more-->


<h1>Apa itu rilis</h1>

<p>Rilis pada intinya adalah menyerahkan software yang sudah kita kerjakan ke pihak lain. Berdasarkan siapa yang dimaksud dengan pihak lain, kita membedakan rilis menjadi :</p>

<ul>
<li>rilis internal : menyerahkan software ke pihak internal tim pengembang, misalnya dari programmer ke tester.</li>
<li>rilis eksternal : menyerahkan ke pihak luar seperti client atau customer.</li>
</ul>


<p>Kita tidak harus menunggu sampai software selesai dikerjakan 100% untuk melakukan rilis. Berdasarkan tingkat penyelesaian pekerjaan, kita bisa membedakan rilis menjadi :</p>

<ul>
<li><p>development release : Ini adalah rilis yang dilakukan sebelum software selesai dikerjakan. Rilis ini dibuat untuk menunjukkan kemajuan dalam proses development, misalnya menunjukkan tambahan fitur baru ataupun sekedar menunjukkan perbedaan dengan rilis sebelumnya. Development release biasa dilakukan secara rutin dan periodik. Ada yang melakukannya secara mingguan, harian, bahkan dua kali sehari. Rilis jenis ini juga biasa disebut dengan unstable release (karena softwarenya belum stabil - sering hang atau error), milestone release, daily/nightly build release, atau alpha release.</p></li>
<li><p>testing release : Ini adalah rilis yang dilakukan setelah aplikasi siap untuk dites. Pada titik ini biasanya sudah tidak ada penambahan fitur lagi. Software yang dibuat diserahkan ke tester untuk dicari bugnya. Hasil laporan bug itu kemudian akan ditindak lanjuti sehingga menghasilkan testing release berikutnya. Kalau kita pernah mendengar istilah beta release, biasanya itu maksudnya adalah testing release. Orang sering membagi lagi testing release menjadi beta release dan release candidate. Pada prinsipnya, beta dan release candidate sama saja, bedanya ada di cakupan tester. Beta release khusus untuk dites oleh tester, sedangkan release candidate bisa juga dites oleh end-user.</p></li>
<li><p>final release : Rilis jenis ini menyatakan bahwa software sudah selesai dikerjakan, dites, dan laporan bugnya sudah ditindak lanjuti. Biasa disebut juga stable release, karena software yang dihasilkan bisa digunakan dengan lancar dan nyaman (stabil).</p></li>
</ul>


<h1>Manfaat Rilis</h1>

<p>Manfaat rilis tentunya adalah supaya software yang sudah susah payah kita buat, bisa bermanfaat bagi penggunanya dan sukur-sukur bisa menghasilkan uang bagi pembuatnya. Karena di atas kita sudah membahas berbagai jenis rilis, tentu juga ada macam-macam manfaat dari berbagai jenis rilis tersebut.</p>

<p>Development release sebaiknya dilakukan sesering mungkin. Agar tidak merepotkan, dilakukan menggunakan perangkat otomasi seperti <a href="http://jenkins-ci.org/" title="Jenkins Continuous Integration">Jenkins</a>. Manfaat dari development release adalah untuk memastikan integrasi antara fitur berjalan dengan baik. Sering kali pada saat membuat fitur X, secara tidak sengaja mempengaruhi fitur Y sehingga tidak berjalan dengan baik. Hal inilah yang coba dicegah dengan development release.</p>

<p>Testing release manfaatnya adalah supaya software yang kita buat bisa diperiksa oleh orang lain dengan perspektif yang berbeda dan lebih fresh. Programmer yang membuat aplikasi pastinya sudah hafal perilaku aplikasi yang dibuatnya, sehingga bisa menghindari error yang mungkin terjadi. Tapi tester atau user tidak memiliki pengetahuan tentang cara kerja internal aplikasi, sehingga lebih mungkin menemukan skenario yang belum diantisipasi oleh software.</p>

<p>Final release tentunya berguna supaya software kita bisa digunakan oleh masyarakat umum. Para pengguna (end user) biasanya menunggu sampai suatu software dinyatakan selesai, baru dia mau menggunakannya. Demikian juga bila aplikasi yang kita buat akan dibundel oleh orang lain (contohnya distro Linux, integrasi dengan aplikasi lain, dsb), tentu mereka akan menunggu keluarnya rilis final.</p>

<h1>Aturan Rilis</h1>

<p>Seperti kita bahas sebelumnya, tujuan rilis adalah supaya software kita bisa digunakan oleh orang lain. Oleh karena itu, kita harus memudahkan pengguna dalam memahami rilis yang kita keluarkan.</p>

<p>Hal paling penting dalam melakukan rilis adalah aturan penamaan. Dengan aturan penamaan yang baik, kita bisa:</p>

<ul>
<li>menjelaskan status rilis, apakah ini development release, testing, atau final.</li>
<li>menjelaskan kompatibilitas dengan versi sebelumnya dan aplikasi lain. Ini akan dijelaskan secara lebih detail sebentar lagi.</li>
<li>menjelaskan hubungan dengan rilis lainnya. Bila kita memiliki dua rilis, kita bisa membedakan mana rilis yang duluan dan mana yang belakangan.</li>
</ul>


<h1>Studi Kasus</h1>

<p>Untuk memudahkan pemahaman tentang penamaan rilis, mari kita karang studi kasusnya, yaitu Facebook Contact Backup.</p>

<blockquote><p>Aplikasi Facebook Contact Backup (FCB) adalah aplikasi yang bisa mendownload daftar contact kita di facebook, kemudian menuliskannya ke dalam text file. Contoh textfile akan dilampirkan di bawah. Untuk versi pertama, informasi kontak yang ditampilkan adalah : nama, email, no HP.</p></blockquote>

<p>Berikut contoh file yang dihasilkan oleh aplikasi FCB</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;081298000468&lt;/mobile&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<blockquote><p>Karena aplikasi FCB kemudian menjadi populer, ada orang lain yang membuat aplikasi untuk mengisi phonebook di handphone bernama Handphone Contact Importer (HCI). Aplikasi HCI ini menggunakan aplikasi FCB untuk connect ke facebook dan mengambil data contact. Setelah datanya ada dalam format textfile, aplikasi HCI akan membaca text file tersebut dan kemudian mengisinya ke phonebook handphone.</p></blockquote>

<p>Aplikasi FCB dikembangkan dengan cepat sehingga menghasilkan beberapa rilis sebagai berikut:</p>

<h2>Rilis Pertama</h2>

<p>Memperbaiki format nomer handphone, sehingga semua diseragamkan menjadi format internasional. Nomer <code>081298000468</code> pada contoh di atas akan dikonversi menjadi <code>+6281298000468</code></p>

<h2>Rilis Kedua</h2>

<p>Fix protokol komunikasi ke Facebook, karena ada perubahan di Facebook API.</p>

<h2>Rilis Ketiga</h2>

<p>Menambahkan field ulang tahun sehingga format text file menjadi sebagai berikut :</p>

<p>``` xml facebook_contact.xml
<contacts></p>

<pre><code>&lt;contact&gt;
    &lt;name&gt;Endy Muhardin&lt;/contact&gt;
    &lt;email&gt;endy@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281298000468&lt;/mobile&gt;
    &lt;birthdate&gt;1945-08-17&lt;/birthdate&gt;
&lt;/contact&gt;
&lt;contact&gt;
    &lt;name&gt;Ifnu Bima&lt;/contact&gt;
    &lt;email&gt;ifnu@geemail.com&lt;/email&gt;
    &lt;mobile&gt;+6281234567890&lt;/mobile&gt;
    &lt;birthdate&gt;2011-11-11&lt;/birthdate&gt;
&lt;/contact&gt;
</code></pre>

<p></contacts>
```</p>

<h2>Rilis Keempat</h2>

<p>Ganti format xml menjadi json, mengikuti trend masa kini.
``` js facebook_contact.json
[</p>

<pre><code>{
    name: "Endy Muhardin",
    email: "endy@geemail.com",
    mobile: "+6281298000468",
    birthdate: "1945-08-17"
},
{
    name: "Ifnu Bima",
    email: "ifnu@geemail.com",
    mobile: "+6281234567890",
    birthdate: "2011-11-11"
}
</code></pre>

<p>]
```</p>

<p>Dengan studi kasus di atas, kita harus mempertimbangkan penomoran rilis untuk aplikasi FCB dengan benar, supaya aplikasi HCI bisa tahu apa yang harus dilakukan pada saat aplikasi FCB mengeluarkan rilis baru.</p>

<h1>Kompatibilitas</h1>

<p>Dalam mengeluarkan rilis untuk aplikasi FCB, kita harus mempertimbangkan aplikasi HCI agar tidak rusak. Pengaruh aplikasi FCB terhadap HCI dikenal dengan istilah kompatibilitas. Kompatibilitas dibedakan berdasarkan ketergantungan secara programmatic:</p>

<ul>
<li>binary compatibility : FCB terbaru disebut binary-compatible dengan HCI bila FCB yang sudah dicompile bisa langsung ditaruh di folder dan dipakai oleh HCI.</li>
<li>source compatibility : FCB terbaru disebut source-compatible dengan HCI bila FCB yang sudah dicompile tidak bisa langsung ditaruh begitu saja. HCI harus dicompile ulang dulu dengan FCB terbaru, baru HCI bisa dijalankan.</li>
</ul>


<p>Lebih lanjut tentang binary vs source compatibility bisa dibaca <a href="http://blogs.msdn.com/b/jmstall/archive/2008/03/10/binary-vs-source-compatibility.aspx">di artikel ini</a>.</p>

<p>Dan juga bisa dibedakan berdasarkan hubungannya dengan rilis terdahulu.</p>

<ul>
<li>backward compatibility : bila HCI versi terbaru bisa menggunakan format data FCB yang terdahulu. Misalnya, aplikasi HCI terbaru bisa membaca data versi baru (json), versi sebelumnya (xml), dan sebelumnya lagi (xml tanpa field birthdate)</li>
<li>forward compatibility : bila HCI versi jadul bisa membaca format data FCB yang lama (xml tanpa birthdate) dan yang lebih baru yang dirilis setelah HCI jadul tersebut (xml dengan birhtdate).</li>
</ul>


<p>Setelah kita memahami urusan kompatibilitas, kita bisa menentukan skema penamaan rilis, atau dikenal dengan istilah version numbering.</p>

<h1>Version Numbering</h1>

<p>Kita akan menggunakan <a href="http://apr.apache.org/versioning.html" title="Version Numbering APR">aturan dari Apache Portable Runtime</a> yang sudah diakui sebagai best-practices dalam version numbering. Aturan APR mengharuskan ada tiga komponen version number, yaitu :</p>

<ul>
<li>major number</li>
<li>minor number</li>
<li>patch number</li>
</ul>


<p>Contohnya, waktu pertama kita merilis FCB, kita beri nama <code>FCB-1.0.0</code>. Major numbernya 1, minor numbernya 0, patch numbernya 0.</p>

<p>Untuk rilis selanjutnya, kita menaikkan major/minor/patch number sesuai dengan pengaruhnya terhadap kompatibilitas. Aturannya sebagai berikut:</p>

<ul>
<li>major number dinaikkan bila FCB baru tidak kompatibel dengan FCB rilis sebelumnya. Bila HCI dipasang dengan FCB terbaru ini, HCI akan error.</li>
<li>minor number dinaikkan bila FCB baru mengandung penambahan fitur, tapi tetap kompatibel dengan HCI yang dibuat berdasarkan FCB lama. HCI versi lama tetap bisa jalan, walaupun tidak bisa memanfaatkan fitur yang baru.</li>
<li>patch dinaikkan bila tidak ada perubahan secara fitur, tapi cuma ada perbaikan di internal FCB yang tidak terlihat dari luar (misalnya optimasi koneksi jaringan, perubahan protokol ke arah Facebook, dsb)</li>
</ul>


<p>Selanjutnya, mari kita beri nomer sesuai studi kasus kita di atas.</p>

<ol>
<li>Rilis Pertama : diberi nama <code>1.1.0</code>, karena cuma terjadi perubahan di content saja. HCI yang dibuat dengan FCB versi <code>1.0.0</code> akan tetap berjalan lancar</li>
<li>Rilis Kedua : diberi nama <code>1.1.1</code>, karena perubahan protokol komunikasi dengan Facebook tidak mempengaruhi HCI sama sekali. HCI versi lama tetap bisa jalan dengan lancar.</li>
<li>Rilis Ketiga : diberi nama <code>1.2.0</code>, sama dengan rilis pertama. Ada penambahan fitur, tapi tidak membuat HCI jadi error. Dengan rilis ini, programmer HCI bisa menambahkan fitur baru misalnya reminder ulang tahun. Tapi HCI versi lama (tanpa reminder ulang tahun) tetap bisa digunakan dengan <code>FCB-1.2.0</code></li>
<li>Rilis Keempat : diberi nama <code>2.0.0</code>. Ini adalah perubahan signifikan. Untuk dapat menggunakan <code>FCB-2.0.0</code> ini, HCI harus mengalami perubahan signifikan. HCI versi lama tidak bisa digunakan dengan <code>FCB-2.0.0</code>. Agar dapat digunakan, programmer HCI harus mengeluarkan rilis baru yang bisa mengakomodasi format data JSON.</li>
</ol>


<p>Berikutnya, mari kita lihat pengaruhnya untuk HCI.</p>

<ol>
<li><code>HCI-1.0.0</code> : versi pertama, dibuat dengan <code>FCB-1.0.0</code></li>
<li>Rilis <code>FCB-1.1.0</code> : tidak ada tambahan fitur yang bisa dibuat di HCI, sehingga programmernya tidak coding.</li>
<li>Rilis <code>FCB-1.1.1</code> : tidak ada perubahan yang terlihat. Programmer HCI makan gaji buta sambil update status Facebook. Nganggurnya programmer HCI ini berarti <code>HCI-1.0.0</code> forward-compatible dengan <code>FCB-1.0.0</code>, <code>FCB-1.1.0</code>, hingga <code>FCB-1.1.1</code>.</li>
<li>Rilis <code>FCB-1.2.0</code> : ada field baru (birthdate) yang bisa dimanfaatkan, programmer HCI mulai coding.</li>
<li><code>HCI-1.1.0</code> : tambahan fitur reminder ulang tahun. <code>HCI-1.1.0</code> ini backward-compatible dengan <code>FCB-1.1.1</code>, <code>FCB-1.1.0</code>, maupun <code>FCB-1.0.0</code>.</li>
<li>Rilis <code>FCB-2.0.0</code> : HCI semua versi tidak dapat digunakan bila user meng-upgrade FCB-nya. Programmer HCI harus segera mengeluarkan rilis baru, tidak boleh coding sambil facebookan.</li>
<li><code>HCI-1.1.1</code> : bagi end-user, HCI terbaru ini tidak ada tambahan fiturnya. Tapi dia fixing bug, yang tadinya error pada waktu dijalankan (karena FCB-nya tidak kompatibel), menjadi tidak error.</li>
</ol>


<p>Selain major.minor.patch, ada kalanya orang juga menambahkan satu informasi lagi yang menyatakan kestabilan rilis. Berikut beberapa contohnya:</p>

<ul>
<li><code>FCB-1.0.1-SNAPSHOT</code> : ini biasanya digunakan untuk mencerminkan rilis daily build terbaru</li>
<li><code>FCB-1.0.0-20121212080808</code> : ini biasanya digunakan untuk menunjukkan hasil daily build tertentu</li>
<li><code>FCB-1.0.1-RC-01</code> : release candidate pertama</li>
<li><code>FCB-1.0.0-M2</code> : milestone kedua</li>
<li><code>FCB-1.0.0-Final</code> : final release. Ada orang yang menambahkan keyword Final, ada juga yang tidak.</li>
<li><code>FCB-1.0.0-GA</code> : generally available, sama dengan final release</li>
<li><code>FCB-1.0.0-RELEASE</code> : sama dengan GA dan Final</li>
</ul>


<p>Penomoran versi ini terlihat sepele saja. Tapi kalau kita tidak punya aturan penamaan yang jelas, maka orang lain akan bingung setiap kali ada rilis baru. Mereka tidak bisa menentukan apakah harus upgrade atau tidak, karena mereka tidak bisa tahu bagaimana kompatibilitas rilis ini dengan aplikasi lainnya. Salah satu contoh populer kekacauan yang disebabkan penomoran versi yang sembarangan <a href="http://news.ycombinator.com/item?id=1734936">bisa dilihat di komunitas Ruby</a>. Akibat aturan rilis Ruby tidak jelas, sehingga dibutuhkan aplikasi lain seperti RVM atau rbenv supaya antar versi Ruby tidak saling bentrok. Effort yang dikeluarkan untuk membuat dan memantain RVM dan rbenv tentu tidak sedikit. Ini semua disebabkan <em>hanya karena</em> penomoran versi belaka. Hasil akhir dari semua ini, sampai saat artikel ini ditulis, <a href="http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/">Ruby belum bisa dipaket dengan benar di distro Debian</a> dan turunannya (termasuk Ubuntu).</p>

<h1>Release Notes</h1>

<p>Tentunya penomoran versi saja tidak bisa memuat informasi yang detail. Kita membutuhkan sarana lain untuk memberikan informasi yang detail tentang isi dari suatu rilis. Untuk keperluan ini, biasanya orang membuat dokumen yang disebut Release Notes. Beberapa hal yang biasanya dicantumkan dalam release notes antara lain:</p>

<ul>
<li>fitur baru</li>
<li>bug yang diperbaiki</li>
<li>enhancement/improvement, yaitu perbaikan pada fitur yang ada</li>
<li>known issues, yaitu bug atau error yang sudah teridentifikasi tapi belum difix. Informasi ini menunjukkan bahwa programmernya sudah tahu bahwa ada bug, tapi karena satu dan lain hal belum memperbaikinya</li>
<li>kontributor, yaitu siapa saja yang berkontribusi di rilis ini.</li>
<li>to do, yaitu fitur apa yang direncanakan akan dibuat pada rilis berikut. Informasi ini bisa juga ditulis di dokumen terpisah bernama roadmap</li>
</ul>


<p>Contoh release notes bisa dilihat <a href="/images/uploads/2012/08/RELEASE.txt" title="Contoh Release Notes">di sini</a>.</p>

<h1>Tools</h1>

<p>Ada beberapa hal yang perlu dilakukan pada waktu kita akan melakukan rilis, yaitu:</p>

<ul>
<li>menaikkan nomor versi di source code. Biasanya kita ada mencantumkan nomor versi di aplikasi, misalnya di halaman About.</li>
<li>membuat rekap perubahan yang terjadi sejak rilis sebelumnya</li>
<li>membuat tag di version control database</li>
</ul>


<p>Semua kegiatan di atas dapat dioptimasi dengan tools misalnya <a href="http://maven.apache.org/plugins/maven-release-plugin/" title="Maven Release Plugin">maven-release-plugin</a>. Cara pakainya bisa dilihat <a href="http://java.dzone.com/articles/automating-releases-maven-0">di sini</a>. Tapi beberapa orang melihat bahwa maven-release-plugin ini tidak memenuhi kebutuhannya, sehingga dia pakai <a href="http://www.axelfontaine.com/2011/01/maven-releases-on-steroids-adios.html">cara yang lain</a>.</p>

<p>Di ArtiVisi, kita sudah mencoba maven-release-plugin, dan berpendapat bahwa dia <a href="http://www.sonatype.com/people/2011/01/using-the-maven-release-plugin-things-to-know/">terlalu kaku</a> sehingga sulit dikonfigurasi agar sesuai dengan kebutuhan kita. Akhirnya kita menggunakan cara manual dengan prosedur sebagai berikut:</p>

<h2>Prosedur Rilis ArtiVisi</h2>

<p>Contoh skenario :</p>

<ul>
<li>Rilis sebelumnya : <code>1.2.0</code></li>
<li>Rilis sekarang : <code>1.2.1</code></li>
</ul>


<p>Langkah-langkah melakukan rilis :</p>

<ol>
<li><p>Generate Changelog dengan perintah <code>git shortlog 1.2.0..HEAD</code></p></li>
<li><p>Copy paste output dari langkah 1 ke dalam release notes.</p></li>
<li><p>Naikkan version number di dalam source code menggunakan Eclipse. Search file <code>pom.xml</code>, find <code>1.2.0</code> dan replace menjadi <code>1.2.1</code>.</p></li>
<li><p>Save semua file, kemudian commit ke Git dengan perintah <code>git commit -m "release 1.2.1"</code></p></li>
<li><p>Buat tag di Git dengan perintah <code>git tag -a -F RELEASE.txt 1.2.1</code></p></li>
</ol>


<h1>Penutup</h1>

<p>Demikianlah penjelasan tentang serba-serbi release management dalam software development. Mudah-mudahan bisa membuat project dan produk yang kita hasilkan lebih mudah dikelola.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Meluruskan Mitos CMMI]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi/"/>
    <updated>2011-08-10T15:01:25+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/meluruskan-mitos-cmmi</id>
    <content type="html"><![CDATA[<p>Di milis manajemen proyek IT sedang rame diskusi tentang CMMI dan Scrum.
Seperti layaknya diskusi yang rame, perdebatan dibumbui dengan segala macam mitos dan 'FUDification'.</p>

<p>Berikut adalah tanggapan saya tentang mitos yang berkembang mengenai CMMI, dicopy-paste dari posting milis dengan sedikit penyesuaian.</p>

<p>Beberapa mitos yang akan diluruskan :</p>

<ul>
<li>CMMI adalah metodologi manajemen proyek yang cenderung waterfall</li>
<li>CMMI mewajibkan kita bikin banyak dokumen</li>
</ul>


<p>Pada artikel ini, kita akan meluruskan mitos-mitos tersebut.</p>

<h2>CMMI = metodologi, cenderung waterfall</h2>

<p>CMMI bukanlah metodologi manajemen proyek seperti
<a href="http://en.wikipedia.org/wiki/Scrum_(development">Scrum</a>), <a href="http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process">IBM Rational Unified Process</a>, <a href="http://en.wikipedia.org/wiki/Extreme_Programming">XP</a>, apalagi <a href="http://en.wikipedia.org/wiki/Waterfall_model">Waterfall</a>.</p>

<p>CMMI sebetulnya sudah pernah saya jelaskan <a href="http://endy.artivisi.com/blog/manajemen/apa-itu-cmmi/">di posting saya sebelumnya</a>. Tapi untuk lebih menyederhanakan lagi, kita bisa analogikan CMMI seperti akreditasi perguruan tinggi. Kalau kita mau daftar kuliah, biasanya kita cari tahu akreditasi kampus yang kita tuju. Semakin tinggi akreditasinya, semakin tinggi ekspektasi kita terhadap kualitas perguruan tinggi tersebut. <a href="http://ban-pt.kemdiknas.go.id/">Akreditasi perguruan tinggi</a> <a href="http://ban-pt.kemdiknas.go.id/index.php?option=com_content&amp;view=article&amp;id=57&amp;Itemid=63&amp;lang=in">ditentukan oleh banyak hal</a>, diantaranya :</p>

<ul>
<li>berapa jumlah dosen yang S3</li>
<li>berapa karya ilmiah dan penelitian yang dihasilkan dalam satu periode</li>
<li>dsb</li>
</ul>


<p>Untuk menentukan suatu kampus mendapat level A, B, atau lainnya, maka ada tim assessor yang akan memeriksa apakah kampus tersebut sudah memenuhi apa yang dipersyaratkan.</p>

<p>Demikian juga dengan CMMI, berisi seperangkat checklist yang bentuknya kira-kira seperti ini:</p>

<table>
<thead>
<tr>
<th></th>
<th> Level  </th>
<th> Process Area </th>
<th> OK </th>
<th> Not OK </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>   2    </td>
<td> REQM         </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PP           </td>
<td> v  </td>
<td></td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> PMC          </td>
<td>    </td>
<td>   v</td>
</tr>
<tr>
<td></td>
<td>   2    </td>
<td> MA           </td>
<td>    </td>
<td>   v</td>
</tr>
</tbody>
</table>


<p>Nah, checklist itu nanti akan dicentang sesuai dengan kapabilitas perusahaan yang diperiksa.</p>

<p>Adapun urusan Scrum, Waterfall, XP, whatever metodologi yang kita gunakan,
hanyalah mencakup sebagian saja dari CMMI.</p>

<p>CMMI itu model untuk menggambarkan organisasi pembuat software yang mature. Apa itu mature? Salah satu karakteristiknya adalah konsistensi. Perusahaan yang gak mature, hasil kerjanya gak konsisten. Project A ontime, Project B molor 3 tahun. Project X bugnya dikit, Project Y isinya bug doang gak ada fiturnya.</p>

<p>Kalau kita bisa mengeksekusi project dengan sukses, kita hanya bisa lulus CMMI level 2. Untuk bisa mendapatkan level 3, kita harus bisa mengeksekusi project dengan sukses <strong>secara konsisten</strong>.
Untuk bisa konsisten, maka kita harus bisa menduplikasi project sukses ke seluruh perusahaan. Jadi, kalau kita sudah sukses pakai Scrum di project kita sekarang, tetap saja baru level 2. Hanya setelah kesuksesan Scrum bisa direplikasi di keseluruhan perusahaan, barulah bisa level 3.</p>

<p>Seperti juga halnya replikasi resep McDonalds ke seluruh cabang, untuk bisa mereplikasi project sukses ke seluruh perusahaan,
dibutuhkan kegiatan tambahan di level organisasi, misalnya :</p>

<ul>
<li>Menulis SOP (OPD)</li>
<li>Membuat program pelatihan internal (OT)</li>
<li>Selalu menganalisas prosedur yang sekarang berlaku, supaya bisa diimprove (OPF)</li>
</ul>


<p>Yang di dalam kurung adalah process area yang bersesuaian di CMMI.</p>

<p>Berurusan dengan perusahaan yang mature akan mengurangi resiko di client. Apa itu resiko?</p>

<p>Buat orang awam seperti kita, resiko adalah simply sekian persen kemungkinan adanya masalah di kemudian hari. Nah, ada perspektif finansial yang kita orang teknis biasanya gak kepikiran. Buat orang finance, persentase tersebut bisa diuangkan. Misalnya kita mau bikin aplikasi costnya 100 M, uangnya minjem ke bank. Karena pada dasarnya bank gak mau rugi, 100 M itu akan diasuransikan sama dia. Jadi kalo projectnya bubaran, kita gak sanggup bayar, hutangnya akan ditalangin sama asuransi.</p>

<p>Asuransi akan lihat, kita pakai vendor siapa. Kalo vendornya gak mature (baca: resiko tinggi) maka premi asuransinya akan tinggi. Akibatnya, biaya pinjaman kita (cost of money) juga tinggi.</p>

<p>Bisa aja kita bayar 100 M (pokok) + 20 M (bunga) + 20 M (asuransi). Padahal kalo vendornya mature, premi asuransinya cuma 5 M. Nah, jadi urusan resiko dan maturity ini bukan semata jargon2 aja, tapi ada duit beneran yang tersangkut di dalamnya.</p>

<p>Demikianlah mitos pertama, CMMI bukan metodologi manajemen proyek, melainkan manajemen keseluruhan perusahaan.</p>

<h2>CMMI mewajibkan kita bikin banyak dokumen</h2>

<p>CMMI sama sekali tidak mengharuskan kita bikin dokumen apa-apa.</p>

<p>Yang ada, kita harus :</p>

<ul>
<li><strong>melakukan</strong> project planning (level 2)</li>
<li><strong>melakukan</strong> project monitoring &amp; control (level 2)</li>
<li><strong>mendefinisikan</strong> project life cycle : bisa waterfall, scrum, spiral, cowboy programming juga boleh</li>
</ul>


<p>Berikut beberapa definisi singkat</p>

<ul>
<li>Planning : merencanakan apa yang akan dilakukan</li>
<li>Monitoring : melihat kondisi aktual, apakah sesuai dengan plan</li>
<li>Control : melakukan tindakan kalau kondisi aktual tidak sesuai dengan plan</li>
</ul>


<p>Nah, kita harus membuktikan bahwa kita benar2 melakukan apa yang disuruh. Gimana cara membuktikannya?</p>

<p>Kita bisa :</p>

<ol>
<li>Tunjukkan dokumen hardcopy, atau</li>
<li>Tunjukkan bahwa kita melakukan planning, monitoring, dan control di aplikasi yang kita pakai (Redmine, planningpoker.com, pivotaltracker.com, basecamphq.com, fogbugz, whatever)</li>
</ol>


<p>Nah, dari 2 cara di atas, kalo kita <strong>benar-benar</strong> melakukan, akan lebih mudah menunjukkan yang #2. Tapi kalo akal2an, sebenarnya gak planning tapi mau ngakunya planning, akan lebih mudah memalsukan yang #1. Soalnya #2 gak bisa di-back-dated, sedangkan #1 bisa.</p>

<p>Jadi, fokusnya lebih ke <strong>melakukan proses</strong>, bukan <strong>membuat dokumen</strong></p>

<p>Kemudian, ada kesalah-kaprahan juga yang umum terjadi tentang planning. Planning itu tidak sekali saja lalu dipakai sepanjang project. Project plan harus mencerminkan kondisi yang terbaru dari project. Misalnya, kita bikin plan awal (versi 1) selesai 3 bulan. Ternyata waktu monitoring di akhir bulan 1, kita udah tau bahwa gak bakalan selesai dalam 2 bulan sisanya. Kita harus melakukan controlling terhadap projectnya. Tindakan control bisa macam2, bisa kita tambah orang biar tetap selesai dalam 3 bulan, bisa juga revisi plannya sehingga mencerminkan kondisi setelah 1 bulan berjalan.</p>

<p>UUD 45 aja bisa diamandemen, masa project plan gak bisa :D</p>

<p>Contoh lain, mengelola requirement (Requirement Management), Level 2.</p>

<p><blockquote><p>S.P 1.1 : Understand Requirement : kita harus memastikan bahwa requirement dipahami.</p></blockquote></p>

<p>Gimana cara membuktikannya?</p>

<p>Kalo prosesnya benar-benar dijalankan, kita bisa tunjukkan email dari BA ke Client yang isinya mengkonfirmasi pemahaman BA tentang requirement yang diminta Client.</p>

<p>Atau kalo seperti Scrum, Clientnya hadir di ruangan yang sama, gak nyatet apa2, rekaman audio juga boleh. Intinya, ada sesuatu yang bisa ditunjukkan ke auditor bahwa kita sudah Understanding Requirement.</p>

<p>Kalo prosesnya palsu, artinya sebenarnya gak dilakukan, tapi mau lulus Level 2, maka dibuatlah dokumen palsu. Bentuknya biasanya review report, isinya item2 requirement, lalu nanti ada tandatangan client palsu.</p>

<p>So, overhead dokumen (mis: review report) itu ada kalo kita memalsukan proses.</p>

<p>Selama kita benar-benar menjalankan apa yang disuruh, pasti ada evidence bahwa kita menjalankan, entah itu bentuknya chat YM, email, Skype call, apalah terserah, tidak ada CMMI mewajibkan formatnya harus mp3 atau apa.</p>

<p><blockquote><p>SP 1.2 : Obtain Commitment to Requirement : semua pihak harus commit terhadap requirement yang sudah dibuat.</p></blockquote></p>

<p>Gimana cara membuktikan bahwa kita comply dengan SP ini?</p>

<p>Paling gampang, BA kirim email ke Client, "Pak, di iterasi ini, kita kerjakan req #12, #14, sama #15 ya. #13 pending dulu aja"</p>

<p>Client reply, "Ok"</p>

<p>That's it, tunjukkan emailnya ke auditor, beres.</p>

<p>Kalau proses ini tidak dijalankan, akan menimbulkan masalah di kemudian hari. Usernya client bilang A, bosnya user bilang A+, programmer bilang C, PM bilang lain lagi. Sekali lagi, selama prosesnya dilakukan, emailnya pasti ada.</p>

<p>Kalo prosesnya palsu, atau clientnya gaptek gak kenal email, ya dibuatlah dokumen requirement sign off. Orang2 tandatangan. Dokumennya dijadikan evidence.</p>

<p><blockquote><p>SP 1.3 : Manage Requirement Changes : kalo requirement berubah, harus di-manage.</p></blockquote></p>

<p>Apa itu dimanage?</p>

<p>Dimanage artinya harus jelas :
- apa yang berubah
- siapa yang minta berubah
- siapa yang approve
- apa impactnya ke schedule/cost/effort/cuaca hari ini</p>

<p>Apa buktinya? Email boleh, chat log boleh, rekaman cctv boleh.</p>

<p>Ok, lalu kenapa semua harus ada evidence ??</p>

<p>Berikut joke dari auditor kita dulu,</p>

<p><blockquote><p>In God We Trust, everybody else brings data.</p></blockquote></p>

<p>Jadi, CMMI = banyak dokumen hanyalah mitos belaka. Untuk bisa melakukan verifikasi, auditor tentu butuh melihat evidence. Di jaman modern seperti sekarang, evidence bentuknya tidak harus dokumen tertulis yang dibuat dengan aplikasi office.</p>
]]></content>
  </entry>
  
</feed>
