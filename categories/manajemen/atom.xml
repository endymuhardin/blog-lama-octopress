<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: manajemen | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/manajemen/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2014-10-14T22:36:24+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Waterfall is The Best]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/waterfall-is-the-best/"/>
    <updated>2014-10-14T20:45:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/waterfall-is-the-best</id>
    <content type="html"><![CDATA[<p>Di berbagai komunitas Agile, metodologi waterfall merupakan bulan-bulanan dan wajib untuk dibully. Jangankan bilang waterfall itu bagus, coba katakan <code>Ada beberapa situasi di mana waterfall bisa dijalankan</code>. Saya jamin 1000% Anda akan segera dibully seperti layaknya pendukung Justin Bieber hadir di konser Metallica.</p>

<p>Kalau ada satu hal penting yang saya dapatkan dari belasan tahun berkecimpung di dunia IT adalah ini</p>

<blockquote><p>Banyak jargon, metodologi, framework, library, teknologi datang dan pergi setiap saat. Untuk tiap pilihan yang kita buat, ada biaya yang menyertainya. Yaitu waktu dan tenaga yang kita investasikan untuk mempelajari dan mengadopsi pilihan tersebut. Kunci agar kita bisa memilih hal yang tepat sehingga imbal hasil pilihan kita lebih besar dari biayanya adalah, gunakan akal sehat dan jangan gampang terbuai jargon dan marketing gimmick.</p></blockquote>

<p>Prinsip akal sehat tersebut telah menyelamatkan saya dari berbagai teknologi gagal di masa lalu seperti misalnya:</p>

<ul>
<li>Struts 1</li>
<li>EJB 1 dan 2</li>
<li>XA Transaction</li>
<li>JMS</li>
<li>dan lain sebagainya</li>
</ul>


<p>Teknologi gagal bukan artinya teknologi tersebut tidak inovatif atau kurang canggih. Tapi biaya implementasinya jauh melebihi benefit yang diperoleh darinya.</p>

<p>Nah, kali ini dimana orang-orang 'agile' sibuk membully Waterfall, saya punya pendapat yang berbeda.</p>

<blockquote><p>Waterfall justru adalah cara paling alami untuk membuat software</p></blockquote>

<p>Wah kok bisa begitu?</p>

<!--more-->


<p>Sebelum kita bahas lebih lanjut, kita jelaskan dulu. Apa itu waterfall?</p>

<p>Yang senang nonton Youtube, silahkan langsung simak video berikut</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/X1c2--sP3o0" allowfullscreen></iframe></div></p>

<p>Buat yang gak paham bahasa bule, baiklah saya ceritakan saja.</p>

<p>Waterfall adalah siklus pembuatan aplikasi (software development lifecycle) yang diperkenalkan oleh Winston Royce pada tahun 1970. Siklus ini terdiri dari beberapa tahap yaitu:</p>

<ol>
<li>Requirement Specification</li>
<li>Design</li>
<li>Implementation (kita menyebutnya coding)</li>
<li>Testing</li>
<li>Production / Go Live / Operation (aplikasi dipakai di kehidupan nyata)</li>
</ol>


<p>Sekilas, siklus ini terlihat sederhana dan logis. Sehingga banyak orang langsung menganggapnya solusi terhebat.</p>

<p>Seperti segala macam hal di dunia ini, tidak ada yang sempurna. Semua hal ada plus minusnya, termasuk siklus waterfall. Ini sebetulnya sudah dijelaskan juga oleh Opa Winston. Tapi apa lacur, metodologi ini sudah terlanjur dijual oleh para konsultan manajemen sebagai obat kuat tanpa tandingan. Dan seperti dagangan konsultan manajemen lainnya, segera dibumbui dengan berbagai jargon, success story, dan marketing gimmick lainnya sehingga terlihat canggih, mampu mengatasi global warming, kelaparan di Afrika, mendatangkan perdamaian di Timur Tengah, bahkan menyembuhkan kanker dan AIDS.</p>

<p>Ironisnya, gerombolan konsultan manajemen ini pula yang sekarang membully waterfall habis-habisan.</p>

<p>Oke, cukup belajar sejarah, sekarang kita kembali ke akal sehat.</p>

<h2>Apa bagusnya waterfall ?</h2>

<p>Sebetulnya, siklus waterfall merupakan hukum alam dalam pembuatan software. Membantah waterfall sama saja dengan mengatakan air mengalir ke atas.</p>

<p>Tidak percaya? Mari kita telusuri satu per satu</p>

<h3>Requirement Specification</h3>

<p>Coba sekarang saya ketemu Anda, trus saya bilang</p>

<blockquote><p>Ayo mulai coding !!</p></blockquote>

<p>Apakah Anda bisa mulai coding? Tentu tidak bisa. Mau coding apa? Aplikasi perpustakaan? Aplikasi payroll? Social media? Kan harus ditentukan dulu.</p>

<p>Oke, saya kasi petunjuk. Aplikasi social media. Apakah sekarang bisa mulai coding?</p>

<p>Tentu belum. Social media seperti apa? Relationship-based (ala facebook), location-based (ala foursquare), photo-based (ala flickr dan instagram), atau apa?</p>

<blockquote><p>Oh ternyata perlu dijelaskan ya apa yang mau dibuat?</p></blockquote>

<p>Nah ini namanya fase requirement specification.</p>

<p>Beberapa orang akan langsung komentar.</p>

<blockquote><p>Wah, bikin dokumen tebel dong. Apa dibaca? Kalau ada perubahan gimana? Apakah ada business valuenya?</p></blockquote>

<p>Ini mitos. Spesifikasi requirement gak harus berupa dokumen 300 halaman. Bisa berupa <a href="http://software.endy.muhardin.com/manajemen/prototyping/">UI Mockup</a>.</p>

<p>Justru intinya proses requirement adalah supaya user bisa menjelaskan maksudnya pada programmer. Kalau ternyata tidak ditangkap dengan baik, ya tentu penjelasannya harus diperbaiki sampai kedua pihak benar-benar sepaham.</p>

<blockquote><p>Apakah selalu harus melalui proses requirement?</p></blockquote>

<p>Tidak harus, kalau softwarenya kita buat sendiri untuk dipakai sendiri. Misalnya saya mau buka toko, butuh aplikasi. Lalu saya coding sendiri. Dalam kasus ini, tidak perlu proses requirement. Nanti dikira gila, masa programmernya (saya) minta dijelaskan sama usernya (saya juga)?</p>

<p>Tapi pada kenyataannya, user dan programmer biasanya beda orang. Jadi ya tentu harus dijelaskan dong.</p>

<p>Jadi, ternyata Opa Winston benar. Sebelum coding ya requirement dulu dong. Wajib hukumnya. Gak ada requirement, gak bisa mulai coding. Setelah selesai coding, masa iya perlu requirement?</p>

<h3>Design</h3>

<blockquote><p>Apakah wajib melakukan proses desain?</p></blockquote>

<p>Tergantung dua hal:</p>

<ol>
<li>Seberapa kompleks aplikasi yang dibuat?</li>
<li>Berapa orang yang terlibat?</li>
</ol>


<p>Untuk aplikasi 2-3 tabel database, kalau saya kerjakan sendiri, biasanya saya langsung coding. Sebenarnya ada juga saya merenungkan skema database dan mau ditaruh di class mana method dan property. Tapi karena saya sendiri yang coding, tabelnya juga cuma sedikit, yang terlihat dari luar ya saya langsung mengetik kode program.</p>

<p>Kalau aplikasinya besar, tidak mungkin semua saya simpan di kepala sendiri. Harus saya tulis. Selain itu, bikin software mirip main catur. Satu langkah bidak harus kita hitung konsekuensinya beberapa langkah ke depan. Pilih teknologi apa, desktop atau web, berapa layer, berapa modul, bagaimana integrasi antar modul, dan sebagainya. Proses mengidentifikasi alternatif solusi, kemudian memilih salah satunya, ini disebut desain aplikasi.</p>

<p>Contoh kasus, salah satu produk ArtiVisi adalah aplikasi pembayaran tagihan. Aplikasi tersebut bisa melunasi tagihan listrik, telepon, cicilan, beli pulsa listrik, pulsa handphone, dan sebagainya. Jenis produk datang dan pergi. Format cetakan struk berubah-ubah sesuai ketentuan bank. Nah tentu kita harus pikirkan bagaimana supaya aplikasinya mudah beradaptasi kalau ada produk baru, perubahan cetakan struk, dan berbagai perkembangan bisnis lainnya. Segala hal ini namanya proses desain software.</p>

<blockquote><p>Faktor kedua, siapa yang akan coding?</p></blockquote>

<p>Masa saya semua? Kalau saya yang coding semua kapan lagi saya sempat menulis blog untuk Anda semua :D Belum lagi jadwal <a href="https://www.youtube.com/watch?v=A3sM9ePaBvw&amp;list=PL9oC_cq7OYbxjvQd8_isrxi8RxVmHXjZJ">syuting Youtube</a>. Asal tau saja, jadi seleb internet cukup menyita waktu :P</p>

<p>Oke, jadi perlu dibantu orang lain untuk coding. Dengan demikian saya perlu jelaskan di mana harus menaruh template struk, bagaimana skema database, dan berbagai hal lainnya. Sekarang saya wajib membuat dokumen desain.</p>

<blockquote><p>Kenapa gak dijelaskan aja desainnya? Repot-repot bikin dokumen, nanti juga berubah lagi.</p></blockquote>

<p>Mendingan mana, saya tulis sekali dengan resiko bakalan berubah, atau gak saya tulis trus programmernya cuti/sakit/resign/melahirkan dan saya harus jelaskan lagi setiap kali ganti orang?</p>

<p>Oke Opa Winston, saya harus desain dan bikin dokumennya. Kecuali aplikasinya buat saya, yang desain saya, yang coding saya, yang mau pake saya juga.</p>

<p>Kapan kita bisa desain? Tentu setelah requirement. Dan juga pastinya sebelum coding.</p>

<blockquote><p>Apakah desain bisa tidak dikerjakan?</p></blockquote>

<p>Bisa saja langsung coding. Tapi gini, semua programmer yang pernah <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">bikin aplikasi production</a> pasti tau fakta ini</p>

<blockquote><p>Aplikasi production tidak sekedar semua fitur ada. Tapi juga siap dideploy di berbagai environment, kebal menerima data invalid, punya pesan error yang informatif, performancenya acceptable, bisa menangani load tinggi, aman dari berbagai serangan, mudah dimaintenance (backup, archive, offline, monitoring), dan berbagai hal lainnya.</p></blockquote>

<p>Artinya untuk tiap fitur, kita harus :</p>

<ul>
<li>tes</li>
<li>buatkan validasinya</li>
<li>buatkan pesan errornya</li>
<li>buatkan log file yang bagus</li>
<li>ukur performancenya</li>
<li>lihat apa yang terjadi kalau dihajar request tinggi</li>
<li>dsb</li>
</ul>


<blockquote><p>Bagaimana kalau kita sudah implement semua kebutuhan aplikasi production, ternyata kita baru sadar bahwa skema database kita kurang optimal?</p></blockquote>

<p>Nah, selamat bekerja mengulang semua kelengkapan production di atas :D</p>

<blockquote><p>Ampun Opa Winston. Anda benar, requirement dulu, trus desain, baru deh coding. Untuk testing, jangan diomelin lagi, saya udah baca <a href="https://www.google.com/search?q=site%3Asoftware.endy.muhardin.com&amp;q=ruthless+testing&amp;gws_rd=ssl">serial ruthless testing di blog Om Endy</a>.</p></blockquote>

<p>Lalu, kalau si Opa benar, kenapa waterfall dibully?</p>

<h2>Kesalahan dalam implementasi Waterfall</h2>

<p>Sebenarnya Opa Winston juga sudah menjelaskan bahwa ada resiko dalam penggunaan waterfall. Ini juga sudah dibahas Agan Steve McConnell dalam bukunya Rapid Development. Singkatnya kira-kira begini</p>

<blockquote><p>Jangan gunakan waterfall satu siklus kalau projectnya besar.</p></blockquote>

<p>Jadi kalau misalnya kita bikin aplikasi ERP, terdiri dari modul akunting, procurement, inventory, manufacture, sales, tax, dan lain sebagainya, jangan dikerjakan sekali pukul satu kali requirement satu kali desain, satu kali coding.</p>

<p>Kenapa gak boleh sekali pukul? Karena aplikasinya sangat besar, requirementnya bisa makan waktu 4 bulan. Nanti desainnya 2 bulan lagi. Total sudah 6 bulan dan belum juga mulai menginstall Netbeans.</p>

<p>Di pertengahan tahun biasanya manajemen rapat untuk evaluasi bisnis. Ternyata sales gak masuk target. Ada revisi program penjualan, tadinya minta diskon harus ke direktur, sekarang cukup ke kepala cabang.</p>

<p>Nah, belum sempat nulis <code>Hello World</code>, requirement sudah berubah. Revisi requirement, revisi desain, makan waktu 3 bulan. Menjelang akhir tahun, manajemen rapat lagi, proses bisnis berubah lagi. Trus kapan kita mau mulai coding <code>Hello World</code>?</p>

<p>Fenomena seperti ini yang bikin waterfall dibully. Padahal balik ke premis awal, ya akal sehat dipakai dong. Masa 6 bulan dokumentasi doang belum nulis kode program satu barispun? Emangnya situ programmer atau pegawai kelurahan?</p>

<blockquote><p>Bagaimana solusinya?</p></blockquote>

<p>Ini sebetulnya juga sudah dijelaskan oleh Opa Winston. Ya di tahun 1970 itu juga barengan sambil menjelaskan waterfall. Agan Steve juga udah menjelaskan di <a href="http://www.stevemcconnell.com/rdcntnt.htm">Rapid Development</a>. Yang optimal itu begini</p>

<blockquote><p>Requirement menyeluruh dilakukan terhadap seluruh aplikasi, tapi global saja. Tujuannya supaya bisa membagi modul-modul dan mendapatkan gambaran bagaimana nanti integrasinya. Setelah itu, bagi per modul. Tiap modul lakukan mini-waterfall sampai selesai modul per modul. Nanti tiap beberapa modul selesai, ada lagi iterasi untuk proses integrasi antar modul.</p></blockquote>

<p>Cara seperti ini oleh Agan Steve disebut dengan siklus <code>Staged Delivery</code>. Walaupun namanya keren dan terlihat beda, tapi ya sebenarnya menurut saya ini sama saja dengan <code>Waterfall dengan Akal Sehat</code>. Yaitu memecah aplikasi besar menjadi modul-modul, dimana masing-masing modul dikerjakan dengan waterfall juga. Dan tidak ada juga yang melarang modul-modul ini dikerjakan secara paralel.</p>

<p>Bahkan Agan Steve bilang, gak semuanya harus dibikin sendiri. Kalau misalnya aplikasi akunting udah ada yang jual (Commercial Off The Self - COTS) ya beli aja daripada ribet-ribet bikin sendiri. Malahan ada beberapa perusahaan yang kerjanya beli-beli doang, digabungin, trus dijual. Sampai sempat-sempatnya dia bikin nama keren buat dirinya sendiri, yaitu <code>System Integrator</code>.</p>

<h2>Kesimpulan</h2>

<p>Di dunia IT, banyak sekali pilihan. Mulai dari bahasa pemrograman, framework, metodologi, macam-macam. Kita harus pintar-pintar memilih dan tidak gampang terbuai bujuk rayu konsultan. Caranya gampang saja, gunakan akal sehat.</p>

<p>Jadi kalau lain kali ada yang menganjurkan dua programmer komputernya satu aja gantian, renungkan dengan akal sehat. Apakah gak sebaiknya sekalian dibeliin perlengkapan fitness? Jadi pas project selesai, programmernya punya perut sixpack.</p>

<p><img src="https://lh3.googleusercontent.com/-kWEJAXJQqiY/U01NMQkQ7_I/AAAAAAAAFp0/099uScfrhP0/w768-h576-no/rambo-wallpaper-800x600.jpg"></p>

<p><em>Fotonya Rambo diambil <a href="http://wallpaperswide.com/rambo-wallpapers.html">dari sini</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Belajar Project Management dari Ubuntu]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/belajar-project-management-dari-ubuntu/"/>
    <updated>2014-08-30T23:49:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/belajar-project-management-dari-ubuntu</id>
    <content type="html"><![CDATA[<p>Hampir seluruh aktivitas yang saya lakukan dengan komputer (smartphone juga termasuk komputer) menggunakan aplikasi open source. Jaman sekarang, aplikasi open source sudah jauh mengungguli aplikasi closed source baik dalam hal fitur, user-friendliness, reliability, dan kecepatan development (bug fix, fitur baru, enhancement, dan sebagainya).</p>

<p>Selama ini kita hanya tahu pakai saja. Download, instal, pakai, happy. Kita juga hanya tahu bahwa open source = kode programnya bisa dilihat, dimodifikasi, dan dibagikan ke siapa saja. Sebenarnya ada aspek lain dari open source yang juga menarik, penting, dan banyak sekali manfaatnya buat para pembaca blog saya yang utamanya adalah programmer, software project manager, dan juga pengusaha di sektor IT. Aspek tersebut adalah software development process yang terjadi sehingga semua produk canggih ini bisa berada di tangan kita saat ini.</p>

<p>Kehandalan manajemen proyek open source bisa kita lihat bukti nyatanya di distro linux Ubuntu. Coba lihat beberapa fakta berikut:</p>

<ul>
<li>Ubuntu rilis setiap enam bulan sekali, yaitu tiap bulan April dan Oktober.</li>
<li>Sejak rilis pertama, belum pernah terjadi keterlambatan rilis.</li>
<li>Kontributor Ubuntu (programmer, pembuat dokumentasi, desain tampilan, tukang burn CD, tukang update website, tukang upload iso, admin server, dsb) datang dari seluruh dunia. Bekerja 24 jam sehari 7 hari seminggu dengan timezone yang berbeda-beda. Jadi kalau kita masih kerja di ruangan yang sama, hanya dipisahkan <em>cubicle</em> saja, datang bareng, makan siang bareng, pulang bareng, sebaiknya jangan terlalu sering mengeluh di socmed ;p</li>
<li>Jumlah kontributornya ribuan orang. Bahasanya berbeda-beda. Lokasinya juga berbeda-beda.</li>
<li>Tulang punggung Ubuntu adalah kernel Linux dan desktop manager Gnome. Harus menunggu Gnome rilis dulu, baru Ubuntu bisa dikerjakan. Jangan sampai di tengah-tengah development Ubuntu, ada perubahan signifikan yang terjadi di Gnome sehingga Ubuntu harus rombak total.</li>
<li>Ubuntu basisnya adalah distro Debian varian unstable. Proses development harus memperhatikan agar jangan sampai menyimpang terlalu jauh dari Debian supaya tetap bisa sinkronisasi pada saat Debian naik versi.</li>
<li>Ubuntu digunakan orang dari seluruh dunia, sehingga harus bisa mendukung berbagai bahasa, format angka, format tanggal, dan berbagai variasi lainnya.</li>
<li><a href="http://software.endy.muhardin.com/manajemen/release-management/">Kompatibilitas antar rilis</a> harus terjaga, supaya orang bisa <a href="http://software.endy.muhardin.com/linux/upgrade-ubuntu/">upgrade dengan mudah</a>.</li>
</ul>


<blockquote><p>Nah, apa rahasianya supaya bisa seperti itu?</p></blockquote>

<!--more-->


<p>Oh ternyata tidak rahasia, karena semua tahapnya dijelaskan <a href="https://wiki.ubuntu.com/UbuntuDevelopment/ReleaseProcess">di sini</a>. Ya namanya juga dibuat oleh orang seluruh dunia. Tentu saja tidak ada yang rahasia di sini. Ini namanya rahasia umum :D</p>

<p>Ubuntu menggunakan skema <a href="https://wiki.ubuntu.com/TimeBasedReleases">Time Based Release</a>. Skema ini juga digunakan banyak project open source lain, misalnya <a href="https://wiki.gnome.org/ReleasePlanning/TimeBased">Gnome</a>.</p>

<p>Proses development Ubuntu dimulai dari issue tracker, di mana semua user (dari seluruh dunia) menginputkan bug report dan feature request. Semua request ini kemudian akan divoting oleh sesama user untuk menunjukkan seberapa banyak orang yang membutuhkan request tersebut. Request populer tentu ratingnya akan naik. Untuk request fitur baru dibuatkan <a href="https://wiki.ubuntu.com/FeatureSpecifications">spesifikasinya</a>.</p>

<p>Selanjutnya, Canonical mengadakan <a href="http://uds.ubuntu.com/agenda/">Ubuntu Developer Summit</a>. Pesertanya ada yang datang secara fisik, ada juga yang ikutan secara remote. Eventnya terbuka untuk umum dan <a href="http://www.jonobacon.org/2014/02/11/the-next-ubuntu-developer-summit-11-13-march-2014/">semua sesi direkam sehingga semua orang tahu proses pengambilan keputusan yang terjadi</a>.</p>

<p>UDS ini akan menghasilkan gambaran umum fitur apa saja yang akan dibuat, bagaimana skala prioritasnya, dan apa saja kira-kira pekerjaan yang harus dilakukan. Output dari UDS dapat kita lihat contohnya di <a href="https://blueprints.launchpad.net/ubuntu/karmic/+specs">blueprint rilis Karmic</a>.</p>

<p>Tahap selanjutnya adalah coding/development. Semua kontributor bekerja membuat fitur sesuai wilayah masing-masing. Ini dilakukan sampai terjadi freeze (stop penambahan fitur). Ada macam-macam freeze, misalnya:</p>

<ul>
<li><a href="https://wiki.ubuntu.com/FeatureFreeze">Feature Freeze</a> : berhenti menambahkan fitur baru</li>
<li><a href="https://wiki.ubuntu.com/UserInterfaceFreeze">User Interface Freeze</a> : berhenti mengubah tampilan, supaya bisa mulai membuat user manual / dokumentasi aplikasi</li>
<li><a href="https://wiki.ubuntu.com/DocumentationStringFreeze">Documentation String Freeze</a> : berhenti mengubah tulisan di dokumentasi aplikasi utama yang berbahasa Inggris, supaya bisa mulai diterjemahkan ke berbagai bahasa</li>
</ul>


<p>Setelah penambahan fitur berhenti, semua orang berkonsentrasi fixing bug, tuning performance, refactoring, membuat dokumentasi, dan kegiatan beres-beres lainnya untuk <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">mengubah barang prakarya menjadi barang production</a>. Ada beberapa milestone di sini yang menunjukkan tingkat kematangan produk, yaitu Alpha, Beta, Release Candidate, sampai akhirnya Stable Release. Proses coding dan testing di berbagai milestone yang biasa kita lakukan di ArtiVisi bisa dibaca <a href="http://software.endy.muhardin.com/java/staged-deployment/">di sini</a>.</p>

<p>Setelah stable release, kembali ke awal proses, yaitu issue tracker.</p>

<p>Simak juga <a href="http://www.ubuntu-user.com/Online/Blogs/Amber-Graner-You-in-Ubuntu/Interview-Kate-Stewart-Ubuntu-Release-Manager-at-Canonical">penjelasan Kate Stewart, Release Manager Ubuntu dari Canonical</a>.</p>

<p>Nah, demikianlah proses yang terjadi di dalam dapur Ubuntu. Sebagai bahan perbandingan, kita juga bisa menyimak skema project management yang terjadi di berbagai project open source lain, misalnya:</p>

<ul>
<li><a href="http://wiki.eclipse.org/SimRel/Overview">Eclipse</a></li>
<li><a href="https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt">Git</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/development-process/2.Process">Linux Kernel</a>, untuk yang butuh penjelasan dengan diagram bisa <a href="http://techblog.aasisvinayak.com/linux-kernel-development-process-how-it-works/">baca ini</a></li>
<li><a href="https://source.android.com/source/code-lines.html">Android OS</a></li>
<li>masih banyak lagi, silahkan google sendiri</li>
</ul>


<p>Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Capacity Planning]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/capacity-planning/"/>
    <updated>2014-08-19T17:48:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/capacity-planning</id>
    <content type="html"><![CDATA[<p>Ada pertanyaan bagus di milis IT Project Management, sebagai berikut</p>

<blockquote><p>Mohon di-share caranya menentukan spesifikasi minimal hardware yang dibutuhkan sebuah sistem.
contoh <a href="http://en.wikipedia.org/wiki/System_requirements">http://en.wikipedia.org/wiki/System_requirements</a>
Kriteria apa saja yang digunakan dalam memilih hardware? Terutama menentukan jumlah RAM dan Speed Processor nya. Apakah cukup dari jumlah concurrent user? Atau menggunakan metode trial-and-error.
Kalaupun trial-and-error, tentunya ada standar yang digunakan sebagai benchmark awal ya kan? Bagaimana standar awal tersebut?</p></blockquote>

<p>Mari kita bahas</p>

<!--more-->


<p>Proses perencanaan seperti ini disebut dengan istilah Capacity Planning. Penjelasan lengkapnya bisa dibaca <a href="http://en.wikipedia.org/wiki/Capacity_planning">di Wikipedia</a>.</p>

<p>Pada intinya, proses Capacity Planning di dunia IT dilakukan untuk mengetahui perencanaan infrastruktur yang dibutuhkan agar sistem yang dibangun bisa bekerja dengan baik sesuai kebutuhannya. Ada beberapa metrik yang ingin dihasilkan dari proses ini, antara lain:</p>

<ul>
<li>kebutuhan hardware (berapa server, masing-masing prosesornya apa, memori berapa, harddisk berapa, dan sebagainya)</li>
<li>kebutuhan jaringan (berapa besar bandwidth, berapa IP public, berapa jalur redundan/backup, dan sebagainya)</li>
<li>kebutuhan tempat (berapa luas ruang server, apakah dibutuhkan lokasi sekunder untuk Disaster Recovery Center)</li>
<li>kebutuhan energi (berapa watt listriknya, berapa UPS, perlu genset atau tidak, dan sebagainya)</li>
</ul>


<h2>Data yang dibutuhkan</h2>

<p>Angka-angka di atas tentu tidak turun dari langit. Ada beberapa data yang kita butuhkan sebagai input, antara lain:</p>

<ul>
<li>proyeksi pertumbuhan kegiatan bisnis. Berapa user di tahun pertama, berapa user di tahun kedua, dan seterusnya</li>
<li>profil perilaku user. Apakah ramai di tanggal tertentu (misalnya aplikasi pembayaran tagihan)? Apakah ramai di bulan tertentu (misalnya aplikasi penjualan tiket pesawat)? Atau di hari tertentu (misalnya tiket bioskop)?</li>
<li>constraint yang harus dipenuhi secara bisnis. Berapa detik user boleh menunggu? Berapa banyak user yang diperbolehkan mengantri dalam sistem? Apakah boleh sistemnya down? Kalau boleh, berapa lama batas waktunya sampai dia harus aktif lagi?</li>
<li>profil perilaku aplikasi kita sendiri. Berapa besar data yang disimpan dalam disk untuk tiap user? Berapa besar data tersimpan untuk satu transaksi? Berapa besar data yang lewat di jaringan untuk satu transaksi? Bagaimana rinciannya, berapa byte antara database server ke application server, berapa byte antara application server ke perangkat yang digunakan user?</li>
</ul>


<h2>Cara Memperoleh Data</h2>

<p>Data-data ini bisa kita peroleh dengan berbagai cara, misalnya:</p>

<ul>
<li>proyeksi pertumbuhan bisa diminta dari divisi marketing. Mereka tentu punya target pasar yang nantinya kita konversi menjadi jumlah user.</li>
<li>profil perilaku user juga bisa diminta dari divisi marketing. Segmentasinya seperti apa (anak, remaja, atau dewasa; orang kota atau orang desa), demografinya bagaimana, sebaran geografisnya di mana saja, dan sebagainya.</li>
<li>constraint juga bisa diperoleh dari divisi bisnis / marketing. Seperti apa penawaran kompetitor, apakah mereka menjanjikan fitur tertentu yang diunggulkan, dan sebagainya.</li>
<li>data tentang aplikasi kita, tentu kita bisa kumpulkan sendiri. Deploy aplikasi kita di testing server, lalu lakukan functional dan stress test dengan tools seperti <a href="http://jmeter.apache.org/">JMeter</a>. Jalankan aplikasi, jalankan testing tools, dan kumpulkan datanya. Cara melakukan profiling bisa dibaca di <a href="http://software.endy.muhardin.com/programming/tuning-performance/">artikel saya tentang tuning performance</a></li>
</ul>


<p>Beberapa data yang bisa dikumpulkan dari cara ini misalnya:</p>

<h3>Storage</h3>

<ul>
<li>besar data yang digunakan oleh satu user aplikasi</li>
<li>besar data yang digunakan untuk masing-masing jenis transaksi bisnis (penjualan, pembelian, barang masuk, barang keluar, dan sebagainya)</li>
</ul>


<h3>Processing</h3>

<p>Processing di sini maksudnya, dengan prosesor dan RAM tertentu, berapa</p>

<ul>
<li>jumlah maksimal request yang bisa dihandle tanpa terjadi error (100% sukses)</li>
<li>jumlah maksimal request yang bisa dihandle dengan tingkat error yang bisa diterima (10% transaksi gagal)</li>
<li>waktu yang dibutuhkan untuk memproses masing-masing jenis request (login, entri transaksi, generate report, pencarian data, dsb)</li>
</ul>


<h3>Network</h3>

<ul>
<li>berapa byte yang ditransmisikan untuk masing-masing jenis request dan response</li>
<li>waktu yang dibutuhkan untuk transmisi dengan berbagai jenis koneksi (ADSL, leased line, fiber optik, GPRS, 3G, dsb)</li>
<li>waktu yang ditoleransi aplikasi sebelum request dinyatakan timeout</li>
</ul>


<p>Sampai di sini, kita sudah tahu output, dan juga sudah punya input. Tinggal diproses saja.</p>

<h2>Memproses Data</h2>

<p>Ada beberapa hal yang bisa kita analisa dari data di atas, yaitu:</p>

<ul>
<li>kebutuhan hardware</li>
<li>kebutuhan jaringan</li>
<li>skema deployment</li>
<li>kebutuhan infrastruktur pendukung</li>
</ul>


<h3>Kebutuhan Hardware</h3>

<p>Dari stress test yang kita lakukan, kita bisa tahu 2 hal:</p>

<ol>
<li>Spesifikasi hardware yang kita gunakan pada waktu test</li>
<li>Jumlah maksimal load yang bisa ditangani oleh hardware tersebut</li>
</ol>


<p>Sebagai ilustrasi, misalnya kita menggunakan server test dengan spesifikasi sebagai berikut:</p>

<ul>
<li>Prosesor Xeon Dual Core</li>
<li>RAM 8GB</li>
<li>SATA 120GB</li>
</ul>


<p>Bisa menangani load sebagai berikut</p>

<ul>
<li>1000 concurrent user</li>
<li>masing-masing user melakukan login, entri transaksi dua kali, melihat report, dan kemudian mengunduh laporan dalam format PDF</li>
</ul>


<p>Dan bisa menampung data untuk</p>

<ul>
<li>10.000 registered user</li>
<li>1.000.000 transaksi</li>
</ul>


<p>Perlu diperhatikan bahwa jumlah user yang bisa ditangani tentu berbeda tergantung kompleksitas aplikasinya. Jadi jangan bertanya di forum seperti ini</p>

<blockquote><p>Aplikasi saya kok boros resource ya? Padahal sudah pakai Xeon Dual Core dan RAM 8GB, tapi cuma bisa menghandle 1000 user?</p></blockquote>

<p>Pertanyaan di atas tidak bisa dijawab tanpa tahu persis isi perut aplikasinya. Hanya arsitek aplikasinya yang bisa menjawab, karena dia yang tahu apa bisnis proses yang dijalankan, apa teknologi yang digunakan, bagaimana teknik query database, bagaimana strategi caching, dan sebagainya. Bahkan mungkin saja angka 1000 user itu sudah merupakan prestasi yang luar biasa.</p>

<p>Jadi sebetulnya, dari proses test tersebut kita cuma butuh kesimpulan sebagai berikut</p>

<blockquote><p>Xeon Dual Core + RAM 8GB + Disk 120GB = 1000 concurrent user + 10.000 registered user + 1.000.000 transaksi</p></blockquote>

<p>Dari kesimpulan di atas, kita bisa interpolasi ke requirement dari sisi bisnis. Kalau bisnisnya ingin melayani 2000 concurrent user, 20.000 registered user, dan 2.000.000 transaksi, tentu kita harus beli minimal Xeon Quad Core, RAM 16GB, dan Disk 300GB.</p>

<p>Jangan lupa, selain spesifikasi minimal kita juga bisa mengeluarkan spesifikasi yang ideal / direkomendasikan. Soalnya bagian finance dan purchasing biasanya suka kalau mereka punya alternatif. Pastikan saja spesifikasi minimal yang kita berikan sudah mempunyai cadangan kapasitas. Biasanya saya berikan tiga level spesifikasi:</p>

<ul>
<li>minimal</li>
<li>rekomendasi</li>
<li>ideal</li>
</ul>


<p>Tentu saja sebenarnya sudah saya markup dari perhitungan sebenarnya, sehingga spesifikasi minimal sebenarnya adalah spesifikasi rekomendasi, spesifikasi rekomendasi sebenarnya adalah spesifikasi ideal, dan yang saya tulis sebagai spesifikasi ideal sebenarnya adalah spesifikasi <em>all you can eat</em>. Jangan heran kalau nanti isinya adalah <a href="http://en.wikipedia.org/wiki/NonStop">NonStop Server</a></p>

<h3>Skema Deployment</h3>

<p>Beberapa requirement bisnis menuntut skema deployment tertentu. Contohnya, kita mendapatkan requirement seperti ini</p>

<blockquote><p>Sistem harus berjalan dengan SLA 99.9%. Bila terjadi downtime, sistem cadangan harus aktif paling lambat dalam waktu 1 jam. Sistem cadangan harus menyimpan data transaksi minimal satu hari kerja sebelumnya.</p></blockquote>

<p>Requirement bisnis tersebut harus kita terjemahkan dulu menjadi angka yang bisa kita pahami secara teknis.</p>

<p>Pertama, kita <a href="http://www.joshualyman.com/2010/12/sla-uptime-guarantees-in-minutes-and-hours/">terjemahkan SLA tersebut</a>. Angka 99.9% artinya dalam setahun sistem cuma boleh mati maksimal 525.6 menit atau 8.76 jam. Perlu diperhatikan bahwa angka ini sudah termasuk proses terencana (scheduled downtime) seperti misalnya upgrade versi aplikasi, deployment karena fixing bug, ataupun server crash karena berbagai alasan.</p>

<p>Kedua, dari requirement di atas, kita bisa menyimpulkan adanya kebutuhan sistem cadangan. Sistem cadangan ini biasanya harus berjauhan dari sistem utama (geographic diversity).</p>

<p>Ketiga, dari waktu aktivasi sistem cadangan dan sinkronisasi data, kita dapat menentukan strategi replication antar kedua sistem. Delay data satu hari artinya kita bisa melakukan sinkronisasi data dengan file transfer biasa (FTP atau Rsync).</p>

<p>Aktivasi 1 jam artinya kita bisa menyimpan data dalam bentuk dump database karena waktu 1 jam memungkinkan kita untuk melakukan proses restore.</p>

<p>Bila data harus sinkron secara hampir real-time dan aktivasi di bawah 10 menit, maka kita harus mempertimbangkan strategi sinkronisasi yang berbeda (misalnya di level disk menggunakan DRBD).</p>

<h3>Kebutuhan Jaringan</h3>

<p>Lakukan logika yang sama untuk kebutuhan jaringan. Interpolasikan antara requirement bisnis dengan karakteristik aplikasi. Nanti kita akan dapatkan kesimpulan misalnya seperti ini:</p>

<ul>
<li>untuk menangani 2000 transaksi per detik</li>
<li>dibutuhkan koneksi uplink dengan bandwidth 1Mbps dengan maksimum delay 0.1ms</li>
</ul>


<p>Dengan contoh kasus di atas, setidaknya ada tiga segmen jaringan yang kita harus pikirkan:</p>

<ul>
<li>dari sistem utama / cadangan ke end user</li>
<li>dari sistem utama ke sistem cadangan (untuk keperluan sinkronisasi dan replikasi data)</li>
<li>di internal sistem (utama dan cadangan)</li>
</ul>


<p>Kebutuhan jaringan menuju end user dapat dikalkulasi dengan mengkombinasikan:</p>

<ul>
<li>jumlah concurrent user</li>
<li>apa yang dilakukan masing-masing user di aplikasi</li>
<li>besar data yang ditransmisikan untuk masing-masing aktifitas user</li>
</ul>


<p>Kebutuhan jaringan dari sistem utama ke sistem cadangan bisa dikalkulasi dengan mempertimbangkan:</p>

<ul>
<li>delay sinkronisasi data. Bila data harus sinkron secara real time, maka bandwidth harus besar dan delay harus kecil supaya data bisa ditransfer dengan lancar dan cepat</li>
<li>delay aktivasi sistem cadangan. Bila aktivasinya tidak harus cepat, kita bisa mentransfer data dalam bentuk dump yang membutuhkan proses restore sebelum sistem aktif. Tapi kalau aktivasi harus cepat, maka data harus ditransfer dalam bentuk yang lebih instan seperti byte-per-byte blok dalam disk. Ini butuh jaringan dengan spesifikasi yang tinggi</li>
</ul>


<p>Kebutuhan jaringan di internal sistem juga harus dipertimbangkan, terutama antara application server dan database server. Walaupun demikian, karena sifatnya jaringan internal, maka kita memiliki keleluasaan untuk memasang perangkat gigabit.</p>

<h3>Infrastruktur Pendukung</h3>

<p>Hasil perhitungan terhadap kebutuhan hardware, skema deployment, dan jaringan bisa kita gunakan untuk menghitung berapa ruangan, rak, listrik yang kita butuhkan untuk menjalankan sekian banyak server dan perangkat jaringan. Sesuai dengan requirement SLA, kita juga mungkin perlu menyewa lokasi kedua untuk sistem cadangan.</p>

<h2>Kesimpulan</h2>

<p>Singkatnya, untuk membuat Capacity Planning kita perlu mengetahui:</p>

<ul>
<li>requirement bisnis sekarang dan beberapa tahun ke depan</li>
<li>profil dan karakteristik aplikasi yang kita bangun</li>
</ul>


<p>Dengan data tersebut, kita bisa menghitung:</p>

<ul>
<li>apa saja perangkat yang dibutuhkan</li>
<li>berapa jumlah masing-masing perangkat</li>
<li>bagaimana spesifikasi masing-masing perangkat</li>
<li>apa saja infrastruktur untuk menjalankan semua perangkat tersebut</li>
<li>sampai kapan perangkat bisa digunakan</li>
<li>pada titik mana kita harus upgrade / menambah perangkat</li>
</ul>


<p>Demikianlah sekilas tentang Capacity Planning, semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tahapan Membuat Aplikasi]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/tahapan-membuat-aplikasi/"/>
    <updated>2014-04-22T23:51:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/tahapan-membuat-aplikasi</id>
    <content type="html"><![CDATA[<p>Seperti sudah dijelaskan pada <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">artikel sebelumnya</a>, anjuran saya buat mereka yang ingin mahir pemrograman adalah</p>

<blockquote><p>Buatlah aplikasi production barang 5-10 buah. Insya Allah setelah itu Anda akan mahir.</p></blockquote>

<p>Setelah kita menguasai dasar-dasar pemrograman seperti:</p>

<ul>
<li>konsep variabel dan tipe data</li>
<li>control flow (looping, branching, jumps)</li>
<li>pengelompokan (function, class, package)</li>
</ul>


<p>tidak serta merta kita bisa langsung membuat aplikasi. Analoginya, walaupun kita mahir menggunakan pengolah dokumen seperti MS Word atau Open Office, tidak berarti kita bisa menulis seri lanjutan dari <a href="http://en.wikipedia.org/wiki/Harry_Potter_and_the_Deathly_Hallows">Harry Potter and the Deathly Hallows</a>.</p>

<p>Inilah sebabnya banyak pemegang sertifikasi pemrograman seperti Oracle Certified Java Programmer yang tidak bisa membuat aplikasi, walaupun mendapatkan nilai yang tinggi.</p>

<p>Ada berbagai macam aplikasi, diantaranya:</p>

<ul>
<li>aplikasi bisnis, yaitu aplikasi yang membantu pencatatan kegiatan bisnis. Contohnya aplikasi akunting, purchasing, perpustakaan, mini-market, bank, payment gateway, dan sebagainya</li>
<li>aplikasi sistem, yaitu aplikasi yang memungkinkan berbagai perangkat bekerja sama. Contohnya sistem operasi, device driver, embedded system, dan lainnya</li>
<li>dan berbagai kategori aplikasi lainnya.</li>
</ul>


<p>Artikel kali ini akan kita batasi hanya untuk membahas aplikasi bisnis. Mengapa demikian? Karena aplikasi bisnis adalah genre aplikasi yang paling banyak dibuat orang. Sebagai ilustrasi, kita hanya mengenal beberapa sistem operasi populer, yaitu Microsoft Windows, Linux, MacOS. Bandingkan dengan aplikasi bisnis, untuk proses akuntansi saja berapa ribu aplikasi yang tersedia. Bahkan walaupun sudah ada yang gratis dan lengkap, tetap saja banyak perusahaan yang minta dibuatkan aplikasi sejenis. Jadi dari sisi komersial dan ketersediaan lapangan kerja, pembuatan aplikasi bisnis tetaplah pangsa pasar terbesar.</p>

<p>Pada artikel ini, kita akan membahas proses berpikir dan tahapan mulai dari penjabaran aplikasi yang akan dibuat, sampai menjadi skema database dan desain aplikasi berorientasi objek (object-oriented).</p>

<!--more-->


<p>Berikut adalah tahapan yang biasa saya lakukan dalam mengembangkan aplikasi:</p>

<ol>
<li>Membuat deskripsi aplikasi. Berisi penjelasan tentang apa fungsi utama dari aplikasi yang akan kita kembangkan. Tuliskan juga siapa saja user yang terlibat, dan garis besar dari proses bisnis yang akan disediakan oleh aplikasi.</li>
<li>Membuat daftar fitur</li>
<li>Untuk proyek komersial, daftar fitur ini akan kita terjemahkan menjadi estimasi biaya dan waktu. Bila Anda adalah programmer dan tidak berurusan dengan masalah finansial, silahkan skip langkah ini. Bila Anda ingin tahu lebih jauh, silahkan baca <a href="http://software.endy.muhardin.com/manajemen/estimasi-proyek-software/">artikel yang khusus membahas masalah estimasi ini</a>.</li>
<li>Membuat UI Mockup</li>
<li>Membuat skema database</li>
<li>Membuat daftar class dan relasi antar class</li>
<li>Membuat kerangka aplikasi dalam bentuk source code</li>
<li>Membuat detail implementasi source code sampai selesai</li>
<li>User Acceptance Test, baik internal maupun external (kalau ada client/customer yang akan mengetes)</li>
</ol>


<p>Agar lebih mudah dipahami, kita akan menggunakan studi kasus aplikasi perpustakaan. Kita pilih aplikasi ini karena semua orang sudah paham proses bisnisnya. Kalau saya pilih aplikasi seperti misalnya payment gateway, banking, gps tracking, dan aplikasi-aplikasi 'bergengsi' lainnya, saya khawatir proses bisnisnya tidak dipahami oleh mayoritas pembaca. Tidak semua orang paham apa yang terjadi pada saat nasabah membuka rekening bank.</p>

<p>Ok mari kita mulai.</p>

<h2>Penjelasan Aplikasi</h2>

<p>Penjelasan atau deskripsi aplikasi adalah hal terpenting dalam pembuatan aplikasi. Bila kita membuatnya dengan benar, maka pekerjaan kita di tahap selanjutnya akan mudah. Sebagaimana halnya semua skill yang lain, kemahiran kita dalam mengarang penjelasan aplikasi ini hanya bisa didapatkan dari latihan. Berikut contoh penjelasan aplikasi perpustakaan.</p>

<p>```
Aplikasi perpustakaan ini, sesuai namanya berguna
untuk mengelola kegiatan operasional perpustakaan.
Aplikasi ini akan digunakan oleh penjaga perpustakaan untuk:</p>

<ul>
<li>entri data anggota</li>
<li>entri data buku</li>
<li>entri peminjaman buku</li>
<li>entri pengembalian buku</li>
</ul>


<p>Selain itu, anggota juga bisa menggunakan aplikasi ini untuk:</p>

<ul>
<li>mencari buku dengan kriteria tertentu
(misalnya judul, pengarang, topik, dan sebagainya)</li>
<li>melihat ketersediaan buku</li>
<li>mengetahui lokasi penyimpanan buku</li>
<li>booking buku secara online dari rumah agar tidak kehabisan
```</li>
</ul>


<p>Dari penjelasan aplikasi di atas, kita bisa menentukan apa saja usernya dan apa saja fitur dari aplikasi yang akan kita buat. Mari kita lanjutkan ke tahap selanjutnya.</p>

<h2>Daftar Fitur</h2>

<p>Aplikasi bisnis (aplikasi yang dibuat untuk melayani operasional bisnis) biasanya memiliki fitur yang dapat diklasifikasikan menjadi beberapa kategori:</p>

<ul>
<li>master data : data referensi yang jarang berubah. Misalnya kelurahan, kode pos, tingkat pendidikan, dan lainnya. Untuk mengubah data master biasanya tidak ada proses bisnis khusus. User langsung saja membuka datanya, kemudian mengedit isinya, dan tekan tombol save.</li>
<li>transaksi : fitur pencatatan transaksi bisnis. Di sini biasanya ada berbagai aturan bisnis yang rumit seperti penambahan/pengurangan stok, perhitungan pajak, dan lain sebagainya</li>
<li>laporan : rekap dan aggregasi dari data transaksi. Umumnya ada fitur pencarian berdasarkan tanggal, jumlah total, dan sejenisnya. Biasanya juga ada fitur export ke berbagai format file (CSV, XLS, PDF)</li>
<li>personalisasi / konfigurasi : fitur untuk memudahkan user. Contohnya daftar menu favorit, mengganti email / no handphone, tema warna, dan lain sebagainya</li>
<li>utilitas / administrasi : fitur untuk pemeliharaan aplikasi. Misalnya backup/restore.</li>
</ul>


<p>Untuk membuat daftar fitur biasanya kita mulai dari fitur transaksi. Setelah itu, kita tentukan master data apa saja yang dibutuhkan tiap transaksi. Selanjutnya, laporan-laporan yang dapat dibuat dari berbagai transaksi. Terakhir baru kita identifikasi fitur personalisasi dan utilitas.</p>

<p>Berikut adalah daftar fitur aplikasi perpustakaan:</p>

<p>```
* Transaksi</p>

<pre><code>* Registrasi Anggota
* Berhenti jadi anggota
* Peminjaman
* Pengembalian
* Booking
* Buku baru (beli, hibah, dsb)
* Penghapusan buku (hilang, rusak, dsb)
</code></pre>

<ul>
<li><p>Master Data</p>

<ul>
<li>Buku</li>
<li>Anggota</li>
<li>User</li>
<li>Group</li>
<li>Permission</li>
</ul>
</li>
<li><p>Laporan</p>

<ul>
<li>Rekap Buku Masuk per Periode</li>
<li>Rekap Buku Dihapus per Periode</li>
<li>Rekap Peminjaman per Periode</li>
<li>Rekap Pengembalian per Periode</li>
<li>Histori Peminjaman dan Pengembalian per Anggota</li>
<li>Rekap Jumlah Buku</li>
<li>Rekap Anggota</li>
</ul>
</li>
<li><p>Personalisasi</p>

<ul>
<li>Ganti Password</li>
<li>Ganti Email</li>
<li>Ganti HP</li>
<li>Pengaturan Notifikasi</li>
</ul>
</li>
<li><p>Utilitas</p>

<ul>
<li>Backup</li>
<li>Restore</li>
<li>Import Data Anggota</li>
<li>Import Data Buku
```</li>
</ul>
</li>
</ul>


<p>Selanjutnya, berbekal daftar fitur di atas, kita bisa mulai membuat UI Mockup.</p>

<h2>UI Mockup</h2>

<p>UI Mockup merupakan solusi murah meriah dan cepat untuk sinkronisasi pemahaman kita dan pemahaman user tentang aplikasi yang akan dibuat. Kalau kita tidak membuat UI mockup, kesalah pahaman kita baru diketahui setelah aplikasinya selesai dibuat. Ini akan memboroskan waktu dan tenaga.</p>

<p>Sebagai gambaran, untuk membuat UI mockup, satu orang bisa menyelesaikan 1 screen dalam waktu 5 menit. Sedangkan untuk mengimplementasikan screen tersebut dalam aplikasi, belum tentu selesai dalam 5 hari. Padahal screen tersebut belum tentu sesuai dengan kebutuhan user. Kan sayang kalau sudah dicoding 5 hari ternyata salah.</p>

<p>Untuk membuat UI Mockup, kita dapat menggunakan aplikasi <a href="http://pencil.evolus.vn/">Pencil</a> yang gratis dan mudah digunakan. Aplikasi Pencil ini memiliki <a href="http://pencil.evolus.vn/Stencils-Templates.html">berbagai template (stencil)</a> sesuai aplikasi yang akan kita buat, misalnya aplikasi desktop Windows, aplikasi desktop Linux, aplikasi web, aplikasi Android, dan sebagainya.</p>

<p>Ada beberapa pola umum dalam membuat aplikasi bisnis, yaitu:</p>

<ul>
<li>tampilan list</li>
<li>form entri sederhana</li>
<li>form entri header-detail</li>
<li>lookup dialog</li>
</ul>


<p>Untuk menyederhanakan pembahasan, kita hanya akan buat sebagian kecil saja screen dari aplikasi perpustakaan. Soalnya kalau kita buat semua, bisa-bisa artikel ini jadi satu buku sendiri ;)</p>

<p>Berikut daftar screen yang akan kita buat:</p>

<ul>
<li>Entri Anggota</li>
<li>Entri Peminjaman</li>
<li>Histori Peminjaman per Anggota</li>
</ul>


<p>File Pencil dari UI Mockup di artikel ini bisa diunduh <a href="../../downloads/aplikasi-perpustakaan.ep">di sini</a></p>

<h3>Entri Anggota</h3>

<p>Berikut adalah tampilan screen entri anggota.</p>

<p><img src="https://lh4.googleusercontent.com/-1hcFb859pOI/U1acWK5Y8YI/AAAAAAAAFqw/KxhM_jXmybE/w771-h474-no/entri_anggota.png"></p>

<p>Ada beberapa hal yang harus kita perhatikan di sini, yaitu:</p>

<ul>
<li>validasi input harus dilakukan, baik di sisi server maupun di sisi client.</li>
<li>pesan error harus ditampilkan secara jelas</li>
</ul>


<p>Pembahasan detailnya sudah kita jabarkan di <a href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/">artikel sebelumnya</a>, jadi tidak perlu kita ulangi lagi di sini.</p>

<p>Form entri anggota ini termasuk form entri sederhana. Pola ini biasanya dipakai untuk entri data master, seperti misalnya:</p>

<ul>
<li>Form Entri Buku</li>
<li>Form Entri User</li>
<li>dan lainnya</li>
</ul>


<p>Selanjutnya, kita masuk ke form entri header detail yang lebih kompleks</p>

<h3>Entri Peminjaman</h3>

<p>Hampir semua kegiatan transaksi dalam aplikasi bisnis bisa direpresentasikan dengan model header-detail. Apa itu model header-detail?</p>

<blockquote><p>Satu transaksi akan terdiri dari satu record header dan banyak record detail. Record detail memiliki relasi foreign key ke record header.</p></blockquote>

<p>Sebagai contoh, kita lihat transaksi peminjaman. Satu kali pinjam, anggota bisa membawa banyak buku. Bagaimana representasinya?</p>

<p>Salah satu teknik yang sering saya gunakan dalam analisa dan desain aplikasi adalah <code>visualisasi dengan ilustrasi</code>. Kita buat contoh kasus yang menceritakan transaksi bisnis yang terjadi lengkap dengan datanya. Dengan menggunakan kasus konkrit, kita tidak perlu pusing membayangkan sesuatu yang abstrak. Ini adalah trik yang biasanya tidak diketahui programmer pemula sehingga mereka bingung gak tau mana ujung mana pangkal. Berikut contoh kasusnya.</p>

<p><code>``
Pada hari Senin 21 April 2014 pukul 13:45
anggota bernama</code>Endy Muhardin<code>
dilayani oleh petugas bernama</code>Anton Raharja`
meminjam tiga buku sebagai berikut:</p>

<ul>
<li>Java Desktop</li>
<li>Konsep dan Penggunaan Subversion</li>
<li>Pengenalan PHP
```</li>
</ul>


<blockquote><p>Bagaimana menyimpan data transaksi di atas dalam database?</p></blockquote>

<p>Pertama, kita tentukan dulu headernya. Header adalah satu record yang menjadi induk dari transaksi di atas. Kita buat tabel <code>peminjaman_header</code> sebagai berikut</p>

<table>
<thead>
<tr>
<th> id  </th>
<th> waktu               </th>
<th> id_petugas </th>
<th> id_anggota </th>
</tr>
</thead>
<tbody>
<tr>
<td>p001 </td>
<td> 2014-04-21 13:45:00 </td>
<td> u001       </td>
<td> u100</td>
</tr>
</tbody>
</table>


<p>User dengan id <code>u001</code> adalah relasi foreign key ke tabel <code>master_user</code> yang berisi record <code>Anton Raharja</code>, sedangkan user dengan id <code>u100</code> adalah relasi foreign key ke tabel <code>master_user</code> yang berisi record <code>Endy Muhardin</code>.</p>

<p>Sesuai dengan prinsip <code>visualisasi dengan ilustrasi</code>, dalam mendesain tabel kita isikan juga datanya. Itu sebabnya tabel di atas tidak saya tampilkan seperti biasanya orang mendesain database seperti ini:</p>

<table>
<thead>
<tr>
<th>Nama Kolom </th>
<th> Tipe Data   </th>
<th> Atribut</th>
</tr>
</thead>
<tbody>
<tr>
<td>id         </td>
<td> VARCHAR(32) </td>
<td> PRIMARY KEY</td>
</tr>
<tr>
<td>waktu      </td>
<td> DATETIME    </td>
<td> NOT NULL</td>
</tr>
<tr>
<td>id_petugas </td>
<td> VARCHAR(32) </td>
<td> FOREIGN KEY, NOT NULL</td>
</tr>
<tr>
<td>id_anggota </td>
<td> VARCHAR(32) </td>
<td> FOREIGN KEY, NOT NULL</td>
</tr>
</tbody>
</table>


<p>Karena kalau kita tampilkan seperti di atas, kita terpaksa harus membayangkan sesuatu yang abstrak.</p>

<blockquote><p>Lalu apakah saya harus menggunakan visualisasi dengan ilustrasi seumur hidup saya?</p></blockquote>

<p>Tentu tidak, nanti setelah membuat aplikasi production yang ke-sekian puluh, visualisasi ini sudah <em>terinstal</em> dalam sistem operasi otak kita. Demikian juga dengan prinsip-prinsip normalisasi database, desain berorientasi objek, pola header-detail, dan sebagainya. Pada tahap ini, kita akan bisa coding sambil usernya menceritakan requirement aplikasi yang dia inginkan.</p>

<p>Tapi itu nanti, ada waktunya. Bila Anda masih membaca artikel ini, berarti belum waktunya ;) Sementara ini, jangan malas membuat ilustrasi. Bahkan mahasiswa saya di mata kuliah Pemrograman 1 harus membuat ilustrasi di spreadsheet pada waktu looping menampilkan bilangan prima.</p>

<p>Baiklah, kita kembali ke masalah header-detail. Kita sudah mencatat waktu transaksi, petugas, dan anggota. Sekarang kita akan mencatat buku apa saja yang dipinjam. Untuk itu, kita membuat tabel <code>peminjaman_detail</code> sebagai berikut</p>

<table>
<thead>
<tr>
<th>id    </th>
<th> id_header </th>
<th> id_buku </th>
</tr>
</thead>
<tbody>
<tr>
<td>pd001 </td>
<td> p001      </td>
<td> b001</td>
</tr>
<tr>
<td>pd002 </td>
<td> p001      </td>
<td> b010</td>
</tr>
<tr>
<td>pd003 </td>
<td> p001      </td>
<td> b100</td>
</tr>
</tbody>
</table>


<p>Seperti kita lihat pada tabel di atas, ketiga record berelasi ke record <code>p001</code> di tabel <code>peminjaman_header</code> yaitu pada kolom <code>id_header</code>. Kolom <code>id_buku</code> tentu kita sudah bisa menebak bahwa dia mengacu ke tabel <code>master_buku</code>.</p>

<p>Untuk memasukkan data header dan detail, berikut adalah screen entri transaksinya:</p>

<p><img src="https://lh5.googleusercontent.com/-X3QeTFVgI04/U1adOQ65DlI/AAAAAAAAFrw/whTHBn110mw/w774-h588-no/entri_peminjaman.png"></p>

<p>Berbeda dengan form input sederhana, form entri header-detail memiliki tabel di dalamnya. Tabel inilah yang memuat data detail, sedangkan form inputnya menampung data header.</p>

<p>Karena adanya input ke dalam tabel ini, maka kita membutuhkan screen tambahan, yaitu dialog. Dialog ini akan muncul begitu kita tekan tombol <code>Tambah</code>. Setelah muncul, kita pilih satu atau lebih (tergantung proses bisnis) record dalam dialog. Kemudian setelah selesai, dialognya akan tertutup dan record yang kita pilih masuk ke dalam tabel.</p>

<p>Berikut tampilan dialog untuk memilih buku yang akan dipinjam. Karena yang dipinjam bisa banyak buku, maka kita sediakan checkbox agar user tidak perlu membuka dialog berkali-kali.</p>

<p><img src="https://lh3.googleusercontent.com/-lPHMx7VATXM/U1acVTFCtYI/AAAAAAAAFqg/xQYotfMd4Ns/w804-h420-no/dialog_tambah_buku.png"></p>

<p>Penggunaan dialog tidak terbatas hanya untuk entri detail. Dialog juga sebaiknya kita gunakan untuk data yang bersifat pilihan, kalau jumlah pilihannya lebih dari sepuluh record. Sebagai contoh, pada saat memilih anggota yang akan meminjam buku, tidak mungkin kita gunakan dropdown combo. Kalau anggotanya ada ribuan, usernya pasti kesulitan memilihnya. Apalagi dalam dropdown combo, informasi yang bisa ditampilkan terbatas. Paling hanya nama saja. Akan lebih mudah kalau kita sediakan dialog seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-ZgeS9pGZH-Y/U1acVOVr9HI/AAAAAAAAFqc/5hmU6uXWMAY/w768-h414-no/dialog_cari_anggota.png"></p>

<p>Pola header-detail ini berlaku untuk sebagian besar fitur transaksi. Mari kita ambil contoh lain, transaksi belanja di minimarket misalnya. Screennya seperti ini</p>

<p><img src="https://lh3.googleusercontent.com/LQsOccTBJ6_nHzLHirLdybAv8CMZ_gl6lw3WGIEfpX8=w820-h623-no"></p>

<p>Pada transaksi minimarket, ada tambahan data yaitu <code>quantity</code> untuk mengakomodasi orang beli permen 5 buah. Dialog tambah detailnya juga harus memiliki input field untuk <code>quantity</code>. Dan karena jumlah produknya ribuan, kita juga harus sediakan lookup dialog sekali lagi untuk memilih produk.</p>

<p>Dialog tambah detail seperti ini bentuknya</p>

<p><img src="https://lh5.googleusercontent.com/-fBQUV0F944w/U1acX5wjQ2I/AAAAAAAAFrM/5ZatJYsudL8/w666-h285-no/tambah_detail_minimarket.png"></p>

<p>Di situ ada tombol <code>Cari</code> yang bila diklik akan menampilkan dialog pilih produk seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-lmToPoVQHZ0/U1acWmCjTsI/AAAAAAAAFq4/3mFYG1Cpz1o/w762-h402-no/dialog_cari_produk.png"></p>

<p>Jadi, untuk mengentri satu detail, user akan membuka dialog dua tingkat: dialog entri quantity dan dialog pilih produk.</p>

<p>Adapun tabel di database cukup kita tambahkan satu field quantity seperti ini</p>

<table>
<thead>
<tr>
<th>id    </th>
<th> id_header </th>
<th> id_produk </th>
<th> qty </th>
</tr>
</thead>
<tbody>
<tr>
<td>pd001 </td>
<td> p001      </td>
<td> b001      </td>
<td>   1 </td>
</tr>
<tr>
<td>pd002 </td>
<td> p001      </td>
<td> b010      </td>
<td>   5 </td>
</tr>
<tr>
<td>pd003 </td>
<td> p001      </td>
<td> b100      </td>
<td>  12 </td>
</tr>
</tbody>
</table>


<p>Bisa juga detailnya lebih dari satu, seperti screen transaksi servis motor/mobil. Ada komponen sparepart dan ada komponen jasa. Begini bentuknya</p>

<p><img src="https://lh5.googleusercontent.com/-AFCYrZEZlWE/U1acY31B9wI/AAAAAAAAFrY/W3O2-B4mtyY/w598-h623-no/transaksi_servis_motor.png"></p>

<p>Skema databasenya berarti terdiri dari 3 tabel: <code>servis_header</code>, <code>servis_detail_sparepart</code>, dan <code>servis_detail_jasa</code>.</p>

<p>Selanjutnya, kita buat screen untuk rekap/laporan.</p>

<h3>Histori Peminjaman per Anggota</h3>

<p>Di screen laporan, inputan yang paling sering dipakai adalah periode. Inputannya berupa tanggal mulai dan tanggal sampai. Contohnya, kita ingin menampilkan histori peminjaman buku salah satu anggota untuk 3 bulan terakhir, screennya seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-UPULY4jYmVo/U1acXrfIiJI/AAAAAAAAFrE/IOenvvN8AzM/w867-h486-no/rekap_peminjaman.png"></p>

<p>Di situ kita lihat juga tombol <code>Cari</code>. Itu berfungsi untuk menampilkan dialog pencarian anggota, sama seperti pada screen transaksi peminjaman di atas.</p>

<p>Fitur yang biasa ada di tampilan rekap ini antara lain:</p>

<ul>
<li>pencarian transaksi dengan lebih spesifik. Misalnya menyebutkan buku yang dipinjam, jenis transaksi, nilai/jumlah tertentu, dan sebagainya</li>
<li>paging bila datanya banyak, seperti telah dijelaskan di artikel terdahulu.</li>
<li>sorting, biasanya diimplementasikan melalui kepala tabel yang bisa diklik. Misalnya kita ingin urut tanggal (baik transaksi baru di atas maupun sebaliknya), buku, dan lainnya.</li>
</ul>


<h2>Langkah Selanjutnya</h2>

<p>Setelah UI Mockup kita selesaikan, adakan sesi review bersama user untuk mendapatkan feedback. Setelah sepakat dengan user (untuk proyek komersial bisa juga disertai tanda tangan berita acara kesepakatan) barulah kita lanjutkan ke tahap desain skema database dan desain class/objek.</p>

<p>Banyak orang menyalah-artikan tahap desain dengan dokumen desain. Saya melakukan tahap desain aplikasi, tapi belum tentu membuat dokumen desain.</p>

<p>Proses desain kita lakukan dengan tujuan agar bisa melihat <em>the big picture</em>. Pada waktu mulai coding, perhatian kita akan terpusat ke satu function/method atau class saja. Ibaratnya masuk ke hutan, jarak pandang kita terbatas. Sangat mudah untuk tersesat, kita sudah implement fitur tertentu, ternyata tidak kompatibel dengan fitur selanjutnya.</p>

<p>Selain itu, dengan melihat <em>the big picture</em>, kita jadi tahu fitur mana yang penting dan mana yang <em>nice to have</em>. Jangan sampai kita menghabiskan waktu untuk mengimplementasikan fungsionalitas yang bersifat kosmetik saja, padahal fitur utama belum selesai.</p>

<p>Walaupun demikian, saya tidak membuat dokumen desain. Mengapa begitu? Jawabannya bisa disimak <a href="http://software.endy.muhardin.com/manajemen/dokumentasi-project/">di artikel ini</a>.</p>

<p>Proses mendesain skema database dan skema class/objek akan kita bahas pada artikel selanjutnya. Stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aplikasi Prakarya vs Aplikasi Production]]></title>
    <link href="http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production/"/>
    <updated>2014-04-15T22:00:00+07:00</updated>
    <id>http://software.endy.muhardin.com/manajemen/aplikasi-prakarya-vs-aplikasi-production</id>
    <content type="html"><![CDATA[<p>Salah satu pertanyaan yang sering ditanyakan di forum programmer adalah</p>

<blockquote><p>Saya ingin belajar bahasa pemrograman [isi bahasa yang Anda sukai di sini], bagaimana ya caranya supaya bisa mahir?</p></blockquote>

<p>Dan jawaban saya selalu sama</p>

<blockquote><p>Coba buatlah aplikasi berkualitas production barang 5 - 10 kali, setelah itu insya Allah akan mahir.</p></blockquote>

<p>Jawaban di atas memang singkat, tapi jalan untuk menuju kesana <a href="http://endy.muhardin.com/education/tahapan-belajar/">sungguh tidak mudah dan tidak singkat</a>. Apalagi untuk pemula, setidaknya ada dua pertanyaan besar:</p>

<ol>
<li>Apa sih aplikasi production itu?</li>
<li>Bagaimana cara membuat aplikasi?</li>
</ol>


<p>Pertanyaan pertama akan kita jawab pada artikel ini. Sedangkan pertanyaan kedua akan kita jawab pada artikel selanjutnya.</p>

<!--more-->


<p>Dalam siklus pembuatan aplikasi, biasanya ada beberapa tahapan rilis:</p>

<ol>
<li>Development : ini adalah work in progress yang sedang dikerjakan programmer. Aplikasinya belum selesai sehingga wajar kalau banyak errornya.</li>
<li>Testing : programmer sudah mengetes bagian-bagian yang penting. Tinggal bug pada kasus-kasus dan kondisi <em>'ajaib'</em> yang biasanya cuma bisa ditemukan oleh tester yang handal. Testing biasanya juga ada berbagai tahapan, mulai dari internal tester sampai ke tester dari client/end user.</li>
<li>Production : aplikasi sudah digunakan sehari-hari oleh end user dan berjalan lancar tanpa ada bug yang signifikan (show-stopper).</li>
</ol>


<p>Lebih detail mengenai tahapan rilis bisa dibaca di <a href="http://software.endy.muhardin.com/manajemen/release-management/">artikel terdahulu tentang Release Management</a>.</p>

<p>Tahapan di atas biasanya dijalankan di perusahaan. Di lingkungan akademik (kampus, SMK), saya punya satu kategori lagi yang dinamakan <strong>Aplikasi Prakarya</strong>. Wah apa lagi tuh <strong>Aplikasi Prakarya</strong>??</p>

<blockquote><p>Aplikasi Prakarya adalah aplikasi yang cuma bisa digunakan untuk tugas kuliah ataupun skripsi. Itupun cuma bisa lulus kalau dosennya bermurah hati. Aplikasi prakarya ini tidak akan mungkin digunakan oleh end-user, walaupun daftar fiturnya sama dengan aplikasi production.</p></blockquote>

<p>Masih belum paham? Baiklah kita coba ilustrasikan dengan cerita.</p>

<p>Pada suatu hari, saya menyuruh mahasiswa saya membuat aplikasi. Mereka saat ini sedang semester 4. Seperti umumnya kampus di negeri kita ini, mahasiswa semester 4 belum pernah membuat aplikasi utuh. Jam terbangnya paling hanya beberapa looping/branching atau paling maksimal beberapa function/method untuk belajar algoritma. Saya beri tugas:</p>

<blockquote><p>Coba buat aplikasi user management. Tidak perlu full coding, cukup UI mockup (rancangan screen) saja.</p></blockquote>

<p>Aplikasi user management adalah aplikasi yang paling mendasar. Apapun aplikasi yang ingin kita buat, pasti ada modul ini. Fiturnya pun tidak rumit-rumit. Cukup insert-update-delete-display data user saja. Untuk menyederhanakan masalah, tidak perlulah kita buat group dan permission.</p>

<p>Source file UI mockup yang saya buat di artikel ini bisa diunduh <a href="../../downloads/prakarya-production.ep">di sini</a> dan dibuka menggunakan <a href="http://pencil.evolus.vn/">aplikasi Pencil</a>.</p>

<p>Nah kita lihat evolusi dari aplikasi prakarya menjadi aplikasi production. Kita mulai dengan menampilkan data user.</p>

<h2>Menampilkan Data</h2>

<p>Inilah screen daftar user yang dipresentasikan ke saya</p>

<p><img src="https://lh4.googleusercontent.com/-25Yeh5ay_RY/U01LMUEObTI/AAAAAAAAFpA/p45UmrhH9-4/w888-h408-no/tabelprakarya01.png"></p>

<blockquote><p>Bagaimana menurut Anda? Apakah Anda melihat ada masalah pada screen di atas? Apa masalahnya?</p></blockquote>

<p>Masalahnya ada di jumlah data. Aplikasi prakarya biasanya dites menggunakan 1 - 5 baris data saja. Tentu saja tidak ada masalah yang terlihat kalau datanya cuma 1 - 5 baris. Nah, bagaimana kalau tidak ada data? Biasanya begini jadinya.</p>

<p><img src="https://lh3.googleusercontent.com/-mvMdRuXasxU/U01LNOysKkI/AAAAAAAAFpQ/wkv2gyBpzCs/w882-h363-no/tabelprakarya03.png"></p>

<p>Ini menunjukkan programmer malas. Padahal dengan menambah beberapa baris <code>if-else</code>, tampilan di atas bisa terkesan lebih <em>'serius'</em> seperti ini</p>

<p><img src="https://lh5.googleusercontent.com/-g1HzK09B3W0/U01LOCrimhI/AAAAAAAAFpg/yXw_NJX3OIQ/w654-h306-no/tabelproduction02.png"></p>

<p>Ok, kita sudah handle kasus tidak ada data. Nah sekarang, pada waktu dipakai di kondisi riil, berapa datanya? Misalnya kita membuat aplikasi perpustakaan untuk kampus. Berapa jumlah anggotanya? Apakah 1-5 saja? Tentu tidak mungkin. Kisaran datanya antara ratusan sampai puluhan ribu tergantung ukuran kampus. Belum lagi kalau perpustakaannya menerima anggota masyarakat umum.</p>

<p>Dengan data ratusan/ribuan, screen di atas akan mengalami masalah:</p>

<ul>
<li>data tentu ditarik dengan query <code>select * from tabel_user</code>. Kalau satu user datanya 1KB, maka untuk 10 ribu user 10MB harus dikirim dari database server ke webserver, dan kemudian dari webserver ke browser.</li>
<li>asumsikan koneksi internet user 1 MB/s, maka dia harus menunggu 10 detik sampai daftar user bisa dia lihat. Pakai GPRS? Nah, silahkan kembali lagi besok sore ;)</li>
<li>bila ada 10 concurrent user (user yang mengakses aplikasi secara bersamaan), maka kita harus siapkan bandwidth 100 MB/s di sisi server hanya untuk menampilkan daftar user.</li>
</ul>


<blockquote><p>Lalu bagaimana solusinya?</p></blockquote>

<p>Solusi pertama, paging. Kita bagi data menjadi beberapa halaman. Toh user juga tidak mungkin melihat 10 ribu data sekaligus. Bisa-bisa stres dia kayak caleg kalah pemilu.</p>

<p><img src="https://lh6.googleusercontent.com/-CgyzCMA-Foc/U01LMwcZhfI/AAAAAAAAFpM/8PCtzho72xA/w852-h462-no/tabelprakarya02.png"></p>

<blockquote><p>Selesai?</p></blockquote>

<p>Belum. Untuk 10 ribu data, bila satu halaman isinya 20, maka ada 500 halaman. Mana ada orang mau klik satu persatu halamannya. Jadi bagaimana? Ya tentu harus bisa dicari.</p>

<p><img src="https://lh3.googleusercontent.com/-OGKJDR3nnSk/U01LN9OAzmI/AAAAAAAAFpc/Z5mYYDj-O9s/w888-h465-no/tabelproduction01.png"></p>

<p>Nah, dari sini kita sudah bisa membedakan antara aplikasi prakarya dan aplikasi production. Aplikasi prakarya tidak dites secara menyeluruh. Dengan 1-5 data saja sudah puas, cukuplah untuk dapat A kalau dosennya murah hati. Tapi aplikasi production tidak bisa seperti itu kalau aplikasinya mau dipakai orang. Kita harus tes dengan 0 data dan 10 ribu data.</p>

<p>Selanjutnya, mari kita lihat form input data.</p>

<h2>Entri Data</h2>

<p>Inilah screen iterasi pertama</p>

<p><img src="https://lh4.googleusercontent.com/-gwFv3Yp1hMY/U01LKyx9OcI/AAAAAAAAFoo/pjiHEIjgRYc/w687-h510-no/formprakarya01.png"></p>

<blockquote><p>Apa masalahnya?</p></blockquote>

<p>Untuk input data, ada dua hal yang wajib dilakukan dengan benar:</p>

<ul>
<li>validasi</li>
<li>menampilkan pesan kesalahan</li>
</ul>


<p>Mari kita perbaiki. Ini hasil revisinya</p>

<p><img src="https://lh5.googleusercontent.com/-ptivii5-b3I/U01LLWa7lZI/AAAAAAAAFo0/PMTqrd83k9c/w917-h487-no/formprakarya02.png"></p>

<p>Sudah ada pesan error pada screen di atas. Tapi kalau berhenti sampai di sini, usernya bisa marah-marah, soalnya nilai yang sudah dia isikan hilang semua. Harusnya tetap ditampilkan, sehingga dia cukup edit yang salah saja. Tidak perlu entri ulang semuanya. Revisi lagi menjadi seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-pzWfTxTPSaY/U01LLyVPxcI/AAAAAAAAFo4/Qo19dzxO8uM/w900-h459-no/formproduction.png"></p>

<p>Nah, jauh lebih baik.</p>

<p>Selain masalah di atas, ada beberapa hal lagi yang perlu kita perhatikan, yaitu:</p>

<ul>
<li>validasi server-side vs client-side</li>
<li>pemilihan jenis komponen</li>
</ul>


<blockquote><p>Mana validasi yang harus kita buat? Apakah di sisi server atau di sisi client?</p></blockquote>

<p>Validasi yang wajib adalah di sisi server. Kita harus cek semua data yang dikirim client. Kita juga tidak boleh hanya mengandalkan validasi di sisi client, karena berada di luar kendali kita. Bisa saja JavaScript dimatikan, form input di-bypass <a href="http://software.endy.muhardin.com/java/mendebug-aplikasi-ajax/">menggunakan aplikasi debugger</a>, dan berbagai teknik lainnya. Baik secara sengaja, ataupun karena keterbatasan perangkat di sisi client (misalnya browsernya versi jadul).</p>

<blockquote><p>Kalau begitu, buat apa kita buat lagi validasi di sisi client? Buang-buang energi saja.</p></blockquote>

<p>Validasi di sisi client tujuannya supaya user lebih nyaman. Akan lebih enak kalau setelah kursor pindah, data yang barusan diinput langsung ketahuan benar/salahnya. Daripada isi seluruh form, submit, dan ternyata ada error. Sama seperti tampilan tabel tanpa data di atas. Aplikasi yang hal-hal detailnya diurus dengan baik akan terkesan lebih profesional.</p>

<p>Pemilihan jenis komponen akan kita bahas pada artikel selanjutnya.</p>

<h2>Pesan Error</h2>

<p>Kita semua tentu kenal Rambo. Dia bisa survive dimanapun dia diterjunkan dan seburuk apapun perlakuan orang kepadanya.</p>

<p><img src="https://lh3.googleusercontent.com/-kWEJAXJQqiY/U01NMQkQ7_I/AAAAAAAAFp0/099uScfrhP0/w768-h576-no/rambo-wallpaper-800x600.jpg"></p>

<p><em>Fotonya Rambo diambil <a href="http://wallpaperswide.com/rambo-wallpapers.html">dari sini</a></em></p>

<p>Aplikasi production juga demikian. Apapun yang diinput user, dia bisa handle dengan baik. Harddisk penuh? Bandwidth lemot? RAM overload? Semua bisa ditangani dengan baik.</p>

<blockquote><p>Bagaimana caranya? Apakah aplikasi tidak boleh error?</p></blockquote>

<p>Tentu tidak. Mana ada yang sempurna di dunia ini. Kita mengatasi kondisi buruk dengan error handling yang baik. Kalau ada sesuatu yang tidak sesuai kondisi yang dibutuhkan aplikasi, kita tampilkan pesan error yang informatif.</p>

<p>Mari kita lihat error handling aplikasi prakarya, ketika usernya mengetikkan alamat yang tidak ada di aplikasi.</p>

<p><img src="https://lh6.googleusercontent.com/-aZa_dcU50c4/U001E2SUhMI/AAAAAAAAFm4/x502FobAP3s/w614-h238-no/404-prakarya.png"></p>

<p>Nah, jelek sekali bukan? Sangat menunjukkan kemalasan programmernya. Padahal dengan beberapa baris tambahan (di Java cuma 4 baris saja), kita bisa buat yang lebih baik seperti ini</p>

<p><img src="https://lh6.googleusercontent.com/-o_w5mMRrh1Q/U001mWLAvAI/AAAAAAAAFnI/lS3c42pYdWc/w616-h465-no/404-production.png"></p>

<p>Waktu yang dibutuhkan tidak lama. Maksimal 5 menit saja. Itupun lama karena kita bimbang apakah mau pakai gambar kucing atau Peter Parker.</p>

<p>Nah kalau pesan error di atas hanya sebatas faktor estetika, pesan error berikut konsekuensinya lebih fatal</p>

<p><img src="https://lh3.googleusercontent.com/-YbMALc355TM/U001Gd2IjAI/AAAAAAAAFnA/6tanv9Q5u8I/w621-h350-no/500-prakarya.png"></p>

<blockquote><p>Kenapa fatal?</p></blockquote>

<p>Karena dari pesan error di atas, pemirsa bisa mengetahui:</p>

<ul>
<li>cara menimbulkan error di atas. Tentu dia ingat langkah-langkah yang dia lakukan sehingga terjadi error seperti di atas.</li>
<li>bahasa pemrograman yang digunakan, yaitu Java. Dilihat dari model stacktracenya.</li>
<li>merek dan versi application server yang digunakan, yaitu Tomcat 6.0.29.</li>
<li>lokasi akurat dari kode program yang error, yaitu class <code>ErrorServlet</code> yang berada dalam package <code>com.muhardin.endy.servlet</code> di baris <code>12</code>.</li>
<li>penyebab error, yaitu <code>IllegalStateException</code>.</li>
<li>estimasi cara kerja program pada waktu error</li>
</ul>


<p>Informasi di atas cukup sebagai titik awal cracker yang akan menjebol aplikasi kita. Dengan informasi tersebut, dia tinggal google:</p>

<ul>
<li>bug yang ada di Tomcat versi 6.0.29.</li>
<li>cara mengeksploitasi bug tersebut</li>
</ul>


<p>Nah, cukup mengerikan bukan? Padahal cukup dengan tambahan 4 baris, kita bisa ganti pesan errornya seperti ini</p>

<p><img src="https://lh4.googleusercontent.com/-JoVmx6mjuNg/U00184vMCTI/AAAAAAAAFnk/PpyXQXOqAyU/w619-h372-no/500-production.png"></p>

<p>Screen di atas akan sangat mengurangi informasi yang bisa disalahgunakan orang yang berniat jahat. Lagipula pesan error <code>IllegalStateException</code> tidak ada gunanya buat user. Error 500 artinya tidak ada perbaikan yang bisa dilakukan end-user. Beda dengan error validasi input dimana user bisa memperbaiki isiannya dan kemudian mencoba submit lagi.</p>

<h2>Pesan Moral</h2>

<p>Perbedaan antara aplikasi prakarya dan production sudah dibahas dalam <a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">buku legendaris <code>The Mythical Man Month</code> karya Fred Brooks</a>. Berikut saya kutipkan satu paragraf dari bab pertama</p>

<blockquote><p>Moving down across the horizontal boundary, a program
becomes a programming product. This is a program that can be run,
tested, repaired, and extended by anybody. It is usable in many
operating environments, for many sets of data.
To become a generally usable programming product,
a program must be written in a
generalized fashion. In particular the range and form of inputs
must be generalized as much as the basic algorithm will reasonably
allow. Then the program must be thoroughly tested, so that it can
be depended upon. This means that a substantial bank of test
cases, exploring the input range and probing its boundaries, must
be prepared, run, and recorded. Finally, promotion of a program
to a programming product requires its thorough documentation, so
that anyone may use it, fix it, and extend it. As a rule of thumb,
I estimate that a programming product costs at least three times as
much as a debugged program with the same function.</p></blockquote>

<p>Dari paparan Eyang Fred di atas, kita bisa mendapatkan beberapa poin penting:</p>

<ul>
<li>membuat aplikasi production biayanya 3x lipat dibandingkan membuat aplikasi prakarya</li>
<li>aplikasi production dapat dipakai di berbagai kondisi (operating environment)</li>
<li>aplikasi production dapat menangani data dalam jumlah besar (many sets of data)</li>
<li>aplikasi production dites secara menyeluruh (thoroughly tested)</li>
<li>tidak hanya urusan coding saja, untuk naik kelas ke kasta production aplikasi juga harus dilengkapi dokumentasi yang lengkap</li>
</ul>


<p>Jadi, untuk set fitur yang sama:</p>

<ul>
<li>tambah user</li>
<li>edit user</li>
<li>hapus user</li>
<li>tampilkan data user</li>
</ul>


<p>terdapat perbedaan kualitas yang signifikan antara level prakarya dan level production. Kalau aplikasi prakarya dibuat dalam waktu 1 bulan, maka untuk membuatnya berkualitas production butuh tambahan 2 bulan lagi.</p>

<p>Tapi untungnya, untuk naik kelas dari prakarya menjadi production syaratnya tidak sulit, sederhana saja yaitu:</p>

<blockquote><p>Jangan malas</p></blockquote>
]]></content>
  </entry>
  
</feed>
