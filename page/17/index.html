
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Pada artikel sebelumnya, kita telah menyimpan artifact modul person-model di shared repository melalui mekanisme scp dengan private key. Pada artikel &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://endy.artivisi.com/blog/page/17/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  	<div id="logoLeft">{</div>
  	<div id="logoText">endymuhardin</div>
  	<div id="logoRight">}</div>
  	<div class="clear"></div>
  </div>
  <h1><a href="/">Living life and make it better</a></h1>
  
    <h2>life, learn, contribute</h2>
  
  <div class="clear"></div>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:endy.artivisi.com/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/java/ant-ivy-5/">Internal Dependency Dengan Ivy</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2008-09-28T16:51:32+07:00" pubdate data-updated="true">Sep 28<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-4/">artikel sebelumny</a>a, kita telah menyimpan artifact modul person-model di shared repository melalui mekanisme scp dengan private key. Pada artikel ini, kita akan menggunakan artifact person-model tersebut dalam modul person-dao-api. Pengambilan artifact dilakukan melalui mekanisme yang sama, yaitu scp dengan private key.</p>

<p>Berikut struktur folder modul person-dao-api.</p>

<p><img src="/images/uploads/2008/09/folder-person-dao-api-before-resolve.png" title="" ></p>

<p>Kita memiliki folder src yang berisi source code class <code>PersonDao.java</code>, yang isinya sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.dao;

import java.util.List;

import com.artivisi.tutorial.ivy.model.Person;

public interface PersonDao {

    /**
     * saves Person object into database. 
     * If object is already exists (denoted by not-null ID field), 
     * the existing record with the corresponding ID is updated. 
     * If the object is new (denoted by null ID field), 
     * new record is inserted.
     * 
     *  This method also set the ID field for new record.
     * */
    public void save(Person person);

    /**
     * fetch all person object in database.
     * @return List of all person
     * */
    public List getAll();

    /**
     * fetch Person object with the speficied ID. 
     * @param id identifier for person object
     * @return Person object if there is record found for the speficied id, null otherwise
     * */
    public Person getById(Long id);
}
</code></pre>

<p>Seperti terlihat dalam deklarasi import, class ini menggunakan class <code>Person</code>, yang sudah tersedia di shared repository. Kita akan melakukan build dengan menggunakan script <code>build.xml</code>. Isinya sama dengan yang ada di modul person-model, dengan perkecualian nama projectnya. Berikut isi <code>build.xml</code>.</p>

<pre><code>&lt;project name="person-dao-api" default="build"&gt;

    &lt;property file="build.properties"/&gt;

    &lt;import file="${basedir}/../person-build/default.xml"/&gt;
    &lt;import file="${basedir}/../person-build/ivy-builder.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>Dependensi modul <code>person-dao-api</code> terhadap <code>person-model</code> kita deklarasikan dalam <code>ivy.xml</code> sebagai berikut.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-dao-api"/&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="api"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

    &lt;dependencies&gt;
        &lt;dependency name="person-model" rev="latest.integration" conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Setelah <code>build.xml</code> dan <code>ivy.xml</code> selesai dibuat, kita bisa langsung melakukan build. Panggil target dari command line sebagai berikut:</p>

<pre><code>ant build
</code></pre>

<p>Dari output perintah di atas terlihat bahwa Ivy akan menguraikan dependensi project dengan melakukan query ke semua resolver yang terdaftar. Setelah modul yang dibutuhkan (person-model) ditemukan, Ivy akan langsung mendonlodnya ke dalam folder lib. Karena isi folder lib sudah kita daftarkan ke dalam classpath, maka proses kompilasi akan berjalan dengan mulus. Berikut struktur folder <code>person-dao-api</code> setelah melakukan proses resolve.</p>

<p><img src="/images/uploads/2008/09/folder-person-dao-api-after-resolve.png" title="" ></p>

<p>Pada deklarasi dependensi di atas, terlihat bahwa modul <code>person-dao-api</code> memiliki dependensi terhadap modul <code>person-model</code> dengan revision <code>latest.integration</code>. Ini artinya Ivy akan menggunakan versi terbaru yang ada dalam repository. Untuk melihat kemampuan fitur ini, mari kita publish <code>person-model</code> dengan revision yang lebih baru.</p>

<p>Edit file build.properties dalam modul person-model, sehingga menjadi seperti ini.</p>

<pre><code>build.version = 0.0.2
release.type = integration
</code></pre>

<p>Setelah itu, bersihkan hasil kompilasi terdahulu, dan publish modul <code>person-model</code>.</p>

<pre><code>ant clean publish-local
</code></pre>

<p>Lalu, pindah ke modul person-dao-api, dan lakukan build lagi.</p>

<pre><code>ant clean build
</code></pre>

<p>Terlihat pada output, bahwa modul <code>person-model</code> yang terbaru akan didonlod, dan yang versi lama akan dihapus. Sehingga isi folder lib akan terlihat sebagai berikut.</p>

<p>Ivy memiliki beberapa cara untuk menentukan mana artifak yang terbaru (latest), yaitu: latest-time, latest-revision, dan latest-lexico.</p>

<p>Dengan menggunakan latest-time, Ivy akan melihat tanggal dibuatnya suatu artifak. Kalau artifak berada di repository filesystem, maka tanggal sistem operasi akan digunakan. Bila repository diakses melalui http, Ivy akan melakukan query terhadap http server. Metode ini, walaupun efektif, relatif lambat bila akses jaringan ke repository tidak mumpuni.</p>

<p>Latest-revision membandingkan nama versi artifak, dan mengenali beberapa keyword. Dia dapat menentukan bahwa versi 1.0-alpha lebih baru daripada 1.0-dev1, dan 1.0 lebih baru daripada 1.0-rc1.</p>

<p>Sedangkan strategi latest-lexico hanya membandingkan berdasarkan urutan abjad. Jadi, 1.0-m1 akan lebih baru daripada 1.0-build135.</p>

<p>Ketiga strategi tersebut sudah built-in dalam Ivy dan tidak memerlukan konfigurasi lebih lanjut.</p>

<p>Selain revision, Ivy juga mengenal terminologi status. Secara default, Ivy menyediakan tiga status diurutkan dari yang paling stabil/mature, yaitu release, milestone, dan integration. Bila kita menggunakan latest.integration, Ivy akan mengambil artifak terbaru berstatus apapun dari repository. Bila kita gunakan latest.milestone, Ivy akan mengabaikan rilis integration, dan hanya akan membandingkan milestone dan release. Demikian juga bila kita gunakan latest.release, maka versi terbaru hanya akan dicari dari artifak berstatus release.</p>

<p>Cara deklarasi latest.integration di atas disebut dengan dynamic revision, karena nomer revision tidak secara eksplisit disebutkan. Selain menggunakan latest.integration, ada beberapa mekanisme lain, yaitu menggunakan +, dan menggunakan range.</p>

<p>Kita bisa menggunakan + untuk memilih revisi terbaru untuk rilis tertentu. Misalnya bila kita memiliki modul dengan revisi 1.0.1, 1.0.4, 1.0.7, dan 1.1.4 dalam repository, kita dapat menggunakan 1.0.+ untuk memilih versi terbaru dalam lini 1.0, yaitu 1.0.7.</p>

<p>Kita juga bisa menggunakan range, untuk menentukan revisi yang dapat digunakan, misalnya [1.0,2.2] akan memilih semua revisi yang sama atau lebih besar dari 1.0, tapi lebih kecil atau sama dengan 2.2. Lebih lengkap tentang ini bisa dilihat di dokumentasi Ivy tentang dependensi.</p>

<p>Demikianlah deklarasi dependensi dengan Ivy. Pada artikel ini, kita baru mencoba dependensi terhadap modul yang kita buat sendiri. Di <a href="http://endy.artivisi.com/blog/java/ant-ivy-6/">artikel selanjutnya</a>, kita akan lihat bagaimana mendeklarasikan dependensi terhadap modul eksternal seperti Spring Framework atau Hibernate.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/java/manajemen/ant-ivy-4/">Publish Modul Ke Repository</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2008-09-10T16:57:41+07:00" pubdate data-updated="true">Sep 10<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Template project sudah dibuat pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-3/">artikel sebelumnya</a>. Pada artikel ini, kita akan menghubungkan kedua modul ini dengan menggunakan Ivy.</p>

<p>Seperti kita ketahui, modul <code>person-dao-api</code> mempunyai dependensi terhadap modul <code>person-model</code>. Berikut gambarnya.</p>

<p><img src="/images/uploads/2008/09/dep-after.png" title="" ></p>

<p>Dependensi ini terlihat di source-code <code>PersonDao.java</code>, yang melakukan import terhadap class Person, sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.dao;

import java.util.List;

import com.artivisi.tutorial.ivy.model.Person;

public interface PersonDao {

    /**
     * saves Person object into database. 
     * If object is already exists (denoted by not-null ID field), 
     * the existing record with the corresponding ID is updated. 
     * If the object is new (denoted by null ID field), 
     * new record is inserted.
     * 
     *  This method also set the ID field for new record.
     * */
    public void save(Person person);

    /**
     * fetch all person object in database.
     * @return List of all person
     * */
    public List getAll();

    /**
     * fetch Person object with the speficied ID. 
     * @param id identifier for person object
     * @return Person object if there is record found for the speficied id, null otherwise
     * */
    public Person getById(Long id);
}
</code></pre>

<p>Agar class diatas bisa dikompilasi dengan lancar, ada tiga hal yang harus dilakukan:</p>

<ol>
<li><p>Menyediakan lokasi yang dapat diakses oleh kedua modul</p></li>
<li><p>Mempublikasikan distribusi modul person-model</p></li>
<li><p>Mendeklarasikan dependensi person-dao-api terhadap person-model</p></li>
</ol>


<h3>Repository Ivy</h3>

<p>Dalam dunia Ivy, file-file distribusi suatu modul, seperti <code>person-model.jar</code>, <code>person-model-sources.jar</code>, disebut dengan istilah artifact.
Artifact ini diletakkan di lokasi tertentu, disebut dengan istilah repository. Konfigurasi tentang cara mengakses suatu repository disebut dengan istilah resolver. Ivy menyediakan berbagai resolver untuk berbagai metode/protokol, yaitu:</p>

<ul>
<li><p>Filesystem : ini biasanya digunakan untuk folder di komputer lokal atau shared folder (NFS atau Windows Share)</p></li>
<li><p>URL : digunakan untuk mengakses repository melalui http</p></li>
<li><p>SSH : digunakan untuk mengakses repository melalui mekanisme scp</p></li>
<li><p>SFTP : menggunakan protokol FTP yang terenkripsi</p></li>
<li><p>VFS : menggunakan Apache Commons VFS sebagai backend. Mendukung apapun jenis filesystem yang didukung VFS, salah satunya sftp</p></li>
<li><p>Ibiblio : untuk mengakses repository maven2</p></li>
</ul>


<p>Selain itu, Ivy juga menyediakan composite resolver, yaitu resolver yang dapat menampung resolver lainnya. Composite resolver ada dua:</p>

<ul>
<li><p>Chain Resolver : menggabungkan beberapa resolver, sehingga kalau suatu artifak tidak ditemukan di resolver pertama, bisa melanjutkan pencarian ke resolver selanjutnya dalam chain</p></li>
<li><p>Dual Resolver : memisahkan resolver untuk menghitung dependensi, dan resolver untuk mendownload artifak.</p></li>
</ul>


<p>Baiklah, ternyata Ivy bisa menangani macam-macam protokol. Tapi bagaimana cara kita mendesain repository yang baik? Bagaimana best-practicesnya? Mari kita bahas.</p>

<h3>Desain Repository</h3>

<p>Biasanya, kita memiliki dua jenis repository, internal dan external. Repository internal digunakan untuk menyimpan artifak yang dihasilkan project dalam organisasi. Sebagian atau semua artifak internal ini mungkin saja bersifat komersil atau proprietary, sehingga tidak dibuka untuk konsumsi publik.</p>

<p>Di internet tersedia repository yang bisa diakses semua orang. Pengguna Maven biasanya menggunakan <a href="http://www.ibiblio.org/maven/">repository ibiblio</a>. Pengguna Spring OSGi biasanya menggunakan <a href="http://www.springsource.com/repository">repository SpringSource</a>, yang sudah berisi library yang OSGi compliant. Repository SpringSource kompatibel baik dengan Ivy maupun Maven. Untuk menghemat bandwidth internasional, organisasi kita bisa membuat mirror dari repository publik ini agar dependensi bisa diunduh dari jaringan lokal.</p>

<p>Pada artikel ini, kita hanya akan membahas tentang internal repository. Pembahasan tentang external repository akan dibahas pada artikel yang akan datang.</p>

<h3>Internal Repository</h3>

<p>Internal repository dibagi lagi menjadi dua kategori, yaitu local repository, dan shared repository.</p>

<p>Local repository berada di PC masing-masing programmer. Misalnya satu programmer mengerjakan dua modul yang saling berhubungan, misalnya <code>person-model</code> dan <code>person-dao-api</code>. Seringkali dia membuat perubahan di <code>person-model</code> yang akan digunakan di <code>person-dao-api</code>. Tapi karena kode programnya belum sempurna, dia tidak ingin merilis artifak tersebut ke anggota tim yang lain. Untuk kebutuhan ini, dia mempublikasikan artifact <code>person-model</code> ke local repo di PCnya dia sendiri, sehingga bisa diakses oleh modul <code>person-dao-api</code>.</p>

<p>Setelah <code>person-model</code> dan <code>person-dao-api</code> dibuat dan ditest secara menyeluruh, barulah programmer tersebut merilis artifak ke shared repo agar bisa digunakan rekan-rekannya.</p>

<h3>Konfigurasi Internal Resolver</h3>

<p>Untuk mengimplementasikan skenario di atas, kita pertama akan mendefinisikan repository local. Asumsikan saja repository ini akan disimpan di folder local-repo sejajar dengan modul-modul yang lainnya. Kita akan mengkonfigurasi resolvernya di file bernama <code>ivysettings.xml</code>, diletakkan di modul <code>person-build</code> dalam subfolder ivy. Berikut isinya.</p>

<pre><code>&lt;ivysettings&gt;
    &lt;settings defaultResolver="local" /&gt;

    &lt;caches defaultCacheDir="${ivy.settings.dir}/../../ivy-cache" /&gt;
    &lt;resolvers&gt;     
        &lt;filesystem name="local"&gt;
            &lt;artifact
                pattern="${ivy.settings.dir}/../../local-repo/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
            &lt;ivy
                pattern="${ivy.settings.dir}/../../local-repo/release/[organisation]/[module]/[revision]/[artifact]-[revision].xml" /&gt;
        &lt;/filesystem&gt;
    &lt;/resolvers&gt;
&lt;/ivysettings&gt;
</code></pre>

<p>Ada beberapa hal yang harus dijelaskan di sini.</p>

<ul>
<li><p>defaultResolver : ini adalah resolver yang digunakan oleh Ivy bila kita tidak secara eksplisit memilih resolver. Setting ini akan berguna nantinya bila kita mendeklarasikan dependensi</p></li>
<li><p>defaultCacheDir : menyebutkan lokasi cache di komputer lokal. Bila tidak dikonfigurasi, Ivy akan menyimpan cache di folder <code>.ivy2/cache</code> dalam home folder user.</p></li>
<li><p>Variabel ${ivy.settings.dir} : lokasi folder tempat file <code>ivysettings.xml</code> berada</p></li>
<li><p>Artifact Pattern : struktur folder tempat artifak disimpan</p></li>
<li><p>Ivy Pattern : struktur folder tempat metadata modul disimpan. Kita akan membahas tentang metadata ini nanti.</p></li>
</ul>


<p>Selanjutnya, kita butuh repository yang bisa digunakan seluruh tim dan programmer dalam perusahaan. Ini berguna bila modul yang kita buat akan digunakan oleh tim lain. Untuk itu, kita akan mengkonfigurasi repository yang akan kita beri nama company. Agar aman, kita gunakan protokol scp untuk memindahkan file ke server. Otentikasinya menggunakan public/private key supaya semua artifact disimpan dengan nama user yang sama. Berikut konfigurasi resolvernya. Tambahkan di bawah resolver local.</p>

<pre><code>&lt;ssh name="company" keyFile="${user.home}/.ssh/id_rsa" host="nama-servernya" user="user-untuk-login-di-server"&gt;
    &lt;ivy
        pattern="/lokasi-folder-di-server/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact
        pattern="/lokasi-folder-di-server/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/ssh&gt;
</code></pre>

<p>Kita telah memiliki dua resolver, satu untuk repository di komputer lokal, dan satu lagi repository yang disharing ke seluruh organisasi.</p>

<h3>Target Resolve dan Publish</h3>

<p>Setelah kita melakukan konfigurasi resolver, sekarang kita bisa mempublish artifact dari modul person-model.
Untuk melakukan publishing, kita perlu membuat target di buildfile kita. Agar buildfile tetap rapi, kita buat file baru, yaitu <code>ivy-builder.xml</code>, diletakkan di modul <code>person-build</code>. File ini nantinya akan kita import di <code>build.xml</code> dalam masing-masing modul. Berikut isi file <code>ivy-builder.xml</code></p>

<pre><code>&lt;project name="ivy-related-targets" xmlns:ivy="antlib:org.apache.ivy.ant"&gt;

    &lt;target name="resolve" description="--&gt; resolve and retrieve dependencies with ivy"&gt;
        &lt;ivy:retrieve 
            sync="true"
            pattern="lib/[conf]/[artifact].[ext]"
        /&gt;
    &lt;/target&gt;

    &lt;target name="clean-cache" description="--&gt; clean the ivy cache"&gt;
        &lt;ivy:cleancache /&gt;
    &lt;/target&gt;


    &lt;target name="publish-local" depends="build" description="--&gt; publish this project in the ivy repository"&gt;
        &lt;property name="revision" value="${build.version}" /&gt;
        &lt;delete file="${build.dir}/ivy.xml" /&gt;
        &lt;ivy:publish 
            artifactspattern="${dist.dir}/[artifact].[ext]" 
            resolver="local" 
            pubrevision="${revision}" 
            status="${release.type}" 
            update="true" 
            overwrite="true" 
        /&gt;
        &lt;echo message="project ${ant.project.name} released locally with version ${revision} and status ${release.type}" /&gt;
    &lt;/target&gt;

    &lt;target name="publish-company" depends="build" description="--&gt; publish this project to company repository"&gt;
        &lt;property name="revision" value="${build.version}" /&gt;
        &lt;delete file="${build.dir}/ivy.xml" /&gt;
        &lt;ivy:publish 
            artifactspattern="${dist.dir}/[artifact].[ext]" 
            resolver="company" 
            pubrevision="${revision}" 
            status="${release.type}" 
            update="true" 
            overwrite="true" 
        /&gt;
        &lt;echo message="project ${ant.project.name} released to company repo with version ${revision} and status ${release.type}" /&gt;
    &lt;/target&gt;

    &lt;target name="ivy-report" depends="resolve" description="--&gt; generate dependency report"&gt;
        &lt;ivy:report todir="build/ivy-report"/&gt;
    &lt;/target&gt;

&lt;/project&gt;
</code></pre>

<p>Terlihat dari target publish di atas bahwa kita membutuhkan dua variabel untuk melakukan publish, yaitu <code>${revision}</code> dan <code>${release.type}</code>. Kedua variabel ini akan kita sediakan pada masing-masing modul.</p>

<p>Bila kita ingin mempublish artifact, terlebih dulu kita harus melakukan build. Kita juga memiliki target resolve untuk menentukan dependency. Target resolve ini dijalankan sebelum melakukan kompilasi. Dengan demikian, kita harus menyesuaikan target compile dalam <code>default.xml</code> agar menjalankan resolve sebelum compile. Ubah baris berikut dalam <code>default.xml</code></p>

<pre><code>&lt;target name="compile" depends="prepare"&gt;
    &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
&lt;/target&gt;
</code></pre>

<p>menjadi seperti ini.</p>

<pre><code>&lt;target name="compile" depends="resolve, prepare"&gt;
    &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
&lt;/target&gt;
</code></pre>

<h3>Mempublish Artifact</h3>

<p>Sekarang kita ingin mempublish artifact yang dihasilkan modul <code>person-model</code>. Seperti kita ketahui pada artikel sebelumnya, bila kita menjalankan target build, akan dihasilkan dua jar dalam folder <code>dist</code>, yaitu <code>person-model.jar</code> dan <code>person-model-sources.jar</code>. Kita akan mempublish kedua artifak ini ke repository.</p>

<p>Pastikan file <code>ivy-builder.xml</code> sudah diimport dalam <code>build.xml</code>. Isi <code>build.xml</code> harusnya terlihat seperti ini.</p>

<pre><code>&lt;project name="person-model" default="build"&gt;
    &lt;property file="build.properties"/&gt;

    &lt;import file="${basedir}/../person-build/default.xml"/&gt;
    &lt;import file="${basedir}/../person-build/ivy-builder.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>File tersebut mengacu pada file <code>build.properties</code>. Berikut isi file <code>build.properties</code>.</p>

<pre><code>build.version = 0.0.1
release.type = integration
</code></pre>

<p>Kedua variabel di atas digunakan untuk mengisi variabel <code>${build.version}</code> dan <code>${release.type}</code> yang dibutuhkan target publish di atas. Setiap kali kita melakukan publish, kita harus menentukan versi dan jenis artifak tersebut.</p>

<p>Nomer versi (build.version) tidak sulit dipahami. Untuk menentukan mana yang lebih baru, tinggal dibandingkan versi major, minor, dan micronya. Release type membutuhkan penjelasan lebih lanjut.</p>

<p>Secara default, Ivy memiliki tiga jenis release, diurutkan dari yang paling experimental sampai yang paling stabil: integration, milestone, dan release. Kita juga bisa mendefinisikan jenis release sendiri, dengan menggunakan tag status dalam <code>ivysettings.xml</code>. Untuk kebutuhan kita, tiga status yang disediakan Ivy sudah memadai.</p>

<p>Selanjutnya, kita mendefinisikan beberapa metadata yang berkaitan dengan artifact yang ingin dipublish, yaitu:</p>

<ul>
<li><p>Nama organisasi kita. Ini akan digunakan Ivy untuk mengatur struktur folder dalam repository</p></li>
<li><p>Nama modul yang akan dipublish</p></li>
<li><p>Daftar artifak yang akan dipublish. Satu modul bisa mempublish banyak artifak, misalnya: *.jar yang berisi hasil compile, javadoc, source-code, dsb</p></li>
</ul>


<p>Metadata tersebut ditulis dalam file yang bernama <code>ivy.xml</code>. Diletakkan di sebelah <code>build.xml</code>. Berikut isinya.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="com.artivisi.tutorial.ivy.model"/&gt;
    &lt;publications&gt;    
        &lt;artifact name="${ant.project.name}"/&gt;
        &lt;artifact name="${ant.project.name}-sources" type="src" ext="jar"/&gt;
    &lt;/publications&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Setelah semuanya lengkap, kita tinggal memanggil</p>

<pre><code>ant publish-local 
</code></pre>

<p>untuk mempublish ke repository local, atau</p>

<pre><code>ant publish-company
</code></pre>

<p>untuk mempublish ke repository shared. Bila dalam proses pembuatan private key kita menggunakan password, akan muncul dialog box yang menanyakan password. Isikan nama user yang digunakan untuk login ke server dan password dari private key kita. Sekali lagi, username yang dimasukkan adalah username di server, sedangkan password yang dimasukkan adalah password untuk private key kita sendiri. Jadi, kita tidak memasukkan password dari username di server.</p>

<p>Setelah dijalankan, kita akan melihat banyak file dalam repository. Ivy akan merilis: <code>person-model-0.0.1.jar</code>, <code>person-sources-0.0.1.jar</code>, dan <code>ivy-0.0.1.xml</code> yang berisi metadata dari rilis tersebut. Setiap file disertai signature md5 dan sha1 untuk kebutuhan verifikasi keabsahan file.</p>

<p>Berikut struktur folder keseluruhan.
<img src="/images/uploads/2008/09/struktur-folder-4-all.png" title="" ></p>

<p>Isi folder local repo sebagai berikut.</p>

<p><img src="/images/uploads/2008/09/struktur-folder-4-local-repo.png" title="" ></p>

<p>Isi folder person-build sebagai berikut.</p>

<p><img src="/images/uploads/2008/09/struktur-folder-4-person-build.png" title="" ></p>

<p>Isi folder person-model sebagai berikut.
<img src="/images/uploads/2008/09/struktur-folder-4-person-model.png" title="" ></p>

<p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-5">artikel selanjutnya</a>, kita akan membahas bagaimana cara mengambil artifact yang sudah dipublish tersebut.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/java/manajemen/ant-ivy-3/">Otomasi Build Process Dengan Ant</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2008-09-09T16:48:30+07:00" pubdate data-updated="true">Sep 9<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Setelah pada artikel sebelumnya kita memahami <a href="http://endy.artivisi.com/blog/java/ant-ivy-2">mengapa dan kapan kita butuh Ivy</a>, mulai dari artikel ini, kita akan menjalani langkah demi langkah supaya kegiatan build kita benar-benar terintegrasi dan efisien.</p>

<p>Pada artikel ini, kita akan membuat satu modul dulu, yang sama sekali tidak memiliki dependensi, yaitu modul <code>person-model</code>.
Kita akan mengotomasi proses build untuk modul ini, kemudian menyiapkan infrastruktur lainnya sehingga siap untuk digunakan oleh modul lainnya.</p>

<p>Tiap modul yang kita buat, setara dengan satu project dalam IDE. Dalam IDE kita dapat mendaftarkan (membuat referensi ke) project lain dalam build-path sehingga tidak muncul peringatan compile error.</p>

<p>Berikut struktur folder modul <code>person-model</code>.</p>

<p><img src="/images/uploads/2008/09/01-project-person-model.png" title="" ></p>

<p>Tidak ada yang istimewa, kita memiliki build.xml disertai dengan folder <code>src</code> yang berisi source code java. Kita ingin agar struktur folder kita seragam di semua modul, jadi untuk seluruh modul nantinya strukturnya akan sama.</p>

<p>Kita hanya memiliki satu file source code sederhana, <code>Person.java</code> sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.model;

import java.util.Date;

public class Person {
    private Integer id;
    private String name;
    private Date birthdate;

    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    public void setBirthdate(Date birthdate) {
        this.birthdate = birthdate;
    }   
}
</code></pre>

<p>Sebagai rangkaian build, kita akan melakukan kegiatan sebagai berikut:</p>

<ul>
<li><p>Bersihkan hasil kompilasi sebelumnya (clean)</p></li>
<li><p>Kompilasi (compile)</p></li>
<li><p>Distribusi, membuat file *.jar dari hasil kompilasi (build)</p></li>
</ul>


<p>Rangkaian kegiatan tersebut kita tuliskan dalam file <code>build.xml</code>, sebagai berikut</p>

<pre><code>&lt;project name="person-model"&gt;

    &lt;property name="src.java.dir" value="src/java" /&gt;
    &lt;property name="compile.dir" value="build/bin" /&gt;
    &lt;property name="dist.dir" value="build/dist" /&gt;

    &lt;path id="compile.classpath"&gt;
        &lt;pathelement location="${src.java.dir}" /&gt;
        &lt;fileset dir="lib" includes="**/*.jar" /&gt;
    &lt;/path&gt;

    &lt;target name="prepare"&gt;
        &lt;mkdir dir="lib" /&gt;
        &lt;mkdir dir="build" /&gt;
        &lt;mkdir dir="${compile.dir}" /&gt;
        &lt;mkdir dir="${dist.dir}" /&gt;
    &lt;/target&gt;

    &lt;target name="clean"&gt;
        &lt;delete dir="build" /&gt;
        &lt;delete dir="lib" /&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="prepare"&gt;
        &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
    &lt;/target&gt;

    &lt;target name="build" depends="compile"&gt;
        &lt;!-- binary distribution --&gt;
        &lt;jar destfile="${dist.dir}/${ant.project.name}.jar"&gt;
            &lt;fileset dir="${compile.dir}"&gt;
                &lt;exclude name="**/*Test.class"/&gt;
            &lt;/fileset&gt;
        &lt;/jar&gt;

        &lt;!-- source distribution --&gt;
        &lt;jar destfile="${dist.dir}/${ant.project.name}-sources.jar"&gt;
            &lt;fileset dir="${src.java.dir}"&gt;
                &lt;exclude name="**/*Test.java"/&gt;
            &lt;/fileset&gt;
        &lt;/jar&gt;
    &lt;/target&gt;
&lt;/project&gt;
</code></pre>

<p>Selanjutnya, kita bisa coba melakukan build.</p>

<pre><code>ant build
</code></pre>

<p>Nanti Ant akan menghasilkan file <code>person-model.jar</code> dan <code>person-model-sources.jar</code> dalam folder dist.</p>

<p>File <code>build.xml</code> ini nantinya akan kita gunakan di seluruh modul. Seluruh modul tentunya butuh kegiatan kompilasi dan membuat jar. Untuk menghindari perulangan dan copy-paste, kita simpan <code>build.xml</code> ini di folder bersama, kita beri nama saja person-build.</p>

<p>Karena digunakan di banyak modul, kita perlu melakukan penyesuaian sedikit, yaitu namanya kita ganti menjadi <code>default.xml</code>. Deklarasi nama project juga diganti, dari seperti ini:</p>

<pre><code>&lt;project name="person-model"&gt;
</code></pre>

<p>menjadi seperti ini:</p>

<pre><code>&lt;project name="default-build"&gt;
</code></pre>

<p>Struktur foldernya menjadi seperti ini</p>

<p><img src="/images/uploads/2008/09/02-project-person-build.png" title="" ></p>

<p>Selanjutnya, dalam build.xml di project person-model, kita hanya perlu melakukan import saja. Isi <code>build.xml</code> menjadi seperti ini:</p>

<pre><code>&lt;project name="person-model" default="build"&gt;

    &lt;import file="${basedir}/../person-build/build.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>Silahkan coba lakukan build di dalam folder <code>person-model</code>. Seharusnya modul ini bisa dibuild tanpa error, sama seperti sebelumnya.</p>

<p>Bila modul person-model sudah lancar, kita bisa mulai mereplikasi modul-modul yang lainnya. Dengan semua modul sudah dibuatkan sesuai template, berikut struktur foldernya.</p>

<p><img src="/images/uploads/2008/09/03-project-all.png" title="" ></p>

<p>File <code>build.xml</code> di masing-masing project mirip dengan person-model, hanya dibedakan di baris pertama saja.</p>

<pre><code>&lt;project name="person-model"&gt;
</code></pre>

<p>Sesuaikan dengan nama modul masing-masing.</p>

<p>Persiapan template project kita sudah selesai. Sampai tahap ini, kita hanya memiliki satu source-code java, yaitu Person.java. Source-code ini akan dipaket menjadi file distribusi <code>person-model.jar</code> (binary) dan <code>person-model-sources.jar</code> (source-code). Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-4/">artikel selanjutnya</a>, kita akan mempublikasikan distribusi ini agar bisa digunakan oleh modul lain.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/18/">&larr; Older</a>
    
    <a href="/archives">Blog Archives</a>
    
    <a class="next" href="/page/16/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/aplikasi/terima-kasih-wordpress/">Terima kasih Wordpress</a>
      </li>
    
      <li class="post">
        <a href="/java/konsep-dasar-log4/">Konsep Dasar Log4j</a>
      </li>
    
      <li class="post">
        <a href="/java/monitoring-aplikasi-java/">Monitoring Aplikasi Java</a>
      </li>
    
      <li class="post">
        <a href="/linux/backup-home-folder/">Backup Home Folder</a>
      </li>
    
      <li class="post">
        <a href="/java/manajemen/staged-deployment/">Staged Deployment</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/meluruskan-mitos-cmmi/">Meluruskan Mitos CMMI</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/linux/redmine-jruby-tomca/">Instalasi Redmine di Tomcat</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/programming/instalasi-spket-ide/">Instalasi Spket IDE</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/linux/membuat-screencast/">Membuat Screencast</a>
      </li>
    
      <li class="post">
        <a href="/java/php/tutorial-extjs/">Tutorial ExtJS</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/110971146012275775230?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
