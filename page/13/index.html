
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Belajar bahasa pemrograman mirip dengan belajar bahasa manusia. Bahasa pertama adalah yang paling sulit. Ini disebabkan karena kita belum paham &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://software.endy.muhardin.com/page/13/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36102948-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:software.endy.muhardin.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="my_site_title">
            Living life and make it better
        </span>
       
           <span class="my_site_subtitle">
             life, learn, contribute
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/calendar">Calendar</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/road-to-java-se/">Road to Java SE</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-07-13T17:56:34+07:00" pubdate data-updated="true">Jul 13<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Belajar bahasa pemrograman mirip dengan belajar bahasa manusia. Bahasa pertama adalah yang paling sulit. Ini disebabkan karena kita belum paham istilah-istilah yang digunakan, pola umum menyusun kata, dan ungkapan-ungkapan khusus yang biasa digunakan dalam bahasa tertentu.</p>

<p>Mari kita ingat waktu pertama kali belajar bahasa Inggris (bahasa Indonesia tidak dihitung, karena kita sudah bisa dari kecil). Pertama kali, kita sama sekali tidak tahu vocabulary. Kemudian kita belajar tentang susunan kata, Subjek-Predikat-Objek. Belajar kalimat aktif dan pasif.</p>

<p>Demikian juga dengan bahasa pemrograman. Bahasa pertama selalu paling sulit. Setelah kita menguasai satu bahasa, belajar bahasa berikutnya tidak sesulit yang pertama. Misalnya kita butuh waktu enam bulan untuk menguasai Java, maka untuk belajar PHP mungkin cuma butuh 2 bulan.</p>

<p>Dengan asumsi kita sama sekali belum pernah mengenal bahasa pemrograman, berikut adalah peta jalan untuk belajar bahasa pemrograman Java.</p>

<p>Pertama, kita kumpulkan dulu perlengkapan belajarnya. Kita membutuhkan:</p>

<ul>
<li><p>Java SDK</p></li>
<li><p>Java Tutorial dari Sun</p></li>
<li><p>Javadoc API</p></li>
<li><p>Text Editor yang bisa memberi warna (syntax highlighting)</p></li>
</ul>


<p>Pada tahap ini, jangan menggunakan editor canggih &#8211;biasa disebut Integrated Development Environment (IDE)&#8211; macam Eclipse, Netbeans, dan lainnya. IDE memiliki fitur yang canggih dan juga kompleks. Di awal masa belajar, kita ingin belajar tentang bahasa Java, bukan penggunaan tombol dan wizard.</p>

<p>Setelah itu, instal Java SDK. Tergantung metode instalasi Anda, mungkin Anda perlu mengatur environment variabel JAVA_HOME dan PATH. JAVA_HOME mengarah ke folder tempat instalasi Java SDK, sedangkan PATH mengarah pada folder bin di dalam lokasi JAVA_HOME.</p>

<p>Untuk mengetes apakah instalasi Anda sudah berhasil, coba ketik perintah berikut di command prompt:</p>

<pre><code>javac -version
</code></pre>

<p>Bila keluar pesan error &#8220;perintah javac tidak ditemukan&#8221; berarti environment variabel masih belum diatur dengan benar.</p>

<p>Perhatikan bahwa setelah mengatur environment variabel, kita harus merestart command prompt. Command prompt baik di Windows maupun Linux tidak dapat mendeteksi perubahan environment variabel secara instan.</p>

<p>Selanjutnya, buat kode program sederhana. Dalam semua bahasa pemrograman, kode ini disebut HelloWorld. Kode program ini hanya mencetak tulisan <strong>Hello World</strong> ke layar komputer.</p>

<p>Coba kompilasi dan jalankan program HelloWorld tersebut. Dari sini Anda akan mengetahui beberapa konsep, yaitu:</p>

<ul>
<li><p>Cara kompilasi kode program Java</p></li>
<li><p>Cara menjalankan aplikasi Java</p></li>
<li><p>Konsep CLASSPATH</p></li>
</ul>


<p>Begitu kita sudah bisa mengkompilasi dan menjalankan kode program Java, kita bisa mulai belajar prinsip umum pemrograman. Prinsip ini sama di semua bahasa pemrograman, walaupun cara penulisannya berbeda. Berikut prinsip-prinsip yang perlu dipelajari:</p>

<ol>
<li><p>Anatomi aplikasi. Di Java, aplikasi terdiri dari banyak package, satu package berisi banyak class, satu class berisi banyak property dan method, satu method terdiri dari banyak statement.</p></li>
<li><p>Menggunakan variabel</p></li>
<li><p>Macam-macam tipe data</p></li>
<li><p>Operator</p></li>
<li><p>Statement, Comment, Expression</p></li>
<li><p>Method, function, atau procedure. Istilah mana yang digunakan tergantung bahasa yang dipelajari</p></li>
<li><p>Penggunaan variabel sebagai argumen dan return value. Pelajari juga pass-by-value vs pass-by-reference dan scope variabel</p></li>
<li><p>Control Flow, meliputi percabangan menggunakan if-else dan switch, dan perulangan dengan while atau for.Ketahui juga keyword control flow seperti break, return, dan exit.</p></li>
<li><p>Setelah mahir menggunakan variabel skalar, pelajari variabel majemuk. Variabel majemuk ini ada di semua bahasa pemrograman. Biasanya ada dua kategori dasar, yaitu yang menggunakan indeks numerik dan indeks non-numerik. Di PHP variabel majemuk berindeks numerik disebut dengan numeric-array, sedangkan yang berindeks non-numerik disebut associative-array. Di Java pilihan lebih banyak. Untuk indeks numerik ada List dan array. Sedangkan indeks non-numerik diwakili oleh Map. Java juga punya variabel majemuk yang dinamakan Set, yang tidak memiliki indeks berurut, tapi bisa digunakan untuk mencegah elemen yang duplikat. Pelajari konsep, implementasi, dan penggunaannya.</p></li>
</ol>


<p>Beberapa latihan yang dapat digunakan untuk memahami prinsip dasar ini antara lain:</p>

<ul>
<li><p>Hitung jumlah hari dalam bulan dan tahun tertentu</p></li>
<li><p>Tampilkan nama sendiri secara berulang sebanyak jumlah hurufnya</p></li>
<li><p>Hitung faktorial</p></li>
<li><p>Deret Fibonacci</p></li>
<li><p>dan sebagainya</p></li>
</ul>


<p>Salah satu keunggulan Java adalah dukungannya terhadap Object Oriented Programming. Sekarang, setelah menguasai cara kerja bahasa pemrograman melalui prinsip-prinsip di atas, kita belajar tentang bagaimana mendesain aplikasi dengan menggunakan prinsip orientasi objek.</p>

<p>Langkah-langkah belajar OOP adalah:</p>

<ol>
<li><p>Belajar apa itu class dan apa itu object. Kalau di Java, ketahui perbedaan antara class dan instance. Perbedaan antara static variable dan instance variable.</p></li>
<li><p>Encapsulation</p></li>
<li><p>Inheritance</p></li>
<li><p>Polymorphism</p></li>
<li><p>Banyak orang mengalami kesulitan dalam menjelaskan, apalagi mempelajari encapsulation, inheritance, dan polymorphism. Berdasarkan pengalaman saya, design pattern dapat digunakan untuk membantu pemahaman ketiga konsep OO tersebut. Gunakan Strategy pattern untuk memahami polymorphism, Factory pattern untuk memahami encapsulation, dan Template Method untuk memahami Inheritance. Cukup dengan tiga pattern ini, seharusnya konsep OO sudah bisa dipahami dengan baik</p></li>
</ol>


<p>Beberapa bahasa pemrograman seperti Java, Ruby, C# memiliki fitur Exception Handling. Pelajari fitur ini. Khusus Java, pelajari bedanya Error, Checked Exception, dan Unchecked Exception. Yang lebih penting, kenali karakteristik masing-masing dan kapan harus menggunakannya.</p>

<p>Semua bahasa pemrograman modern sudah memiliki infrastruktur Input/Output Stream. I/O Stream ini digunakan untuk membaca dan menulis data ke berbagai tujuan, misalnya file, jaringan, object, dan sebagainya. Dengan menggunakan I/O Stream, teknik baca/tulis file mirip dengan terima/kirim data dari jaringan.</p>

<p>Sebagai latihan, coba buat aplikasi chatting sederhana.</p>

<p>Terakhir, pelajari fitur-fitur Java yang advanced, seperti:</p>

<ul>
<li><p>Multithreading</p></li>
<li><p>Reflections API</p></li>
<li><p>Annotations</p></li>
<li><p>Generics</p></li>
<li><p>Enum</p></li>
</ul>


<p>Kalau sudah sampai di sini, pengetahuan Anda sudah cukup untuk meneruskan sendiri. Bila ingin membuat aplikasi bisnis, pelajari JDBC, kemudian ikuti <a href="http://endy.artivisi.com/blog/java/road-to-java-ee/">Road to Java EE</a>. Bila ingin membuat aplikasi daemon seperti web server atau sms gateway, dalami multithreading, classloading, socket programming, dan lainnya. Bila ingin konsentrasi di mobile, pelajari Java ME.</p>

<p>Demikian panduan singkat untuk belajar bahasa pemrograman Java. Tidak ada yang instan di dunia ini, termasuk belajar bahasa pemrograman. Bila Anda sama sekali belum pernah coding, Anda butuh waktu paling tidak 6 bulan untuk menguasai Java. Bila sudah pernah menggunakan bahasa non-OOP, butuh waktu sekitar 2-3 bulan. Perkiraan waktu ini sekedar gambaran saja, mungkin juga ada yang 2 minggu sudah bisa, atau 2 tahun masih belum bisa. Tergantung kondisi.</p>

<p>Setelah menguasai bahasanya, selanjutnya menguasai (Application Programming Interface) API yang dibutuhkan untuk menyelesaikan pekerjaan. Kemudian masih ada framework untuk membantu pembuatan aplikasi. Jangan lupa, kita masih harus belajar menggunakan tools seperti IDE, Ant, Maven, JUnit, Subversion, agar kita bisa bekerja secara efektif dan efisien.</p>

<p>Selamat belajar Java.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/life/wirausaha/">Wirausaha</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-07-04T18:01:08+07:00" pubdate data-updated="true">Jul 4<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Tiga bulan yang lalu, tepatnya Februari 2008, saya membuat keputusan signifikan sepanjang kehidupan saya.
Yaitu berpindah sisi meja, dari menerima gaji, menjadi memberi gaji alias mendirikan perusahaan sendiri. Padahal kantor tempat saya bekerja merupakan perusahaan terkenal, posisi saya strategis dan menantang, dan lingkungan kerjanya menyenangkan.</p>

<p>Perubahan ini, terutama bagi mereka yang sudah cukup lama bekerja di perusahaan dan sudah berkeluarga, merupakan hal yang menakutkan.
Pada waktu kita masih single, kalau ada kesulitan keuangan, yang menderita cukup diri sendiri saja. Sedangkan bila kita sudah berkeluarga, bokek bisa berakibat fatal bagi istri dan anak. Saya pernah mengalami masa melarat dulu di Surabaya sekitar tahun 2001-2002. Saking bokeknya, kami (saya dan teman-teman serumah) tidak punya uang untuk membeli lauk. Hanya ada nasi. Akhirnya, kami memetik daun kelor yang tumbuh di pekarangan dan merebusnya sebagai teman nasi. Jika ada yang memiliki ilmu kebatinan, pasti akan luntur seketika :p. Setelah berkeluarga, tentunya kita ingin memastikan bahwa jangan sampai anggota keluarga kita terpaksa makan sayur daun kelor.</p>

<p>Tidak sedikit teman-teman yang bertanya bagaimana cara melakukan peralihan dari karyawan menjadi wirausahawan dengan mulus. Yah, saat ini saya juga masih belum menjadi pengusaha sukses. Masih berjuang. Tapi ada sedikit pengalaman yang bisa saya ceritakan pada mereka-mereka yang ingin mengikuti jejak saya.</p>

<p>Di jaman serba sulit seperti ini, akan lebih baik jika kita bisa mandiri menciptakan lapangan pekerjaan sendiri. Jadi, semakin banyak pengusaha, semakin cepat Indonesia akan bangkit dari keterpurukan nasional.</p>

<p>Kerja kantoran dulu kemudian buka usaha sendiri berbeda dengan lulus sekolah dan langsung buka usaha. Masing-masing ada plus-minusnya.</p>

<p>Jika kita langsung buka usaha, kita biasanya akan:</p>

<ul>
<li><p>terbiasa dengan kondisi finansial yang tidak menentu. Kadang kaya raya, kadang melarat.</p></li>
<li><p>memiliki jiwa sales (ini adalah karakteristik penting yang akan saya bahas lebih lanjut nanti)</p></li>
<li><p>berorientasi hasil, bukan jam kerja</p></li>
<li><p>miskin pengalaman, sehingga usaha sulit maju</p></li>
</ul>


<p>Sebaliknya, bila kita jadi karyawan dulu, biasanya kita:</p>

<ul>
<li><p>terbiasa gajian di akhir bulan dengan jumlah fixed.</p></li>
<li><p>naluri pemburu kurang terasah, kecuali yang bekerja di lini penjualan</p></li>
<li><p>berorientasi jam kerja, lewat jam kantor masih kerja, hitung lembur</p></li>
<li><p>sudah mengenal sistem birokrasi kantoran dengan hirarki kekuasaan dan wewenang</p></li>
<li><p>terbiasa dengan prosedur yang baku (bila bekerja di perusahaan yang rapi)</p></li>
</ul>


<p>Masing-masing starting-position memiliki plus minusnya. Yang akan kita bahas sekarang adalah start dari posisi karyawan. Mungkin lain waktu kita akan bahas tentang start langsung jadi pengusaha.</p>

<p>Untuk bisa beralih dengan mulus, ada beberapa persiapan terutama dari aspek pola pikir dan gaya hidup.</p>

<p>Pola pikir yang dibutuhkan adalah:</p>

<ul>
<li><p>Orientasi terhadap hasil</p></li>
<li><p>Sense of urgency</p></li>
<li><p>Kepekaan terhadap peluang</p></li>
</ul>


<p>Sedangkan gaya hidup yang dibutuhkan adalah:</p>

<ul>
<li><p>Multiple Stream of Income (MSI).</p></li>
<li><p>Aktif di komunitas, baik fisik maupun maya.</p></li>
</ul>


<p>Mari kita bahas satu persatu.</p>

<h3>Orientasi Hasil</h3>

<p>Bila kita menjadi karyawan swasta &#8211;apalagi di industri IT&#8211;, kita sulit untuk santai. Selalu ada atasan yang memantau kinerja kita. Terlihat chatting atau browsing, pasti akan langsung diajak diskusi mengenai pemanfaatan jam kerja yang efisien. Dengan demikian, performa kita akan selalu kinclong, karena dimonitor dan diingatkan sepanjang waktu.</p>

<p>Lain halnya bila kita menjadi wirausahawan. Tidak ada lagi atasan yang memantau kinerja kita dan mengingatkan bila kita mulai tidak fokus. Mau berpola hidup PNS, monggo. Mau sampai di kantor jam 11 pulang jam 14, silahkan.</p>

<p>Ini merupakan tantangan bagi kita. Kita harus memacu diri sendiri untuk menghasilkan sesuatu. Bila kita programmer, harus menghasilkan kode program. Bila kita instruktur pelatihan, harus menghasilkan modul pelatihan dan slide presentasi. Tanpa orientasi terhadap hasil, dapur bisa berhenti ngebul.</p>

<h3>Sense of Urgency</h3>

<p>Mirip dengan orientasi hasil, di lingkungan karyawan kita memiliki atasan yang rajin menagih hasil kerja kita. Setelah hasil kerja kita serahkan, biasanya akan diperiksa dulu sebelum kita berikan pada client.</p>

<p>Berbeda halnya bila kita berwirausaha. Bila kita tidak memiliki sense of urgency, semua delivery ke client akan terlambat dan berkualitas rendah, karena tidak ada yang menagih dan memeriksa pekerjaan kita.</p>

<p>Kedua hal ini, orientasi hasil dan sense of urgency sepintas nampak seperti hal sepele dan sudah menjadi kondisi yang umum. Tapi walaupun ini terkesan common sense, tapi ternyata sangat berat dilakukan tanpa adanya atasan yang mengawasi. Penguasaan kita terhadap dua hal ini akan menentukan apakah kita bermental bos atau karyawan. Tanpa kedua hal ini, walaupun kita menjadi karyawan, sulit untuk meningkatkan karir di kantor.</p>

<h3>Kepekaan terhadap peluang</h3>

<p>Sebagai karyawan, bila tidak berada di departemen business development, marketing, atau sales, biasanya kita tidak mampu mengenali peluang bisnis. Kepekaan terhadap peluang adalah suatu kemampuan yang harus dilatih terus menerus, mirip seperti kemampuan mendesain aplikasi.</p>

<p>Saat belum terlatih, kita tidak bisa melihat peluang bisnis, bahkan walaupun sudah disodorkan di depan mata. Berikutnya, kita bisa mengenali peluang, tapi belum bisa membedakan mana yang angin surga dan mana peluang betulan. Bila sudah mahir, kita bisa mengendus dari sekian banyak peluang, mana yang akan menghasilkan imbal hasil yang paling menguntungkan.</p>

<p>Inilah yang saya sebut di atas &#8220;memiliki jiwa sales&#8221;. Sebagai pendiri perusahaan, tugas utama kita adalah mendatangkan bisnis ke dalam perusahaan. Menjadi seorang deal-maker. Bila perusahaan kita tidak mendapat project, karyawan tidak ada kerjaan, ini adalah tanggung jawab founder.</p>

<p>Tanpa kemampuan ini, perusahaan tidak akan jalan, tidak peduli sepintar apapun programmer yang dimiliki. No sales, no company.</p>

<h3>Multiple Stream of Income</h3>

<p>Sebagai karyawan yang loyal, biasanya kita hanya memiliki satu sumber penghasilan, yaitu gaji. Kondisi ini menyulitkan kita bila tiba-tiba ingin banting setir menjadi pengusaha. Seperti kita tahu, menjadi pengusaha penuh dengan ketidakpastian income. Kadang panen raya, kadang paceklik. Tidak ada bisnis yang terus menerus sukses. Bila Anda percaya ada bisnis yang tidak bisa gagal, hati-hati, bisa jadi Anda akan masuk koran sebagai investor blue energy yang ternyata palsu.</p>

<p>Untuk mengatasi perbedaan suasana ini, saya anjurkan untuk membiasakan diri mencari penghasilan tambahan di luar gaji. Setidaknya selama dua sampai tiga tahun, cobalah untuk mencari penghasilan diluar gaji. Tentunya dilakukan dengan <a href="http://endy.artivisi.com/blog/life/nyambi-bolehkah/">cara yang profesional dan etis</a>. Bila sumber penghasilan kita sudah lebih dari satu, maka kita sudah memiliki Multiple Stream of Income (MSI).</p>

<p>Ada beberapa keuntungan yang didapat dari MSI ini. Pertama, terutama bagi eks-karyawan, ini akan menghilangkan paradigma kita bahwa yang namanya penghasilan hanyalah dari gaji bulanan. Kedua, ini akan mengasah kepekaan kita terhadap peluang bisnis. Ketiga, ini akan melatih kita berorientasi hasil dan memiliki sense of urgency. Keempat, ini akan menambah keyakinan diri bahwa tanpa gaji rutin kita tetap bisa survive.</p>

<p>Saya sendiri sudah memiliki MSI sejak lulus kuliah. Dua tahun terakhir sebelum saya benar-benar berhenti jadi karyawan, saya mulai mencatat income saya, baik dari gaji maupun dari yang lainnya. Di akhir tahun pertama, proporsi pendapatan gaji dengan non-gaji berbanding 85:15. Di tahun kedua, proporsinya naik menjadi 65:35. Artinya, hanya dengan menggunakan 10-15% waktu, saya mampu menghasilkan 35% penghasilan tahunan saya.</p>

<p>Kemudian hal ini saya bicarakan dengan keluarga. Siapkah mereka hidup dengan hanya 35% saja dari income biasa? Tentunya dengan imbalan waktu yang lebih fleksibel untuk keluarga dan potensi penghasilan yang tidak terbatas.</p>

<p>Alhamdulillah keluarga saya menyatakan siap berjuang bersama. Saat ini, setelah lima bulan berjuang, rata-rata income saya sudah lebih dari gaji semasa kerja dulu. Tidak ada yang instan. Pada masa awal dulu, kami hidup prihatin dan mengencangkan ikat pinggang.</p>

<p>Paradigma MSI ini akan menjadi lebih penting setelah kita memiliki usaha sendiri. Bila kita mengerjakan project software development, harus selalu ada lebih dari satu project yang berjalan bersamaan. Bila kita mengadakan pelatihan, harus ada pemasukan dari sesi training, lisensi materi pelatihan, dan penjualan buku atau sampel kode program.</p>

<h3>Aktif di komunitas</h3>

<p>Rasulullah bersabda bahwa silaturahmi akan membuka pintu rejeki. Brian Tracy dan Robert Kiyosaki mengatakan bahwa aliran kas masuk berbanding lurus dengan komunikasi keluar. Hasilnya mungkin tidak terlihat langsung, tapi bisa terasakan dampaknya.</p>

<p>Di ArtiVisi, kita mengikuti filosofi tersebut. Saya dan Ifnu aktif mengisi blog dan berkontribusi di milis Java. Motif utamanya tentu saja sedekah ilmu dan mencari pahala. Kalau kemudian ada project yang datang dari komunitas, kami anggap itu sebagai bonus dan juga konsekuensi logis dari aktifitas tersebut.</p>

<p>Demikianlah sedikit sharing pengalaman mendirikan perusahaan baru. Masih panjang jalan yang harus ditempuh untuk membesarkan perusahaan yang baru seumur jagung ini. Di atas semua usaha, tentunya doa memiliki peranan yang paling penting.</p>

<p>Harapan saya, dengan artikel ini akan banyak pengusaha baru yang bisa membuka banyak lapangan kerja. Di satu sisi, banyak training centre dan software development company memang akan menambah saingan ArtiVisi. Tapi di sisi lain, kami jadi bisa berjualan lisensi materi pelatihan, project management training, dan consulting kepada para kompetitor.</p>

<p>Ayo jadi pengusaha !!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/apa-itu-cmmi/">Apa Itu CMMI?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-06-18T01:17:17+07:00" pubdate data-updated="true">Jun 18<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di <a href="http://tech.groups.yahoo.com/group/appli-member">milis Asosiasi Pengembang Perangkat Lunak Indonesia (APPLI)</a> ramai dibahas mengenai standarisasi dalam pengembangan perangkat lunak. Salah satu standar yang populer digunakan adalah CMMI (Capability Maturity Model Integration) yang dikembangkan oleh Carnegie-Mellon University, untuk lebih tepatnya dalam departemen Software Engineering Institute. Selain itu, ada juga blog <a href="http://arian75.wordpress.com/2008/06/16/sei-cmmi-maturity-apakah-ada-perusahaan-it-indonesia-yang-mendapatkannya/">ini</a> dan <a href="http://santus.wordpress.com/2008/02/04/cmmi-what-is-it-for/">ini</a> yang membahas tentang CMMI.</p>

<p>Dengan adanya standar, organisasi dapat berkembang dengan lebih terarah. Semua anggota organisasi mulai dari programmer, analis, tester, manajer, dan direktur menjadi tahu apa ruang lingkup pekerjaannya. Apa yang harus disediakan bagi pihak lain, dan juga apa yang bisa diharapkan dari departemen lain. Dengan demikian, tidak banyak effort yang terbuang karena miskomunikasi atau kurang koordinasi.</p>

<p>Sayangnya, dunia enterpreneur IT di Indonesia masih jarang yang hirau terhadap masalah standarisasi ini. Berbagai alasan dikemukakan, antara lain:</p>

<ul>
<li><p>Tidak mengerti bahasa Inggris</p></li>
<li><p>Standar luar negeri tidak cocok untuk kondisi lokal</p></li>
<li><p>Standar membuat organisasi monoton dan membosankan</p></li>
<li><p>dan segudang alasan lainnya</p></li>
</ul>


<p>Menurut saya, segala alasan itu cuma pembenaran saja untuk sifat malas belajar. Sebagai praktisi IT, tentunya kita sadar bahwa dunia tempat kita hidup sekarang (internet) dibangun di atas standar. Untuk bisa browsing, kita menggunakan protokol HTTP. Memeriksa email, menggunakan protokol POP3, IMAP, dan SMTP. Chatting, menggunakan protokol IRC, XMPP. Voice chat, menggunakan protokol SIP.</p>

<p>Protokol adalah nama lain dari standar. So, standar membuat hidup kita menjadi lebih baik. Setidaknya, standar apapun lebih baik daripada tanpa standar. Melalui artikel ini, mudah-mudahan para praktisi tergerak untuk setidaknya mempelajari dulu standar sebelum mengeluarkan vonis &#8220;tidak perlu&#8221; atau &#8220;tidak sesuai&#8221;.</p>

<p>Sekarang, mari kita lihat standarisasi dalam pengembangan perangkat lunak. Standar yang populer dan cukup saya kuasai adalah CMMI, jadi mari kita bahas tentang CMMI. Kebetulan saya pernah ikutan mengantarkan BaliCamp meraih CMMI Maturity Level 3.</p>

<h3>Apa itu CMMI</h3>

<p>CMMI adalah singkatan dari Capability Maturity Model Integration. Ini adalah kerangka kerja (framework) yang bisa digunakan untuk mengembangkan proses di dalam perusahaan.</p>

<p>Apa itu proses? Proses adalah cara kita melakukan suatu tugas. Misalnya, membuat proposal, menganalisa kebutuhan client, membuat kode program, dan kegiatan lainnya. Semua tata laksana kegiatan tersebut dikenal dengan nama proses atau prosedur.</p>

<p>CMMI membantu kita untuk memperbaiki proses di perusahaan/organisasi kita. Dengan membaiknya proses, diharapkan produk yang dihasilkan akan ikut menjadi baik.</p>

<p>CMMI dirumuskan oleh Software Engineering Institute di Carnegie Mellon University. Para peneliti di SEI telah mengamati proyek pembangunan perangkat lunak di seluruh dunia, mulai dari proyek kecil sampai proyek raksasa. Organisasi yang diteliti meliputi NASA, IBM, dan kontraktor Departemen Pertahanan Amerika Serikat. Pengalaman yang dimiliki organisasi tersebut dirangkum dalam seperangkat aturan yang disebut CMMI. Nah, apakah perusahaan kita sudah lebih canggih daripada organisasi di atas, dalam hal mengelola proyek software? Kalau belum, mari kita belajar dari mereka.</p>

<h3>Apa sih isinya CMMI ??</h3>

<p>CMMI terdiri dari rangkaian practices. Dalam rangkaian practices ini ada rambu-rambu atau rekomendasi yang dapat diikuti. Practices dalam CMMI dibagi menjadi dua, yaitu Generic Practices (GP) dan Specific Practices (SP).</p>

<p>Bila kita sudah mengimplementasikan practices dengan sempurna, kita dianggap sudah memenuhi Goals. Sama seperti practices, ada Generic Goals (GG) dan Specific Goals (SG).</p>

<p>SG dan SP dikelompokkan menjadi Process Area (PA). Total ada 22 Process Area dalam CMMI for Development versi 1.2.</p>

<p>Daftar PA, GG, SG, GP, dan SP dapat dilihat di spesifikasi CMMI yang bisa didonlod gratis <a href="http://www.sei.cmu.edu/publications/documents/06.reports/06tr008.html">di sini</a>.</p>

<h3>Apa hubungannya CMMI dengan standarisasi ISO</h3>

<p>CMMI dan ISO sama-sama standar yang digunakan untuk menilai proses suatu organisasi. Kalau kita programmer Java, kita punya sertifikasi SCJP, SCWD, SCBCD, dan sebagainya. Nah, anggap saja CMMI atau ISO ini adalah sertifikasinya perusahaan.</p>

<p>Kalau di SCJP yang dinilai adalah penguasaan kita terhadap bahasa pemrograman Java, maka di ISO/CMMI yang dinilai adalah penguasaan perusahaan terhadap prosesnya sendiri.</p>

<p>Perbedaan CMMI dan ISO terletak pada ketelitiannya. Bila kita ingin perusahaan kita mendapat sertifikasi ISO, perusahaan kita harus memiliki Standard Operating Procedure (SOP) yang tertulis. Kemudian kita harus membuktikan pada badan sertifikasi bahwa SOP tersebut kita jalankan dengan baik. Apa saja yang kita tulis dalam SOP bebas terserah kita. ISO tidak mengatur sampai ke tingkat itu.</p>

<p>Berbeda dengan CMMI, selain kita punya SOP, dia punya aturan khusus tentang isi SOP. Misalnya, kalau kita melakukan analisa kebutuhan (requirement gathering), ada beberapa aturan yang harus diikuti, misalnya:</p>

<ul>
<li><p>Pernyataan kebutuhan user harus dicatat</p></li>
<li><p>Pernyataan kebutuhan harus dikonfirmasi ke user</p></li>
<li><p>Pernyataan kebutuhan harus disetujui kedua pihak</p></li>
<li><p>Kalau ada perubahan, harus dicatat</p></li>
<li><p>Antara kebutuhan dan software yang dideliver, harus bisa dilacak bolak-balik</p></li>
</ul>


<p>Singkatnya, kalau kita lulus ISO, belum tentu lulus CMMI. Sebaliknya, kalau kita lulus CMMI, besar kemungkinan kita akan langsung lulus ISO bila ikut sertifikasinya.</p>

<h3>Apa yang dimaksud Maturity Level ??</h3>

<p>Tujuan awal dirumuskannya CMMI sebenarnya adalah untuk mendukung proses tender di lingkungan Departemen Pertahanan Amerika Serikat (US-DoD). Mereka ingin memiliki sistem penilaian terhadap semua vendor yang mengajukan proposal. Untuk itu dirumuskanlah sistem penilaian vendor berupa Maturity Level (ML).</p>

<p>Maturity Level di CMMI ada 5, mulai dari yang terendah ML 1, sampai yang paling canggih ML 5. Bila perusahaan kita sudah ML-5, maka kita bisa ikut dalam tender proyek software rudal Patriot. Begitu kira-kira.</p>

<p>Setiap ML memiliki seperangkat PA yang harus dipenuhi agar kita berhak menggunakan titel ML tersebut. Sebagai contoh, bila kita ingin lulus ML-2, maka kita harus mengimplementasikan 7 PA. Untuk mencapai ML-3, kita harus mengimplementasikan 7 PA dari ML-2 ditambah dengan 11 PA dari ML-3. Demikian seterusnya, sehingga ML-5 yang sudah mengimplementasikan 22 PA.</p>

<p>Bila kita sama sekali belum mengimplementasikan apa-apa, perusahaan kita dikategorikan sebagai ML-1. Level ini diadakan sebagai hiburan bagi perusahaan yang sudah ikut SCAMPI Class A, tapi tidak lulus bahkan di ML-2. Well, ML-1 kedengarannya lebih baik daripada No-ML atau ML-0 :p</p>

<p>Daftar lengkap PA per ML bisa dilihat di <a href="http://www.sei.cmu.edu/publications/documents/06.reports/06tr008.html">spesifikasi CMMI</a>.</p>

<h3>Perusahaan saya ingin mendapat ML-5, bagaimana caranya?</h3>

<p>Pertama, tentunya perusahaan kita harus memenuhi semua persyaratan mulai dari ML-2 sampai ML-5. Perusahaan kita harus sudah punya SOP yang mengatur semua proses sesuai aturan CMMI. Bila ada aturan yang tidak kita pahami, kita bisa datangkan konsultan untuk menjelaskan.</p>

<p>Setelah ada SOP tersebut, setiap orang dalam perusahaan harus memahami dan menjalankannya dengan benar. Setelah kita yakin bahwa perusahaan kita mampu, kita mendatangkan appraiser atau auditor untuk memeriksa proses kita.</p>

<p>Kegiatan appraisal ini disebut dengan SCAMPI. Ada macam-macam SCAMPI, tapi yang berhak mengeluarkan peringkat ML hanyalah SCAMPI Class A.</p>

<p>Dalam SCAMPI, Lead Appraiser(LA) akan merekrut beberapa orang dari perusahaan kita untuk membantunya mengaudit. Tim auditor ini disebut Appraisal Team Member (ATM). Perusahaan kita juga juga harus menyediakan tim yang akan diwawancarai oleh ATM, yang disebut dengan Functional Area Representative (FAR).</p>

<p>FAR merupakan perwakilan dari berbagai departemen dalam organisasi. Mungkin nantinya akan ada kelompok FAR dari procurement, tim project, network administrator, programmer, tester, dan lainnya.</p>

<p>ATM dibutuhkan untuk menterjemahkan aturan CMMI ke dalam SOP perusahaan. Misalnya, dalam CMMI ada aturan mengenai analisa kebutuhan, yaitu process area Requirement Management (REQM) dan Requirement Development (RD). Process area ini di perusahaan A mungkin diimplementasikan dengan dokumen Software Requirement Specification (SRS), tapi di perusahaan B mungkin namanya User Requirement Specification (URS), dan di perusahaan C berupa Use Case Diagram dan User Stories. Nah, tugas ATM adalah menjembatani antara istilah CMMI dan istilah internal perusahaan.</p>

<p>Wawancara ATM tidak aneh-aneh. Untuk setiap proses area, mereka akan tanya apakah FAR sudah mengimplementasikan. Bila sudah, mana buktinya. Bukti ini bisa berupa hard-copy, bisa juga soft-copy. Kita bisa mengajukan email sebagai evidence. Bahkan kita juga bisa menunjukkan log Subversion atau item bug dalam aplikasi bug tracker.</p>

<p>Dalam sintaks Java 5, proses appraisal dalam SCAMPI Class A bisa digambarkan sebagai berikut.</p>

<pre><code>int level = 1;

appraisal:
for(int i=1; i&lt;=5; i++) {
    List allProcessAreas = maturityLevel[i].getProcessAreas();
    for(ProcessArea pa : allProcessAreas) {
        for(GenericPractice gp : allGenericPractices) {
            if(!far.isImplement(pa, gp) { break appraisal; }
        }

        for(SpecificPractice sp : pa.getSpecificPractices()) {
            if(!far.isImplement(sp)) { break appraisal; }
        }

        level++;
    }
}
</code></pre>

<p>Berdasarkan hasil wawancara FAR oleh ATM, LA akan memutuskan ML berapa yang pantas untuk perusahaan kita.</p>

<p>Semua hasil SCAMPI Class A akan dilaporkan pada SEI dan akan <a href="http://sas.sei.cmu.edu/pars/pars.aspx">dipublikasikan di internet</a>. Sebagai contoh, kita bisa melihat <a href="http://sas.sei.cmu.edu/pars/pars_detail.aspx?a=7546">hasil appraisal BaliCamp pada tahun 2006</a>.</p>

<p>Sayangnya, sampai sekarang belum ada appraiser lokal. Jadi kita harus mendatangkan appraiser dari luar negeri.</p>

<p>Informasi lebih rinci mengenai SCAMPI dapat dilihat <a href="http://www.sei.cmu.edu/publications/documents/06.reports/06hb002.html">di spesifikasi resminya</a>. Di sana ada penjelasan rinci tentang apa saja syarat menjadi ATM, bagaimana proses interview dilakukan, dan bagaimana cara memutuskan apakah suatu evidence sudah memenuhi syarat atau belum.</p>

<h3>Apa yang dimaksud Continuous Representation?</h3>

<p>Perusahaan mengadopsi CMMI untuk berbagai tujuan. Ada yang bermotif marketing, yaitu meraih ML tertentu dengan harapan akan mendapat project dari US-DoD, ataupun simply memperkeren Company Profile. Sama saja dengan kita ambil SCJP.</p>

<p>Ada juga yang memang berniat meningkatkan kualitas prosesnya. Mengadopsi CMMI dengan harapan perusahaan akan menjadi lebih baik.</p>

<p>Kita kesampingkan dulu motif marketing. Mari kita lihat motif peningkatan kualitas. Ada beberapa pendekatan untuk mengadopsi CMMI. Kita bisa mengadopsi per ML, misalnya tahun ini ML-3, berikutnya ML-4, dan seterusnya. Atau bisa juga kita hanya memfokuskan perbaikan pada satu process area tertentu saja, misalnya Requirement Management, atau Risk Management.</p>

<p>Bila kita berorientasi ML, maka kita mengambil pendekatan Staged Representation. Sedangkan bila kita berorientasi PA, maka kita mengambil pendekatan Continuous Representation.</p>

<h3>Bila perusahaan saya sudah ML-5, apakah perusahaan akan menjadi monoton dan membosankan? Apakah karyawannya akan menjadi seperti robot belaka??</h3>

<p>Bagi programmer seperti saya dan Anda, kreativitas dan improvisasi adalah kenikmatan kerja yang utama. Itulah yang membuat kita memilih profesi software developer. Oleh karena itu, wajar bila kita mengkhawatirkan masalah ini.</p>

<p>Well, saya sudah pernah mengantarkan BaliCamp meraih ML-3, dan ikut terlibat dalam persiapan mencapai ML-5. Jadi, yang akan saya ceritakan ini adalah pengalaman nyata, bukan FUD (Fear, Uncertainty, Doubt).</p>

<p>Sebagai programmer yang terlibat dalam project, hal yang paling menyebalkan bagi kita bukanlah kesulitan teknis atau kerumitan algoritma. Semakin sulit, semakin menantang bagi kita. Hal yang paling menyebalkan adalah perubahan requirement di tengah jalan. Fitur yang kita implementasi dengan susah payah, bertampilan Web 2.0, menggunakan teknologi AJAX, tiba-tiba divonis client, &#8220;Ini bukan yang saya mau, GANTI !!!&#8221;.</p>

<p>Atau mungkin tidak se-ekstrim itu. End-user hanya minta geser tombol sedikit, tambah fitur sedikit, dan sedikit-sedikit lainnya, yang lama-lama tentunya akan menjadi bukit. Tiba-tiba, project sudah telat 2 bulan, dan fitur baru 50% terimplementasi. Bukan karena kita codingnya lama, tapi karena user minta perubahan melulu.</p>

<p>Nah, urusan perubahan requirement ini wajib hukumnya untuk dikelola dengan baik. Diatur dalam process area Requirement Management (REQM) yang ada di ML-2 dalam SP 1.3. Kalau perusahaan kita mengimplementasi REQM dengan baik, kita sebagai programmer akan lebih tenang hidupnya. Semua perubahan terhadap aplikasi yang sedang dibuat harus melalui rangkaian prosedur untuk memastikan perubahan tersebut benar-benar diinginkan dan sudah dipertimbangkan konsekuensinya. End-user tidak akan semena-mena meminta perubahan, tapi harus melalui persetujuan atasannya dan atasan kita. Dengan demikian, perubahan yang sampai pada programmer sudah pasti adalah perubahan yang penting, bukan hanya menurut end-user, tapi juga menurut sponsor project. Bahkan, adanya prosedur ini saja sudah cukup untuk membatasi <em>liarnya imajinasi</em> end-user.</p>

<p>Ini hanya satu contoh saja bagaimana implementasi CMMI memudahkan hidup kita sebagai programmer. Silahkan baca-baca spesifikasinya untuk mengetahui aturan-aturan lainnya. Secara umum, CMMI sama sekali tidak menyinggung tentang teknologi, IDE, tools, bahasa pemrograman yang digunakan. Bahkan kegiatan coding sendiri cuma dibahas dalam 2 PA dari 22 yang ada, yaitu Technical Solution dan Product Integration.</p>

<p>Technical Solution mengharuskan kita untuk mengidentifikasi alternatif pendekatan yang tersedia. Kemudian dari alternatif tersebut, kita pilih yang paling baik, berdasarkan kriteria yang kita tentukan sendiri. Jadi tidak boleh langsung coding, melainkan harus mikir dulu.</p>

<p>ML-4 dan ML-5 banyak menitikberatkan pada analisa kuantitatif dan continuous improvement. Sukakah anda terlibat dalam project yang selesai tepat waktu, tidak lembur, libur pada hari Sabtu-Minggu? Nah, kalau sudah ML-5, project seperti ini bukan lagi impian, tapi sudah menjadi hal yang biasa. Delay dalam project sudah bisa diketahui sejak dini. Dari mulai telat 1 hari, project manager sudah bisa tahu dan mengambil tindakan antisipasi seperti minta pengunduran jadwal, mengurangi requirement, dan sebagainya.</p>

<p>Sebagai programmer, tidak banyak perubahan yang kita rasakan selain project menjadi lebih tenang dan teratur. Yang paling besar terkena dampak implementasi CMMI adalah Project Manager. Tiba-tiba saja dia akan diharuskan membuat banyak dokumen dan menyediakan data. Pekerjaan administratifnya akan menjadi jauh lebih banyak.</p>

<p>Tentunya hal ini bisa diatasi dengan otomasi proses. Begitu prosesnya sudah rapi, kegiatan administrasi bisa di-online-kan. Masalah versioning dokumen bisa diatasi dengan Subversion. Daftar resiko project, task management, bug report, bisa diotomasi dengan Bug/Issue Tracker. Lagipula, bila perusahaan kita bergerak di bidang IT, tentunya persenjataan seperti itu sudah seharusnya menjadi lifestyle kita.</p>

<p>Demikianlah penjelasan singkat tentang CMMI. Lain waktu kita akan bahas satu persatu Process Area yang ada.</p>

<p>Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/lain/long-time-no-see/">Long Time No See</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-06-11T22:44:45+07:00" pubdate data-updated="true">Jun 11<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mohon maaf bagi pembaca setia blog saya, karena sudah lama tidak ada artikel baru. Pada Februari 2008 yang lalu, saya mengambil keputusan yang mengubah arah hidup saya, mudah-mudahan ke arah yang lebih baik.</p>

<p>Saya mengundurkan diri dari posisi empuk dan pekerjaan menantang di <a href="http://www.balicamp.com">Sigma Karya Sempurna (BaliCamp)</a> dan memutuskan untuk menggarap <a href="http://www.artivisi.com">ArtiVisi</a> secara lebih serius bersama <a href="http://ifnu.artivisi.com">Ifnu</a>.</p>

<p>Sebagai perusahaan start-up, banyak hal yang harus dilakukan pada masa awal berdirinya perusahaan. Hal-hal teknis seperti setup repository server dan hal non teknis seperti rumus penggajian pegawai, aturan cuti, dan sebagainya harus dipikirkan dan dibuatkan prosedurnya. Belum lagi pengembangan produk pelatihan dan standarisasi kualitas bahan ajar. Dan yang paling penting, cari proyek supaya dapur tetap ngebul. Sehingga akibatnya aktivitas blogging menjadi kalah prioritas.</p>

<p>Setelah empat bulan berlalu, banyak pengalaman yang didapat, dan juga banyak project yang sudah closing. Urusan non teknis yang penting juga sudah banyak yang bisa didelegasikan. Karena itu, mudah-mudahan saya bisa mengisi blog lagi.</p>

<p>Beberapa pengalaman yang rencananya akan saya tuliskan antara lain:</p>

<ul>
<li><p>Acegi Security 2.0</p></li>
<li><p>Tutorial OSGi</p></li>
<li><p>SpringSource Application Platform</p></li>
<li><p>Tutorial <a href="http://www.jpos.org">jPOS</a> (library untuk memproses ISO-8583)</p></li>
<li><p>dan tulisan non-java seperti &#8221;<a href="http://endy.artivisi.com/blog/life/wirausaha">Langkah persiapan berhenti jadi karyawan&#8221;</a></p></li>
</ul>


<p>Stay tuned &#8230; :D</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/road-to-java-ee/">Road to Java EE</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-03-27T18:41:19+07:00" pubdate data-updated="true">Mar 27<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Another Frequently Asked Question.</p>

<blockquote><p>Saya sudah menguasai Java Standard Edition dan sekarang mau belajar Java Enterprise Edition. Bagaimana learning-path-nya?</p></blockquote>

<p>Inilah Road to Java Enterprise versi saya:</p>

<h3>Tahap Pertama</h3>

<ol>
<li>Belajar HTTP.</li>
<li>bedanya GET dan POST</li>
<li>apa itu session</li>
<li>bagaimana cara implement state management</li>
<li><p>konsep multipart dan mekanisme upload file</p></li>
<li><p>Belajar Servlet Fundamental.</p></li>
<li>Servlet</li>
<li>Filter</li>
<li>Listener</li>
<li><p>Tidak perlu repot2 belajar JSP</p></li>
<li><p>Belajar JDBC.
Pastikan Anda tau:</p></li>
<li>Cara connect ke database</li>
<li>Cara eksekusi DML</li>
<li><p>Cara menjalankan SQL select</p></li>
<li><p>Belajar Database Transaction Fundamental.
Pastikan Anda tau:</p></li>
<li>Syarat-syarat untuk mengaktifkan transaction</li>
<li>Local vs Managed Transaction</li>
<li>Programmatic vs Declarative Transaction</li>
<li>Transaction Isolation Level</li>
<li>Transaction Propagation</li>
</ol>


<p>Untuk tahap pertama, itu dulu saja.</p>

<p>Kalau sudah ngerti itu, bisa dengan mudah memahami:</p>

<ul>
<li>Web framework apapun (Spring MVC, Struts 1 dan 2, Java Server Faces)</li>
<li>Database abstraction framework seperti Spring JDBC, iBatis, dan Hibernate.</li>
</ul>


<h3>Tahap Kedua</h3>

<p>Tahap kedua ini relatif rumit. Karena itu, untuk tiap materi, pastikan:
- Anda tau masalah yang mendasari munculnya teknologi ini.
- Anda tau cara memecahkan masalah tersebut dengan teknologi ybs.
- Anda tau keterbatasan dari teknologi ybs.
- Anda tau alternatif solusi selain menggunakan teknologi ybs</p>

<ol>
<li>Remote Method Invocation</li>
<li>Mekanisme remote invocation</li>
<li>Mekanisme rmiregistry</li>
<li>Cara membuat remote object</li>
<li>Cara mempublish remote object</li>
<li><p>Cara membuat client yang mengakses remote object</p></li>
<li><p>Java Messaging Service (JMS)</p></li>
<li>Arsitektur Messaging</li>
<li>Point to Point vs Publisher - Subscriber</li>
<li>Bedanya Durable dan Non-Durable Subscriber</li>
<li>Cara mengirim message</li>
<li><p>Cara menerima message</p></li>
<li><p>Enterprise Java Bean</p></li>
<li>Stateless Session Beans</li>
<li>Stateful Session Beans</li>
<li>Message Driven Beans</li>
<li>Entity Beans dan evolusinya dari versi 2 sampai versi 3.</li>
</ol>


<p>Kalau sudah menyelesaikan tahap 2 ini, seharusnya Anda akan mudah memahami Seam Framework dan bisa menggunakan sebagian besar fitur dari application server Java (seperti Glassfish, Geronimo, JBoss AS, IBM Websphere, Oracle iAS, BEA Weblogic, dsb).</p>

<p>Selain itu, masih ada tahap ketiga, yaitu urusan lain-lain seperti JMX, dan teman-temannya. Tapi saya yakin kalau sudah lulus tahap dua, sudah tidak bingung lagi mau belajar apa.</p>

<p>Daftar di atas memang cukup menggetarkan hati. Sebagai gambaran, saya sendiri butuh waktu satu tahun lebih untuk memahami itu semua.</p>

<p>Tapi jangan khawatir, kalau Anda mulai hari ini, berarti tahun depan sudah menguasai. Kalau menunda belajar, bukan saja akan lebih lama selesainya, tapi juga materinya akan lebih banyak. Framework integrasi ala OSGi dan fitur baru Java 7 seperti Closure sudah di ambang pintu.</p>

<p><strong>Mulailah dari sekarang !!!</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/kutu-loncat/">Kutu Loncat</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-03-17T23:53:14+07:00" pubdate data-updated="true">Mar 17<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di milis Java sedang ribut urusan gaji programmer. Topik ini adalah topik abadi. Sepanjang hidup saya di milis ini, paling tidak urusan gaji dibahas setahun dua kali. Kadang-kadang lebih sering.</p>

<p>Kita tidak akan membahas tentang urusan gaji &#8230; mungkin nanti di posting berikutnya. Kita akan membahas tentang fenomena pindah kerja terlalu sering, a.k.a kutu loncat. Menurut salah seorang komentator, programmer Java cenderung kutu loncat.</p>

<p>Sedikit informasi latar belakang, sejak lulus di tahun 2001 sampai 2008 ini, saya sudah kerja di 7 perusahaan berbeda. Kalau dirata-rata, berarti tiap tahun pindah kerja. Saat ini saya membangun perusahaan sendiri. Jadi saya akan bahas dari sudut pandang karyawan, dan juga pemilik perusahaan.</p>

<p><strong>Sudut Pandang Karyawan</strong></p>

<p>Sebagai karyawan, pindah kerja itu hal yang biasa. Yang penting jangan terlalu sering, dan menggunakan sopan-santun yang benar.</p>

<p>Kalau kita terlalu sering pindah kerja, misalnya setahun 3 kali (berarti rata-rata 4 bulan), kita akan mengalami beberapa kesulitan.</p>

<p>Kesulitan pertama adalah dilema dalam mengupdate CV. Apakah 3 perusahaan tersebut akan kita tulis atau tidak? Kalau ditulis, HRD akan bertanya-tanya, ada apa dengan kandidat ini? Kok dalam satu tahun sudah pindah 3 kali. Terlalu menuntut, rewel, atau apa?  Kalau tidak ditulis, HRD akan bertanya kenapa kandidat ini pengangguran beberapa bulan?</p>

<p>Kesulitan kedua, waktunya akan habis untuk masa transisi. Untuk bisa efektif, seorang karyawan butuh 1-2 bulan penyesuaian. Kalau kita resign, butuh waktu 2-4 minggu untuk transfer knowledge ke penerus kita. Kerugian di kita juga, kita tidak bisa mengakumulasi pengalaman.</p>

<p>Bagaimana sopan santunnya? Mudah saja:</p>

<ol>
<li><p>Beritahukan sedini mungkin. Idealnya 1 bulan, kalau tidak bisa ya minimal 2 minggu sebelumnya</p></li>
<li><p>Selesaikan semua tanggung jawab dan hutang (kalau ada)</p></li>
<li><p>Lakukan proses handover dengan benar</p></li>
</ol>


<p>Kapan kita pindah kerja?</p>

<p>Menurut saya, bila:</p>

<ul>
<li><p>Pekerjaan kita sudah tidak lagi membuat kita tambah pintar</p></li>
<li><p>Kompensasi yang kita terima tidak sebanding dengan kontribusi yang kita berikan</p></li>
<li><p>Ada tawaran yang minimal 50% lebih besar (annually, bukan monthly). Kalau lebih sedikit dari itu, tidak sebanding dengan kerepotan pindah kerja.</p></li>
</ul>


<p><strong>Sudut Pandang Perusahaan</strong></p>

<p>Kalau karyawannya bagus, perusahaan akan rugi kalau dia resign, karena:</p>

<ul>
<li><p>butuh waktu untuk rekrutasi</p></li>
<li><p>butuh waktu untuk training</p></li>
<li><p>butuh waktu untuk handover/transisi</p></li>
</ul>


<p>Oleh karena itu, perusahaan harus berusaha mempertahankan karyawannya yang bagus. Apalagi untuk software development company. Komputer rusak gampang diganti, tapi top developer resign, urusannya jauh lebih kompleks. Keseluruhan daya saing perusahaan terletak pada otak karyawannya.</p>

<p>Untuk sudut pandang perusahaan, saya akan lebih fokus tentang bagaimana sudut pandang yang benar dalam memandang karyawannya.</p>

<p>Selalu berikan training. Training ini adalah untuk memastikan karyawan tersebut melakukan tugasnya dengan benar. Saya pernah dengar kutipan berikut, &#8220;Train your employee and risk they leave, or not train your employee and risk they stay&#8221;. Arti kutipan di atas, resiko kita bila memberikan training adalah bila karyawan resign, kita rugi biaya training. Sebaliknya, bila kita tidak memberikan training, kita menanggung resiko bila karyawan tersebut tidak perform dan tak kunjung resign.</p>

<p>Kesalahan besar yang lainnya, berkaitan dengan training, menganggap karyawan yang otodidak tidak butuh training. Ini pandangan yang sempit, menganggap bahwa training hanyalah sarana menambah knowledge belaka.</p>

<p>Training, apalagi external training, memiliki benefit lain disamping menambah pengetahuan:</p>

<ol>
<li><p>Memperluas wawasan</p></li>
<li><p>Memperluas pergaulan</p></li>
<li><p>Menimbulkan sense-of-significance dalam karyawan. Perasaan bahwa dia tidak semata diperah, tapi juga dibesarkan. Perasaan bahwa perusahaan peduli dengan peningkatan kemampuannya. Urusan bahwa materi tersebut bisa dipelajarinya sendiri tidaklah penting.</p></li>
</ol>


<p>Evaluasi kompensasi vs kontribusi secara periodik. Karyawan yang baik kemampuannya akan cepat meningkat. Hari ini baru bisa Java Fundamental, enam bulan kemudian sudah mengerti Spring Framework. Peningkatan kemampuan jelas mengimplikasikan peningkatan market-value si karyawan.</p>

<p>Perusahaan harus memastikan bahwa dialah yang pertama mengetahui peningkatan kemampuan tersebut, dan kemudian mengapresiasinya. Di kantor tempat saya bekerja sebelumnya, banyak orang-orang hebat, yang kehebatannya baru disadari perusahaan setelah orang tersebut resign. Sungguh suatu kesia-siaan yang besar. Saya tidak tahu apakah perusahaan tidak bisa mengenali orang hebat, tidak mau mengapresiasi orang hebat, atau tidak mampu mengapresiasi dengan layak. Yang saya tahu hanya satu, orang hebat satu persatu meninggalkan perusahaan.</p>

<p>Jadi, perusahaan harus selalu mengamati perkembangan karyawannya. Sadari bahwa ulat sudah menjadi kupu-kupu. Kemudian berikan kompensasi yang sesuai.</p>

<p>Kompensasi tidak selalu berimplikasi naik gaji. Banyak kompensasi non-gaji yang bisa digunakan, diantaranya:</p>

<ul>
<li><p>menambah jatah cuti</p></li>
<li><p>mengirim karyawan ikut event</p></li>
<li><p>mengikutkan karyawan pelatihan</p></li>
<li><p>mendorong karyawan ikut dalam kegiatan komunitas</p></li>
<li><p>mengupgrade komputernya</p></li>
<li><p>dan masih banyak teknik lainnya, asal Anda kreatif saja.</p></li>
</ul>


<p>Kesalahan berikutnya, perusahaan, terutama startup, sering menganggap karyawan ber-etos kerja seperti founder. Karena foundernya kerja 10 jam sehari tanpa lembur, maka dianggap karyawannya juga akan rela melakukan hal serupa. Kalau foundernya Sabtu Minggu ngantor dengan gembira, dianggapnya karyawan juga harus ngantor di masa weekend sambil tersenyum. Bila client telat bayar, karyawan diharapkan akan mengerti.</p>

<p>Ini pemahaman yang salah. Karyawan tidak memiliki keterkaitan emosi terhadap perusahaan sekuat foundernya. Mereka punya kehidupan sendiri dan cita-cita sendiri. Perusahaan harus adil, kalau kerja lembur, berikanlah apresiasi yang sesuai. Berikan uang lembur, atau tambahkan jatah cutinya.</p>

<p>Sebagai penutup, saya menganggap perusahaan IT sama seperti klub sepakbola profesional, seperti Inter Milan atau Arsenal. Posisinya di klasemen, kekayaannya, jumlah fansnya, semua terutama ditentukan oleh siapa pelatihnya, dan siapa pemainnya. Tidak memperhatikan karyawan adalah langkah pertama menuju kegagalan.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/life/kandidat-java-vs-php/">Kandidat Java vs PHP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-02-07T00:04:44+07:00" pubdate data-updated="true">Feb 7<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Disclaimer : kondisi dan pengalaman Anda SANGAT MUNGKIN BERBEDA.
Jadi jangan bilang saya salah &#8230; ini pengalaman pribadi.
Pengalaman Anda boleh saja berbeda, dan sangat dianjurkan untuk sharing.</p>

<blockquote><p>Belakangan ini banyak yang nyari Programmer PHP yah :-d</p></blockquote>

<p>Demikian tanggapan moderator milis JUG-Indonesia.</p>

<p>Saya mau sharing pengalaman sedikit tentang rekrutasi ArtiVisi beberapa hari yang lalu.
Rate salary di lowongan kemarin itu 2-3 juta rupiah, looking for PHP Programmer.</p>

<p>Ternyata, dengan rate salary segitu, para kandidat sudah mampu &#8216;melaju ke babak playoff&#8217;.
Begini maksudnya.</p>

<p>Kalau interview, saya selalu mengajukan pertanyaan yang makin lama makin sulit.
Job seeker, perhatikan ini, Endy&#8217;s interview style.</p>

<ul>
<li><p>Urusan coding standar. Percabangan dan perulangan.Misalnya:</p>

<ul>
<li>tampilkan nama anda sebanyak jumlah hurufnya. Kalau namanya Endy, tampilkan endy endy endy endy. Kalau namanya Dhiku, tampilkan dhiku dhiku dhiku dhiku dhiku.</li>
<li>dengan input bulan dan tahun, buat function/method untuk menghitung jumlah harinya</li>
</ul>
</li>
<li><p>Topik-topik populer</p>

<ul>
<li>HTML syntax</li>
<li>Tableless layout with CSS</li>
<li>SQL Injection</li>
</ul>
</li>
<li><p>Setelah itu masalah yang membutuhkan imajinasi, misalnya perbedaan pass by value dan pass by reference</p></li>
<li><p>Kalau masih lolos juga, matakuliah CS yang biasanya bikin ngantuk</p>

<ul>
<li>Struktur Data</li>
<li>Algoritma tingkat menengah (tree, sorting, dsb)</li>
<li>Automata / Finite State Machine   5. Baru kemudian pertanyaan tentang wawasan</li>
<li>Primary Operating System, dan Secondary OS, yang biasa digunakan</li>
</ul>
</li>
</ul>


<p>Cuma pernah pakai Windows??? Hmm &#8230; terima kasih atas waktunya, nanti akan saya hubungi lagi.
Tidak pernah pakai OS selain FreeBSD?? Hmm &#8230; menarik juga &#8230; mari kita tanya lebih lanjut,</p>

<blockquote><p>Kamu sekolah TK di mana?</p></blockquote>

<p>Saya pernah posting tentang kandidat ideal menurut saya <a href="http://software.endy.muhardin.com/life/pengetahuan-wajib-buat-programmer/">di sini</a>.</p>

<p>Lalu banyak yang berkomentar tentang betapa sulitnya persyaratan tersebut.</p>

<p>Nah &#8230;kembali ke pertanyaan Joshua &#8230; kenapa sekarang banyak cari PHP Programmer?</p>

<p>Well &#8230; berdasarkan pengalaman saya, dengan tawaran 2-3 juta,
para kandidat programmer PHP ini umumnya mampu sampai pertanyaan 3.
Beberapa ada yang bisa jawab sampai nomer 4.
Belum ada yang sampai 5.</p>

<p>Bagaimana dengan koleganya, kandidat programmer Java?
Menyedihkan &#8230;.
Bahkan no 2 pun banyak yang gak bisa jawab.
Fresh graduate Java programmer, berdasarkan survei yang tidak serius dan tidak bisa dipertanggungjawabkan metodologinya, apalagi hasilnya, menyatakan bahwa mereka mengharapkan gaji setidaknya 3-4 juta.</p>

<p>Jadi &#8230; kalau saya punya budget 3-4 juta, lalu buka lowongan, bandingkan apa yang akan saya peroleh.</p>

<p><strong> PHP Programmer </strong></p>

<ul>
<li>Berpengalaman 2-3 tahun, sudah tahu sopan santun kerja di kantor</li>
<li>Bisa HTML</li>
<li>Bisa CSS, lengkap dengan div, span, bisa bikin table-less layout</li>
<li>Bisa AJAX, low level lagi pakai prototype.js atau whatever library JavaScript yang sedang trend</li>
<li>Ngerti konsep HTTP request-response, session, cookie, upload file, dan urusan remeh-temeh HTTP lainnya</li>
<li>Kalau beruntung, mungkin bisa dapat yang ngerti SOAP segala</li>
<li>Hey, 4 juta cukup mahal &#8230; coba kita lihat mungkin dia ngerti Photoshop juga :D</li>
</ul>


<p><strong> Java Programmer </strong></p>

<ul>
<li>Fresh graduate, masih bergaya mahasiswa</li>
<li>Ngerti HTML seadanya, belum tentu ngerti perilakunya frameset</li>
<li>Gak bisa CSS, apalagi table-less layout</li>
<li>Forget about AJAX</li>
<li>Forget about low-level HTTP, servlet mapping di web.xml aja belum tentu ngerti</li>
<li>SOAP?? Buat mandi??</li>
<li>Photoshop atau Corel Draw .. hmm .. itu kan kerjaannya Web Designer. Saya gak ikut-ikut.</li>
</ul>


<p>Nah &#8230;. lalu apa pesan moral dari artikel ini?</p>

<ol>
<li>Freshmen Java harus lebih tahu diri. Kerjakan PR dulu baru apply. Dengan kondisi seperti di atas, saya lebih suka mempekerjakan PHP programmer lalu diajari Java</li>
<li>Industri PHP harus lebih mengapresiasi komunitasnya</li>
<li>Sebagai company-owner, harus tahu kondisi di berbagai dunia</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/stack-2008-1/">Java Stack 2008</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-24T16:59:36+07:00" pubdate data-updated="true">Jan 24<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di milis Java sedang dibahas tentang kombinasi teknologi yang digunakan untuk membuat aplikasi Java.</p>

<p>Ada beberapa kategori teknologi, yaitu:</p>

<ul>
<li><p>Presentation Layer. Yaitu teknologi untuk membangun User Interface</p></li>
<li><p>Business Layer. Yaitu teknologi untuk menyediakan logika proses bisnis.</p></li>
<li><p>Data Access Layer. Yaitu teknologi untuk mengakses penyimpanan data, misalnya database.</p></li>
<li><p>Security Framework. Teknologi untuk mengelola otentikasi dan otorisasi.</p></li>
<li><p>Build System. Sistem untuk mengotomasi proses build.</p></li>
<li><p>Testing System. Sistem untuk mengotomasi pengetesan aplikasi.</p></li>
<li><p>Application Server</p></li>
<li><p>Database Server</p></li>
<li><p>Project Management Tools. Perangkat pembantu untuk mengelola project.</p></li>
</ul>


<p>Berikut adalah stack yang saya gunakan, per Januari 2008. Sesuai perkembangan jaman, mungkin sekali stack ini akan berubah.</p>

<h3>Presentation Layer</h3>

<p>Tergantung tujuan developmentnya. Kalau butuh rapid, saya pakai JSF 1.2 dengan komponen RichFaces. Kalau ingin sederhana dan fleksibel, saya pakai Spring MVC.</p>

<p>Sebagai tambahan, sekarang saya sedang mengeksplorasi  Spring Web Flow untuk mengelola state aplikasi. Framework ini bisa digunakan baik untuk JSF maupun Spring MVC.</p>

<p>Baik dalam Spring MVC maupun JSF, kita dapat memilih View Engine yang digunakan. Kebanyakan orang tidak tahu, atau tidak mau repot, atau mungkin juga merasa nyaman menggunakan JSP. Tapi saya tidak. Saya lebih suka pakai Velocity atau Freemarker untuk Spring MVC, dan pakai Facelets di JSF.</p>

<h3>Business Layer</h3>

<p>Saya menggunakan Spring Framework untuk mengorkestrasi transaction, integrasi dengan berbagai data access layer, messaging system, dan sebagainya.</p>

<h3>Data Access Layer</h3>

<p>Bila ingin rapid development, saya pakai Hibernate. Bila ingin main low level SQL, saya pakai Spring JDBC.</p>

<p>Saya tidak pakai JPA. Dulu pernah pakai iBatis, tapi belakangan sepertinya sudah cukup dengan Spring JDBC saja.</p>

<h3>Security Framework</h3>

<p>Pakai Spring Security. Fiturnya cukup lengkap dan desainnya sudah teruji di skenario dunia nyata.</p>

<h3>Build System</h3>

<p>Orang-orang pada pakai Maven. Saya sudah merasa cukup pakai Ant saja.</p>

<h3>Testing System</h3>

<p>Saat ini pakai JUnit 4 dan DBUnit. Tapi sedang eksplorasi TestNG. Saya tertarik dengan kemampuan test-grouping. Ini penting apabila kita ingin memisahkan test yang harus dieksekusi programmer sebelum dia commit (sehingga harus cepat), dan test yang dieksekusi oleh tools Continuous Integration saja (karena butuh waktu lama).</p>

<p>Test sebelum commit contohnya adalah unit test dan integration test. Selain itu, ada test yang butuh waktu lama, misalnya test End of Day/Month/Year process, dan test simulasi kinerja aplikasi dengan data satu tahun kedepan.</p>

<p>Untuk coverage test, saya gunakan Cobertura. Sedangkan untuk Static Code Analysis saya gunakan PMD.</p>

<p>Ke depan, saya sedang menganalisa efektifitas penggunakan JDepend untuk memastikan dependensi antar modul yang sudah ditentukan di awal tidak dilanggar programmer lain. Misalnya, tidak ada urusannya presentation layer melakukan import HibernateException. Nah, ini sepertinya bisa dienforce oleh JDepend, tapi belum sempat saya coba.</p>

<h3>Application Server</h3>

<p>Saya gunakan Winstone untuk tutorial dan pelatihan. Untuk development saya gunakan Tomcat. Untuk production saya gunakan Glassfish.</p>

<h3>Database Server</h3>

<p>Untuk development dan production, saya menggunakan PostgreSQL. Untuk pelatihan dan tutorial, saya gunakan MySQL.</p>

<h3>Project Management Tools</h3>

<p>Untuk melakukan tracking terhadap:</p>

<ul>
<li><p>implementasi fitur</p></li>
<li><p>resiko dalam project</p></li>
<li><p>masalah dalam project</p></li>
<li><p>penyelesaian bug</p></li>
<li><p>perbaikan dokumen berdasarkan review/audit</p></li>
</ul>


<p>saya menggunakan Redmine.</p>

<p>Untuk membantu proses Configuration Management, saya menggunakan Subversion. Kadang-kadang dibantu dengan SVK bila ingin kerja offline.</p>

<p>Sebelum saya tutup artikel ini, pasti nanti ada yang ingin berkomentar seperti ini,</p>

<blockquote><p>Wuah, banyak sekali persenjataannya. Kok repot-repot sekali sih?</p></blockquote>

<p>Di sebelah rumah saya, tetangga sedang membangun rumah. Para pekerjanya (2-3 orang) cukup bermodalkan cangkul untuk mengaduk semen. Bila mereka ingin mengecor lantai dua, cukup membuat bekisting dari triplek dan papan bekas, yang setelah pakai bisa langsung dibuang. Sekali-sekali, saya melihat mereka menggotong perkakas dan bahan baku bila lokasi kerjanya pindah.</p>

<p>Di depan jendela saya di kantor, sedang dibangun gedung perkantoran yang baru. Untuk mengaduk semen, tidak pakai cangkul, melainkan dituang dari truk molen. Tim pekerjanya (200-300 orang) punya cetakan/bekisting khusus yang reusable untuk mengecor tiang dan lantai. Bila ada perkakas atau bahan baku yang perlu dipindahkan, mereka tidak gotong sendiri. Untuk keperluan itu, ada alat sendiri yang namanya <a href="http://science.howstuffworks.com/tower-crane.htm">tower crane</a>. Bahkan ada pilotnya khusus.</p>

<p>Nah, itu analoginya. Silahkan simpulkan sendiri, kenapa harus repot-repot.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/aplikasi-web-spring25-6/">Aplikasi Web Dengan Spring 2.5 [Bagian 6]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-19T17:24:03+07:00" pubdate data-updated="true">Jan 19<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada artikel kali ini, kita akan mengurusi masalah sepele tapi penting, yaitu Internationalization (i18n) dan Localization (l10n). i18n adalah menyiapkan aplikasi kita supaya bisa beradaptasi dengan berbagai bahasa, format penomoran, mata uang, dan hal-hal lain yang berkaitan dengan globalisasi.</p>

<p>Para pembaca mungkin ada yang bertanya,</p>

<blockquote><p>Ah, aplikasi saya tidak perlu multibahasa kok. Saya bikin dalam bahasa Inggris, dan tidak akan diubah-ubah lagi.</p></blockquote>

<p>Baiklah, mungkin aplikasi kita tidak akan berganti bahasa. Tapi mungkin sekali akan terjadi banyak revisi tampilan. Kita sebagai programmer mungkin mahir berbahasa PHP, Java, Ruby, atau bahasa-bahasa komputer lainnya. Tetapi belum tentu kita dapat menyaingi seorang JS Badudu dalam urusan Bahasa Indonesia.</p>

<p>Oleh karena itu, penting untuk menyiapkan aplikasi kita agar setidaknya tulisan yang dilihat user bisa diganti dengan mudah.</p>

<p>Mari kita lihat template sederhana berikut.</p>

<h3>personlist.html</h3>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;title&gt;:: List of All Person ::&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;List of All Person&lt;/h1&gt;

&lt;table border="0" cellpadding="2" cellspacing="2"&gt;
    &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;th&gt;Email&lt;/th&gt;
        &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    #foreach($person in $personList)
    &lt;tr&gt;
        &lt;td&gt;$person.Name&lt;/td&gt;
        &lt;td&gt;$person.Email&lt;/td&gt;
        &lt;td&gt;&lt;a href="personform?person_id=$person.Id"&gt;edit&lt;/a&gt; | &lt;a
         href="persondetail?person_id=$person.Id"&gt;view&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    #end
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Seperti kita lihat, ada beberapa tulisan yang muncul di situ, yaitu:</p>

<ul>
<li>Judul halaman</li>
<li>Nama kolom pada tabel : Nama, Email</li>
<li>link untuk edit dan lihat</li>
</ul>


<p>Spring sudah memiliki dukungan built-in untuk mengeluarkan tulisan tersebut ke file text. Nantinya kita bisa edit file tersebut dengan mudah. Kita juga bisa punya beberapa file dalam berbagai bahasa, sehingga aplikasi dapat mendeteksi setting regional komputer, dan kemudian menampilkan bahasa yang sesuai.</p>

<p>Tapi untuk artikel ini, cukuplah kita mengeluarkan tulisan itu ke file text. Fitur-fitur tambahan lainnya silahkan dieksplorasi sendiri oleh pembaca.</p>

<p>Kita menggunakan tag <code>#springMessage</code> untuk mengeluarkan tulisan tersebut. Tag ini khusus untuk Velocity. Bila Anda menggunakan JSP atau Freemarker, silahkan lihat referensi Spring.</p>

<p>Template yang sudah diubah terlihat menjadi seperti ini.</p>

<h3>personlist.html</h3>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;title&gt;:: #springMessage("personlist.title") ::&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;#springMessage("personlist.title")&lt;/h1&gt;

&lt;table border="0" cellpadding="2" cellspacing="2"&gt;
    &lt;tr&gt;
        &lt;th&gt;#springMessage("personlist.name")&lt;/th&gt;
        &lt;th&gt;#springMessage("personlist.email")&lt;/th&gt;
        &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    #foreach($person in $personList)
    &lt;tr&gt;
        &lt;td&gt;$person.Name&lt;/td&gt;
        &lt;td&gt;$person.Email&lt;/td&gt;
        &lt;td&gt;&lt;a href="personform?person_id=$person.Id"&gt;#springMessage("list.edit")&lt;/a&gt; | &lt;a
         href="persondetail?person_id=$person.Id"&gt;#springMessage("list.view")&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    #end
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Tag <code>#springMessage</code> membutuhkan satu argumen, yaitu nama yang kita berikan untuk tulisan tersebut. Ini akan menjadi jelas setelah kita lihat file text yang menampung tulisan tersebut, misalnya saya beri nama <code>messages.properties</code>.</p>

<h3>messages.properties</h3>

<pre><code>list.edit = edit
list.view = lihat

personlist.title = Daftar Orang
personlist.name = Nama
personlist.email = Alamat Email
</code></pre>

<p>Setelah file tersebut siap, kita konfigurasi Spring agar membaca file tersebut. Lokasi konfigurasinya ada di <code>tutorial-servlet.xml</code>. Berikut isinya.</p>

<h3>tutorial-servlet.xml</h3>

<pre><code>&lt;bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource"
      p:basename="messages" /&gt;
</code></pre>

<p>Nah, silahkan deploy ulang aplikasinya. Sekarang semua tulisan yang tampil sudah bisa dikonfigurasi melalui text file.</p>

<p>Selanjutnya, bagaimana mengakses file tulisan tersebut dari kode Java? Kita membutuhkannya untuk menampilkan pesan error dari hasil import data.</p>

<p>Mudah saja, langsung saja gunakan object <code>messageSource</code> yang sudah kita deklarasikan tadi. Kita dapat mendapatkan object tersebut dengan menggunakan dependency injection. Berikut adalah kode PersonCSVParser yang akan menggunakan <code>messageSource</code>.</p>

<h3>PersonCSVParser.java</h3>

<pre><code>package tutorial.spring25.helper;

@Component
public class PersonCSVParser {
    private MessageSource messageSource;

    @Autowired(required=true)
    public void setMessageSource(MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    @SuppressWarnings("unchecked")
    public void parse(List&lt;String&gt; data, List&lt;Person&gt; result, List&lt;ParseError&gt; errors) {

        -- snip --

        // check for malformed data
        if(tokenizer.countTokens() != PERSON_NUM_FIELDS) {
            errors.add(new ParseError(
                counter, text,
                messageSource.getMessage(
                    "parseerror.reason.malformed",
                    new Object[]{2,tokenizer.countTokens()},
                    Locale.getDefault()
                )
            ));
        }

        -- snip --

        if(bindErrors.hasErrors()) {
            List&lt;ObjectError&gt; bindErrorContent = bindErrors.getAllErrors();

            for (ObjectError objectError : bindErrorContent) {
                errors.add(new ParseError(
                    counter, text,
                    messageSource.getMessage(
                        objectError.getCode(),
                        objectError.getArguments(),
                        Locale.getDefault()
                    )
                ));
            }
        }

        result.add(person);
    }
}
</code></pre>

<p>Nah, mudah bukan? Karena itu, dari hari pertama coding, langsung saja siapkan aplikasi Anda untuk i18n.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/aplikasi-web-spring25-5/">Aplikasi Web Dengan Spring 2.5 [Bagian 5]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-18T16:15:08+07:00" pubdate data-updated="true">Jan 18<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Aplikasi web &#8211;berbeda dengan aplikasi desktop&#8211; ditakdirkan untuk stateless. Artinya dia tidak menyimpan data untuk masing-masing user yang sedang aktif. Keputusan ini menyebabkan aplikasi web bisa diakses jutaan user sekaligus. Tapi juga menyebabkan perlu teknik khusus agar data user yang sedang aktif dapat disimpan dengan baik.</p>

<p>Tanpa kemampuan penyimpanan state, semua data yang dikirim user akan hilang setelah dia pindah halaman. Misalnya user:</p>

<ol>
<li>mengisi form 1, kemudian menekan tombol Next</li>
<li>mengisi form 2, kemudian menekan tombol Next</li>
<li>tiba di form 3. Pada saat ini, data yang diisi di form 1 sudah hilang</li>
</ol>


<p>Sebelum kita melihat kode program dengan Spring 2.5, terlebih dulu kita bahas konsepnya.</p>

<p>Data user yang kita bicarakan di sini adalah data sementara. Contoh klasik dari state user yang harus disimpan antara lain:</p>

<ul>
<li>kita berbelanja online. Barang-barang yang sudah kita pilih, tapi belum kita pesan, ini harus disimpan oleh aplikasi. Data ini sering disebut dengan istilah shopping cart (atau troli belanja)</li>
<li>kita sudah login untuk melihat email. Selama kita belum menyatakan selesai (dengan cara logout), kita ingin aplikasi menyimpan username dan password kita. Sehingga kita tidak perlu memasukkan username dan password setiap kali pindah dari satu email ke email lain.</li>
<li>kita mengisi form secara bertahap (wizard-style). Keseluruhan rangkaian proses baru berakhir pada saat form terakhir diisi. Tanpa state management yang baik, kita tidak bisa menggunakan rangkaian form. Kita terpaksa menggunakan satu form yang sangat panjang, dan menyuruh user mengisinya sekaligus dalam satu kali proses.</li>
</ul>


<p>Contoh yang kita sebutkan di atas membahas tentang data sementara yang harus dikelola sebelum disimpan ke database. Umurnya relatif lebih pendek daripada data permanen yang disimpan di database. Misalnya, username dan password selama user membaca email, disimpan dalam jangka waktu beberapa jam saja. Data wizard mungkin hanya disimpan beberapa menit saja, sampai form terakhir selesai dan keseluruhan data disimpan ke database. Walaupun beberapa situs, seperti Amazon, mungkin saja menyimpan data shopping-cart kita selama berbulan-bulan.</p>

<p>Ada beberapa cara yang dapat kita pilih untuk menyimpan state. Setidaknya ada dua pilihan lokasi :</p>

<ul>
<li>di client. Dengan menggunakan mekanisme cookie, kita dapat menyimpan data di browser client. Cara ini tidak membebani server, tapi kapasitas cookie di client relatif kecil. Kita tidak bisa menyimpan data yang terlalu banyak di cookie.</li>
<li>di server. Mekanismenya mirip dengan kalau kita belanja di hypermarket. Tas dan jaket kita titipkan di pintu masuk, kemudian kita akan diberikan token. Pada waktu kita keluar, token kita tukarkan dengan barang yang kita titipkan.</li>
</ul>


<p>Demikian juga dengan penyimpanan state. Ketika user pertama kali datang, dia akan mendapat token atau session ID. Aplikasi menyimpan state user di lokasi tertentu yang ditandai dengan session ID tersebut. Setiap request yang datang akan dilihat session IDnya dan datanya diambil untuk diproses.</p>

<p>Ada beberapa cara untuk menitipkan token pada user, beberapa yang sering digunakan antara lain:</p>

<ul>
<li>masukkan ke cookie. Ya kita pakai cookie lagi, tapi tidak menyimpan keseluruhan data state, melainkan cuma session ID saja.</li>
<li>disisipkan di setiap link dan form. URL yang tadinya seperti ini : <code>http://localhost/aplikasi/personlist</code> menjadi seperti ini: <code>http://localhost/aplikasi/personlist?session_id=12a75tj67</code>.</li>
<li>dikirim ke server sebagai HTML input. Biasanya tipe yang dipilih adalah <em>hidden</em>. Cara ini memiliki kelemahan, karena tidak semua request bisa dibungkus dalam form.</li>
</ul>


<p>Data state yang disimpan di server juga memiliki beberapa pilihan lokasi penyimpanan, antara lain:</p>

<ul>
<li>di webserver. Webserver menulis satu file per satu session. Semua data disimpan di sini. Cara ini paling mudah dikonfigurasi, sehingga banyak webserver menjadikan cara ini sebagai default. Kelemahannya, metode ini menyulitkan kita untuk mengcluster webserver, karena kita kemudian harus memikirkan bagaimana mensinkronisasikan data session di masing-masing anggota cluster</li>
<li>di database. Webserver dikonfigurasi agar menyimpan datanya di database. Cara ini cukup sulit, mengingat dialek SQL masing-masing database berbeda. Banyak vendor webserver tidak mau menulis adapter untuk masing-masing merek database, sehingga kita harus periksa dulu apakah database yang kita gunakan didukung atau tidak. Bila tidak, kita terpaksa menulis sendiri kode program untuk state management.</li>
<li>di distributed cache. Ada beberapa aplikasi cache yang mengkhususkan diri untuk menyimpan data secara terdistribusi, misalnya <a href="name=">memcached</a> yang open source atau <a href="http://www.oracle.com/technology/products/coherence/index.html">Oracle Coherence</a> yang berbayar. Penyimpanan ini bisa dicluster sendiri, terpisah dari webserver. Dengan pendekatan ini, kita bisa mengcluster webserver sesuka hati, karena statenya tidak disimpan webserver, melainkan dititipkan di distributed cache. Kelemahan cara ini sama dengan metode database. Tidak semua webserver menyediakan support. Kadang kita harus tulis kodenya sendiri.</li>
<li>di upstream layer. Beberapa orang menggunakan arsitektur empat layer : client - web layer - application layer - database. Dengan arsitektur ini, semua state disimpan di application layer. Biasanya server yang digunakan untuk application layer memiliki mekanisme state management yang lebih baik daripada webserver. Terutama jika kita ingin melakukan clustering.</li>
</ul>


<p>Sekarang setelah kita mengerti konsepnya, mari kita implementasikan pada contoh aplikasi kita. Kita akan menggunakan state management untuk menampilkan hasil upload data Person.</p>

<p>Kode upload kita kemarin bekerja sebagai berikut :</p>

<ol>
<li>user melakukan upload dengan mensubmit form</li>
<li>server memproses, kemudian mengirim redirect ke halaman berikut</li>
<li>browser menerima perintah redirect, kemudian melakukan request GET ke URL lain sesuai perintah redirect</li>
<li>server menerima request GET, kemudian melakukan proses dan merender hasilnya</li>
<li>browser menampilkan respon dari server</li>
</ol>


<p>Teknik ini sering disebut Post-Redirect-Get (PRG) pattern.</p>

<p>Kesalahan umum programmer web pemula adalah memproses form sebagai berikut:</p>

<ol>
<li>user melakukan upload dengan mensubmit form</li>
<li>server memproses, kemudian merender hasilnya</li>
<li>browser menampilkan respon dari server</li>
</ol>


<p>Bila user merefresh halaman hasil, maka yang dilakukan browser adalah mengulang dari langkah 1. Ini akan mengakibatkan form tersubmit dua kali. Berbeda dengan teknik PRG, kalau user merefresh halaman hasil, maka browser akan mengulangi dari langkah ketiga, yaitu GET untuk halaman hasil. Dengan demikian form tidak disubmit dua kali.</p>

<p>Kita menghadapi tantangan untuk mengimplementasikan PRG pada halaman upload result. Kalau hanya sekedar pesan sukses, kita bisa membuat redirect ke <code>http://localhost/aplikasi/personuploadresult?msg=Sukses</code>. Tapi yang ingin kita tampilkan adalah daftar yang memuat mana data yang sukses diimport, dan mana data yang gagal. Sulit untuk dikirim melalui URL.</p>

<p>Untuk itu, kita harus simpan data tersebut di session. Berikut adalah kode pemrosesan upload yang sudah dimodifikasi.</p>

<h3>PersonUploadController.java</h3>

<pre><code>package tutorial.spring25.ui.springmvc;

@Controller
@RequestMapping("/personuploadform")
public class PersonUploadController {
    private static final Log LOG = LogFactory.getLog(PersonUploadController.class);
    private static final String REDIRECT_PERSONUPLOADRESULT = "redirect:personuploadresult";


    @RequestMapping(method=RequestMethod.POST) 
    public String processForm(@RequestParam("persondata") MultipartFile file, final HttpSession session) {

        // parse file into list of strings
        List&lt;String&gt; contents = new ArrayList&lt;String&gt;();
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream()));
            String content = reader.readLine();
            while(content != null) {
                contents.add(content);
                content = reader.readLine();
            }
            reader.close();
        } catch (IOException e) {
            LOG.warn(e.getMessage(), e);
        }


        // parse list of strings into list of Persons
        List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();
        List&lt;ParseError&gt; errors = new ArrayList&lt;ParseError&gt;();
        personDataParser.parse(contents, persons, errors);

        for (Person person : persons) {
            personDao.save(person);
        }

        session.setAttribute(Constants.PERSONUPLOAD_ERRORS_KEY, errors);
        session.setAttribute(Constants.PERSONUPLOAD_SUCCESS_KEY, persons);

        return REDIRECT_PERSONUPLOADRESULT;
    }
}
</code></pre>

<p>Perhatikan dua baris <code>session.setAttribute</code> di bagian bawah.
Setelah menyimpan data di session, kita redirect ke halaman hasil.</p>

<p>Pada halaman hasil, terlebih dulu kita pindahkan data hasil upload dari session ke request. Kemudian data yang ada di session kita hapus, agar tidak membebani memori ataupun kapasitas penyimpanan server. Lalu baru kita render tampilannya.</p>

<p>Berikut adalah kode untuk memindahkan data dari session ke request. Terletak di class <code>PersonController</code>, dalam method <code>uploadResult</code>.</p>

<h3>PersonController</h3>

<pre><code>package tutorial.spring25.ui.springmvc;

@Controller
public class PersonController { 

    @RequestMapping("/personuploadresult")
    public ModelMap uploadResult(final HttpSession session){
        final ModelMap modelMap = new ModelMap();

        if (session.getAttribute(Constants.PERSONUPLOAD_SUCCESS_KEY) != null) {

            modelMap.addAttribute(
                session.getAttribute(Constants.PERSONUPLOAD_SUCCESS_KEY)
            );

            session.removeAttribute(Constants.PERSONUPLOAD_SUCCESS_KEY);
        }

        if (session.getAttribute(Constants.PERSONUPLOAD_ERRORS_KEY) != null) {

            modelMap.addAttribute(
                session.getAttribute(Constants.PERSONUPLOAD_ERRORS_KEY)
            );

            session.removeAttribute(Constants.PERSONUPLOAD_ERRORS_KEY);
        }

        return modelMap;
    }
}
</code></pre>

<p>Dan ini adalah template yang digunakan untuk menampilkan hasil upload.</p>

<h3>personuploadresult.html</h3>

<pre><code>&lt;html&gt;

  &lt;head&gt;&lt;title&gt;:: Person Upload Result ::&lt;/title&gt;&lt;/head&gt;

  &lt;body&gt;

    &lt;h1&gt;Person Upload Result&lt;/h1&gt;

    &lt;h2&gt;Successfully Imported Person Data&lt;/h2&gt;
    #if (!$personList ||  ${personList.isEmpty()})

      &lt;h3&gt;No Data&lt;/h3&gt;

    #else

    &lt;table border="0" cellpadding="2" cellspacing="2"&gt;
      &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;th&gt;Email&lt;/th&gt;
        &lt;th&gt; &lt;/th&gt;
      &lt;/tr&gt;
      #foreach($person in $personList)
      &lt;tr&gt;
        &lt;td&gt;$person.Name&lt;/td&gt;
        &lt;td&gt;$person.Email&lt;/td&gt;
        &lt;td&gt;
          &lt;a href="personform?id=$person.Id"&gt;edit&lt;/a&gt; | 
          &lt;a href="persondetail?id=$person.Id"&gt;view&lt;/a&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
      #end
    &lt;/table&gt;

    #end


    &lt;h2&gt;Erroneous Data&lt;/h2&gt;
    #if (!$parseErrorList ||  ${parseErrorList.isEmpty()})

    &lt;h3&gt;No Data&lt;/h3&gt;

    #else

    &lt;table border="0" cellpadding="2" cellspacing="2"&gt;
      &lt;tr&gt;
        &lt;th&gt;Row&lt;/th&gt;
        &lt;th&gt;Data&lt;/th&gt;
        &lt;th&gt;Reason&lt;/th&gt;
      &lt;/tr&gt;

      #foreach($error in $parseErrorList)
      &lt;tr&gt;
        &lt;td&gt;$error.Line&lt;/td&gt;
        &lt;td&gt;$error.Text&lt;/td&gt;
        &lt;td&gt;$error.Reason&lt;/td&gt;
      &lt;/tr&gt;
      #end
    &lt;/table&gt;
    #end

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Di framework Ruby on Rails, sudah ada dukungan untuk kegiatan ini, namanya flash message. Flash message akan menyimpan data di session, kemudian menghapusnya pada request berikutnya.</p>

<p>Pada artikel ini kita sudah melakukan state management sederhana. Untuk kemampuan yang lebih canggih seperti pengelolaan shopping cart atau wizard, kita bisa menggunakan framework Spring Web Flow. Dengan SWF, flow aplikasi bisa diedit secara grafis. Ini akan memudahkan kita untuk mendokumentasikan flow navigasi aplikasi.</p>

<p><img src="/images/uploads/2008/01/webflow_editor.png" title="Spring Web Flow Editor" ></p>

<p>Gambar diambil dari <a href="http://springide.org/project/wiki/WebFlowEditorUsage">situsnya SWF</a>.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/14/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
    <a class="next" href="/page/12/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Endy Muhardin</h1>

<p>Software Developer berdomisili di Jabodetabek, berkutat di lingkungan open source, terutama Java dan Linux.</p>

<p>
    <ul>
        <li>
            <span class="icon-phone" style="text-align: left; width: 100%">&nbsp;
            +62 812 98000 468
            </span>
        </li>
        <li>
            <span class="icon-envelope" style="text-align: left; width: 100%">&nbsp;
                <a href="mailto:endy.muhardin@gmail.com">endy.muhardin@gmail.com</a>
            </span>
        </li>
        <li>
            <span class="icon-twitter" style="text-align: left; width: 100%">&nbsp;
                <a href="http://twitter.com/endymuhardin">@endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-github" style="text-align: left; width: 100%">&nbsp;
                <a href="https://github.com/endymuhardin">github.com/endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-facebook" style="text-align: left; width: 100%">&nbsp;
                <a href="http://facebook.com/endy.muhardin">facebook.com/endy.muhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-google-plus" style="text-align: left; width: 100%">&nbsp;
                <a href="http://google.com/+EndyMuhardin">google.com/+EndyMuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-linkedin" style="text-align: left; width: 100%">&nbsp;
                <a href="http://id.linkedin.com/pub/endy-muhardin/3/940/1bb">LinkedIn</a>
            </span>
        </li>
    </ul>
</p>
</section>

<section>

Bila artikel di website ini membantu meningkatkan penghasilan Anda, 
jangan ragu untuk memberikan donasi :)

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYByjmBHWB1u9oWkn33FHJ7Lu41iidZkdKLciblvSz2Oa/oBArw42F4/7nq3imMAWUvpA6Cx9zwNr3R7WqjnMlDr91VTkeyl1jusRB6Knw/JAaNI2yz20lbFtVNMhUrh2LJ6qXUwvdL4jvZeNUeOcvq/muETfy8BzgdKwCF3gNGpoTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQId7q7vUD8KwOAgaAyBdpVvmsdYWgKdVROwaJazFrOpQpWEncNGoycnyfeJRNwHXXZU1mj0oTJuvj/CUGr6cZC5RnQNBHC6FLnbjCVheTNtjBSs/CjD7HZMn28kElykLad2wDrFUsBkQCdRU43ZBLoRedRKbGVWP4wk6DgLovkwPzYNLKtl3clJbgm3UDXigmJqeAyvmafF2yk8LV4ACLTJtCu6qtSBVHkuUPToIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTMwNzExMDY0MjAwWjAjBgkqhkiG9w0BCQQxFgQUwzp1u86AW3VypUoSwjzfYA4KYn8wDQYJKoZIhvcNAQEBBQAEgYBExEV1zgHTrd+4zfXwIP0KO0/W7b4s2KDLbZ3Vq9FrtdtC9W3NEf6SbVZDYE+bEheP10XokfC8BslN7nZgsfPTvSNXv7ixfpWUVBb/gQB+QO70q1NZ2tuF2M/t1QzFUEZ9FeA0sgFMBS7nxmu7ynaSzez3B4FTG/jUzuRljVWhew==-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
</form>

</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/java/scope-variabel/">Scope Variabel</a>
      </li>
    
      <li class="post">
        <a href="/java/mengapa-kita-membuat-class/">Mengapa kita membuat class</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/pembagian-kerja-dalam-programming/">Pembagian Kerja dalam Programming</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/waterfall-is-the-best/">Waterfall is The Best</a>
      </li>
    
      <li class="post">
        <a href="/java/tips-meletakkan-file-konfigurasi-aplikasi/">Tips Meletakkan File Konfigurasi Aplikasi</a>
      </li>
    
      <li class="post">
        <a href="/akademik/tanya-judul-skripsi/">Tanya Judul Skripsi</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/belajar-project-management-dari-ubuntu/">Belajar Project Management dari Ubuntu</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/capacity-planning/">Capacity Planning</a>
      </li>
    
      <li class="post">
        <a href="/java/memahami-authentication/">Memahami Authentication</a>
      </li>
    
      <li class="post">
        <a href="/java/desain-skema-database/">Desain Skema Database</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
