
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Dari seluruh fase yang ada di project, fase Requirement Development adalah yang paling penting. Bila kita melakukan kegiatan requirement dengan asal- &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://software.endy.muhardin.com/page/9/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36102948-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:software.endy.muhardin.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="my_site_title">
            Living life and make it better
        </span>
       
           <span class="my_site_subtitle">
             life, learn, contribute
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/calendar">Calendar</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/fase-requirement/">Fase Requirement</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-18T04:20:29+07:00" pubdate data-updated="true">Apr 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Dari seluruh fase yang ada di project, fase Requirement Development adalah yang paling penting. Bila kita melakukan kegiatan requirement dengan asal-asalan, akibatnya antara lain :</p>

<ul>
<li><p>aplikasi sudah selesai dibuat, tapi tidak sesuai dengan keinginan user</p></li>
<li><p>pada fase coding, banyak terjadi delay karena ternyata ada requirement yang belum jelas</p></li>
<li><p>pada fase coding, banyak pekerjaan harus diulang karena salah memahami requirement</p></li>
</ul>


<p>Kenapa saya sebut dengan istilah Requirement Development, bukan Requirement Gathering seperti yang umum dipakai orang? Sebabnya adalah karena requirement yang baik itu tidak didapat dengan mudah. Tidak seperti memungut barang di jalanan (gathering), melainkan harus melalui proses yang iteratif (development). Kita tidak bisa mendapatkan requirement yang baik sekali jalan. Kita harus terus menerus melakukan investigasi, klarifikasi, verifikasi, agar requirement yang didapat benar-benar bagus kualitasnya.</p>

<p>Pada artikel ini, kita akan membahas bagaimana cara membuat requirement yang baik.</p>

<p>Sebelum ke masalah teknis, kita lihat dulu, kenapa kita harus melalui fase requirement? Kenapa tidak langsung coding saja? Kan customer ingin aplikasi jadi, bukan notulensi meeting dan setumpuk dokumen?</p>

<h2>Tujuan Requirement</h2>

<p>Kita melakukan requirement development karena kita ingin tahu apa yang ingin dibuat. Setelah mengetahui apa yang ingin dibuat, barulah kita bisa:</p>

<ul>
<li><p>memilih anggota tim yang tepat</p></li>
<li><p>memperkirakan biaya dan waktu yang dibutuhkan untuk membuatnya</p></li>
<li><p>memilih arsitektur dan teknologi yang sesuai</p></li>
</ul>


<p>Jadi, proses requirement membantu kita untuk melakukan project planning.
Selain itu, proses requirement juga membantu kita mencegah project menjadi molor dan merugi. Kalau kita langsung terjun coding, maka akan banyak waktu terbuang untuk melakukan perubahan. Misalnya, kalau kita sudah coding, ternyata user minta tambahan satu field entry, maka kita terpaksa mengubah tampilan, skema database, format report, dokumentasi user (kalau sudah ada), dan mungkin banyak lagi. Tapi kalau perubahan ini dilakukan pada fase requirement, paling effortnya cuma mengubah dummy dan dokumentasi user story saja.</p>

<p>Requirement juga bisa membantu kita mengendalikan perubahan dalam project, seperti kita akan lihat di bagian selanjutnya.</p>

<p>Setelah kita tahu tujuannya, mari kita ke langkah pertama yang paling menentukan.</p>

<h2>Identifikasi Usernya</h2>

<p>Segera setelah project dimulai, kita akan segera dihujani jadwal meeting untuk membahas requirement. Nah di sini kita harus jeli. Mendengarkan user itu penting, tapi yang lebih penting lagi adalah menjawab pertanyaan, siapa usernya?</p>

<p>Ada bermacam-macam jenis user, dan ini menentukan informasi apa yang ingin kita dengarkan, dan informasi mana yang kita abaikan.</p>

<ul>
<li><p>End User. Ini adalah user yang nantinya akan menggunakan aplikasi. Kita harus mendengarkan user ini, terutama dari sisi usability. Apakah aplikasi kita nyaman dipakai, mudah digunakan, indah dilihat, dan sebagainya. Tapi, jangan sekali-kali mengambil keputusan tentang proses bisnis dengan user ini. Jangan juga memutuskan untuk menambah/mengurangi fitur <strong>hanya</strong> berdasarkan pendapat user ini. Kita membutuhkan user selanjutnya, yaitu :</p></li>
<li><p>Sponsor atau Client. Ini adalah orang yang akan membayar invoice untuk pembuatan aplikasi. Semua keputusan penting (proses bisnis dan list fitur adalah penting) harus disetujui Client. Dan jangan salah, seringkali pendapat End User tidak sama dengan pendapat Client. Misalnya, Client menginginkan suatu transaksi harus melalui approval supervisor, manager, dan direktur secara berjenjang. Tapi tentunya fitur ini akan memberatkan End User, karena ada banyak proses yang harus dilalui. Nah, tentunya Anda tahu siapa yang harus kita dengarkan. Nah, jadi kapan-kapan melakukan requirement development, cari tahu dulu siapa yang mengotorisasi bilyet giro :D</p></li>
<li><p>Konsultan Internal. Seringkali di organisasi client, ada seseorang yang cukup senior dari sisi teknis. Bisa jadi dia adalah divisi IT di organisasi client, atau orang luar yang dipercaya oleh client. Apakah orang ini harus kita dengarkan pendapatnya? Tergantung dari seberapa besar pengaruhnya terhadap client. Kita bisa mengetes pengaruhnya dengan membuat satu fitur yang tidak sesuai dengan pendapat konsultan internal ini, dan lihat apa reaksi client. Kalau client setuju dengan kita, berarti pengaruhnya tidak besar, dan pendapat selanjutnya bisa kita diabaikan.</p></li>
<li><p>Customer. Ada kalanya Client membeli aplikasi kita untuk dijual lagi ke orang lain. Nah orang lain ini disebut Customer. Sukses atau tidaknya project kita banyak ditentukan oleh berapa customer yang bisa didapatkan client. Jadi, penting juga untuk kita mengetahui profil customer (kalau ada). Apa business objective dari customer, sehingga bisa kita akomodasi dengan baik</p></li>
</ul>


<p>Baiklah, saya sudah memetakan, si A adalah End User, si B Client, si C konsultan internal, dan si D adalah customernya. Apakah sekarang sudah bisa kita mulai interviewnya? Ok ok .. mari kita suruh Business Analyst (BA) untuk melakukan tugasnya. Oh, tunggu dulu, BA belum direkrut? Bagaimana kualifikasinya?</p>

<h2>Kualifikasi Business Analyst</h2>

<p>Pertama, BA harus menguasai proses bisnis. Kalau kita ingin membuat aplikasi akunting, BAnya harus mengerti akuntansi. Aturan sederhana dan logis, tapi masih banyak saja perusahaan yang mengirim programmer untuk melakukan requirement development.</p>

<p>Secara umum, BA harus sudah punya pengetahuan dasar dulu sebelum dia ketemu client. Kalau kita kirim programmer, maka dia bukan melakukan requirement development, tapi dia akan belajar bisnis proses ke client. Seperti kita akan lihat, ini pasti akan menimbulkan delay, karena :</p>

<blockquote><p>Seorang BA harus bisa membedakan mana proses bisnis yang fundamental dan jarang berubah (karenanya boleh dihardcode), mana yang kondisional dan sering berubah (sehingga harus configurable)</p></blockquote>

<p>Programmer yang belajar bisnis proses ke client tidak akan bisa membedakan ini. Sebagai contoh, mari kita lihat prosedur procurement.</p>

<p>Proses bisnis fundamentalnya adalah, ada pengajuan (purchase request), kemudian dilanjutkan dengan minta quotation ke vendor (request for quotation), memilih vendor, baru melakukan pemesanan (purchase order).
Ini adalah flow fundamental, dan boleh di-hardcode.</p>

<p>Kemudian end user akan bilang, purchase request akan dilakukan oleh masing-masing dept, approval dilakukan manager, dst, dst. Siapa yang mengentri, siapa yang mengapprove, dan pada nilai transaksi berapa dia boleh approve, ini adalah kondisional dan harus bisa dikonfigurasi.</p>

<p>Nah, seorang BA yang baik harus bisa membedakan kedua hal ini.</p>

<p>Coba temani BA anda pada saat sesi interview dengan end user. Kalau dia pernah bilang begini,</p>

<blockquote><p>Oh, di perusahaan Anda prosesnya begini ya? Biasanya yang umum dilakukan orang adalah seperti ini. Proses Anda kurang optimal karena blablabla. Apakah proses Anda mau berubah, atau aplikasi yang ingin ikut proses Anda dengan konsekuensi ABC?</p></blockquote>

<p>Nah, kapan-kapan dia minta naik gaji, jangan buru-buru ditolak. Ini BA bagus. Dia menguasai bidangnya, dan tahu best practices.</p>

<p>Banyak perusahaan yang ingin bikin produk dari project tapi tidak kunjung berhasil. Misalnya, ada client minta dibuatkan aplikasi gudang, trus manajemen mikir, &#8220;Wah kayaknya ini kalo dibikin jadi produk bakalan prospek&#8221;. Tapi ternyata setelah project selesai, aplikasinya tidak applicable di perusahaan lain. Ini salah satu sebabnya adalah BA yang kurang pengalaman sehingga tidak tahu mana fitur yang generik berlaku umum dan mana yang spesifik hanya untuk perusahaan tertentu saja.</p>

<p>Tahu bisnis proses saja masih kurang, BA yang baik juga paham usability. Seperti kita tahu, ada banyak cara untuk mengentri transaksi. Bisa dientri via screen, bisa upload file, bisa via HP, bisa import dari aplikasi lain, dsb. BA yang baik bisa memberikan rekomendasi pada programmer mengenai user experience. Bagaimana urutan screen, penempatan komponen, apakah pilihan tertentu disajikan dengan dropdown, radio, atau lookup.</p>

<p>Kalau BAnya tidak paham usability, aplikasi kita akan benar secara proses bisnis, tapi tidak enak digunakan. Programmer tidak bisa menentukan usability, karena dia tidak tahu bagaimana biasanya end-user menggunakan fitur tertentu.</p>

<p>Ok, BA saya sudah canggih, paham bisnis proses, tau best practices, dan pernah magang sama <a href="http://www.useit.com">Jakob Nielsen</a>. Bisa kita mulai interview user?</p>

<h2>Interview User</h2>

<p>Pada fase ini, biarkan saja BA menjalankan tugasnya. Dia akan berbicara dengan user, dan menanyakan hal-hal berikut:</p>

<ul>
<li><p>Flow global dari awal sampai akhir. Untuk aplikasi procurement, berarti dari request pembelian, sampai barang diterima.</p></li>
<li><p>Flow detail untuk masing-masing tahap. Contohnya, bagaimana detail flow proses request pembelian</p></li>
<li><p>Variasi skenario. Di sini BA akan mengidentifikasi percabangan dari tiap flow. Apa saja variasi skenarionya, perbedaan datanya, role user yang mengaksesnya, kondisi outputnya, dan sebagainya.</p></li>
</ul>


<p>Jangan lupa untuk meminta :</p>

<ul>
<li><p>Contoh report yang diinginkan</p></li>
<li><p>Sampel data transaksi untuk kita test di internal</p></li>
<li><p>Rumus atau formula perhitungan</p></li>
</ul>


<p>Tergantung clientnya, ada kemungkinan dia akan meminta perjanjian kerahasiaan sebelum mengeluarkan data-data di atas.</p>

<p>Setelah interview, BA pulang ke kantor, dan akan membuat dokumentasi requirement.</p>

<h2>Dokumentasi Requirement</h2>

<p>Untuk apa kita membuat dokumentasi? Tujuannya adalah</p>

<ul>
<li><p>Untuk mengidentifikasi kalau ada hal yang kurang jelas, sehingga bisa langsung ditanyakan</p></li>
<li><p>Sebagai bahan untuk verifikasi dengan user, apakah pemahaman kita sudah sama dengan yang dimaksud user.</p></li>
<li><p>Sebagai pedoman untuk programmer</p></li>
<li><p>Untuk mencegah project molor</p></li>
</ul>


<p>Lho, bagaimana bisa dokumen requirement mencegah project molor? Ya bisa saja, berikut alasannya</p>

<ul>
<li><p>Kalau ada kesalahan dan ditemukan pada fase ini, biaya perbaikannya jauh lebih kecil daripada kalau ditemukan pada fase coding. Misalnya ada kesalahan rumus perhitungan. Kalau kesalahan ini ditemukan pada fase requirement, paling biayanya cuma mengedit user story. Tapi kalau ditemukan pada waktu UAT, bisa-bisa butuh 2-3 hari untuk fixingnya. Ini <a href="http://www.stevemcconnell.com/articles/art08.htm">katanya Steve McConnell</a>, bukan bikin-bikinan saya.</p></li>
<li><p>Setelah requirement disign off, semua perubahan harus melalui change procedure. Ini mencegah project molor karena user terus menerus berubah pikiran. Sekarang maunya A, besok B, lusa ganti lagi.</p></li>
</ul>


<p>Lalu, apa saja yang harus didokumentasikan? Daripada panjang lebar, silahkan lihat <a href="http://software.endy.muhardin.com/downloads/user-story.odt">template User Story ArtiVisi</a>. Di situ sudah kita siapkan form isian apa saja yang harus dicantumkan.</p>

<p>Coba lihat dulu, supaya nyambung dengan pembahasan di bawah.</p>

<blockquote><p>Lho kenapa ada flow pengetesan? Apa bedanya dengan test scenario?</p></blockquote>

<p>Sama saja, yang kita maksud flow pengetesan memang adalah test scenario. Lalu apakah wajib dibuat pada fase requirement? Kami sangat menganjurkan untuk membuatnya, dengan alasan sebagai berikut:</p>

<ul>
<li><p>Dengan memikirkan bagaimana nanti pengetesannya, kualitas user story akan meningkat. BA terpaksa memikirkan step-by-step bagaimana aplikasi akan digunakan, apa inputnya, dan apa outputnya. Dengan memikirkan ini, semua variasi dan kebutuhan input, dan ekspektasi output mau tidak mau akan terpikirkan dan teridentifikasi sejak dini. Ini akan mengurangi requirement yang ambigu, tidak lengkap, atau tidak mungkin diimplementasikan</p></li>
<li><p>Test scenario yang ditandatangani user merupakan exit strategy bagi vendor. Kalau client sudah setuju dengan skenario testnya, maka vendor cukup membuat aplikasi yang lulus test tersebut. Setelah lulus test, jangan ditambah-tambahi lagi. Ini akan mencegah programmer menambah fitur-fitur menarik namun tidak memiliki business value.</p></li>
</ul>


<p>Seperti bisa dilihat pada template, kita mengharuskan adanya screen prototype di dokumen requirement. Screen ini dirancang oleh BA (makanya dia harus paham usability), dan kalau mau, bisa dibuatkan dummy-nya. Dummy bisa dibuat dengan apapun teknologi yang murah dan cepat. Begitu desain screen jadi, seharusnya tidak lebih dari 2 jam waktu yang dibutuhkan untuk membuat dummy-nya, bahkan untuk screen kompleks sekalipun.</p>

<p>Yang harus ada di desain screen adalah :</p>

<ul>
<li><p>Input field, harus jelas komponennya, apakah text, radio, dsb</p></li>
<li><p>Contoh isian. Jangan membuat input kosong, buatlah seolah-olah sudah diisi user. Ini akan memudahkan pada saat presentasi</p></li>
<li><p>Contoh output. Demikian juga dengan output hasil query, report, dsb. Jangan tampilkan tabel kosong. Isilah dengan data statis barang beberapa baris, agar user mempunyai gambaran bagaimana hasil akhirnya</p></li>
</ul>


<p>Tidak perlu repot-repot mengimplementasikan dummy ini. Semuanya adalah data statis yang langsung diketik apa adanya.</p>

<p>Dokumen user story dan dummy dipresentasikan ke end user dan direvisi sesuai input. Pada fase ini, end user bebas membuat perubahan apapun yang diinginkan. Perubahan bebas untuk diakomodasi, asal jangan pernah melupakan siapa yang tandatangan otorisasi bilyet giro :D</p>

<h2>Sign Off</h2>

<p>Setelah semua user story diiterasi dengan end user sampai puas, maka tiba saatnya untuk melakukan feature-freeze. Semua dokumentasi requirement diupdate sehingga sesuai kondisi terakhir, lalu minta approval tertulis dari client. Ingatlah selalu, <strong>approval client, bukan end-user, bukan konsultan internal</strong>. Ini adalah aktivitas paling critical dan harus dilakukan. Segala usaha proses requirement akan percuma tanpa sign off client.</p>

<h2>Change Management</h2>

<p>Sebelum sign off, end user bebas mengajukan perubahan apapun. Setelah sign off, semua perubahan harus melalui change procedure. Intinya adalah, perubahan diajukan secara tertulis, diestimasi penambahan durasi dan costnya, lalu diajukan ke manajemen, baik vendor maupun client. Kalau salah satu pihak tidak setuju, maka perubahan tidak akan dijalankan.</p>

<p><img src="/images/uploads/2010/02/change-procedure_id-724x1024.png" title="Prosedur Change Management" ></p>

<p>Lebih jelas tentang informasi apa saja yang dibahas di change management, bisa melihat <a href="http://software.endy.muhardin.com/downloads/change-request.odt">template change request ArtiVisi</a>.</p>

<p>Seperti kita lihat, di sini faktor sign off sangat berperan. Tanpa ada sign off, tidak ada batas kapan user bisa berubah seenaknya, dan kapan tidak boleh.</p>

<p>Kalau change management dijalankan dengan baik, project akan lebih terkontrol. Walaupun ada kemunduran, kedua belah pihak sadar apa sebabnya. Semua perubahan diketahui manajemen, sehingga tidak ada bos yang tiba-tiba muncul dan bilang</p>

<blockquote><p>Ini project kenapa gak beres-beres?</p></blockquote>

<p>Kunci sukses change management adalah mulai dari awal, dan perhatikan hal kecil. Kita sebagai vendor sering mengabaikan prosedur ini dengan berbagai alasan, diantaranya</p>

<ul>
<li><p>Ah perubahannya terlalu kecil, kalo langsung diimplement cuma 5 menit, tapi kalo change procedure bisa 2 hari.</p></li>
<li><p>Kita tidak mau terlihat birokratis seperti pegawai kelurahan perpanjang KTP</p></li>
<li><p>Kita berbaik hati pada client, masa perubahan sedikit saja hitung-hitungan banget</p></li>
</ul>


<p>Ini merupakan kesalahan besar. Dengan memberlakukan change procedure bahkan untuk hal kecil, kita akan menimbulkan kesadaran di client bahwa kita mengelola project dengan ketat. Dengan demikian, mereka tidak sembarangan meminta perubahan. Client juga akan menyadari bahwa perubahan kecil saja akan berdampak pada keseluruhan project.</p>

<p>Kalau kita memang ingin berbaik hati pada client, silahkan digratiskan. Tapi prosedur tetap dijalankan. Jadi kalo tiba-tiba ada bos client yang tanya seperti di atas, tinggal kita sodori binder berisi daftar change request yang sudah diapprove.</p>

<p>Change procedure juga ada bonusnya, yaitu tidak banyak mengganggu programmer. Estimasi dan approval mostly dilakukan oleh business analyst dan project manager. Dan belum tentu juga client setuju. Kita akan menghemat banyak waktu, konsentrasi, dan pikiran programmer yang tidak perlu memikirkan usulan perubahan yang ternyata tidak disetujui.</p>

<p>Di change request juga ada timing kapan change akan diberlakukan. Untuk menjaga konsentrasi dan ritme tim, PM bisa menggunakan opsi ini untuk menunda change ke iterasi selanjutnya.</p>

<h2>Requirement Traceability</h2>

<p>Yang satu ini titipan dari CMMI. Di process area Requirement Management, CMMI mengharuskan adanya <em>bidirectional traceability</em>. Artinya, setiap hal di requirement harus bisa ditelusuri dokumen desain mana yang membahasnya, baris kode mana yang mengimplementasikannya, test scenario mana yang memverifikasinya. Demikian juga sebaliknya (makanya disebut bidirectional), setiap baris kode, harus bisa ditelusuri requirement mana yang membutuhkannya.</p>

<p>Ini ide yang bagus. Dengan melaksanakan ini, kita memastikan bahwa effort coding kita benar-benar efisien. Tidak ada effort terbuang percuma untuk fitur-fitur yang tidak perlu. Demikian juga sebaliknya, kita memastikan bahwa semua requirement sudah diimplementasikan dan tidak ada yang ketinggalan.</p>

<p>Walaupun demikian, ide bagus belum tentu realistis di lapangan. Saat ini di ArtiVisi, kita baru bisa merelasikan antara baris kode dengan requirement dengan menggunakan Trac. Tapi tidak untuk dokumen lainnya seperti user manual, test scenario, dsb. Dan itupun tidak bidirectional.</p>

<p>Kalau ingin tahu bagaimana ini diimplementasikan, silahkan lihat <a href="http://sourceforge.net/projects/osrmt/">aplikasi ini</a>.</p>

<p>Oh iya, kalau kita sudah melakukan semua anjuran di artikel ini, lengkap dengan Requirement Traceability, kita sudah siap untuk diaudit untuk proses area Requirement Management (Maturity Level 2) dan Requirement Development (Maturity Level 3) :D</p>

<p>Demikian penjelasan tentang fase requirement. Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/tips-melaporkan-error/">Tips Melaporkan Error</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-15T04:38:02+07:00" pubdate data-updated="true">Apr 15<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>Update 2011-12-02: karena masih aja banyak yang belum paham, saya tambahkan template pertanyaan di akhir artikel.</p></blockquote>

<p>Sebagai programmer, setiap hari kita menghadapi software yang error. Bentuknya macam-macam, misalnya:</p>

<ul>
<li><p>Aplikasi yang kita buat error</p></li>
<li><p>Peserta milis menggunakan framework X dan mengalami masalah</p></li>
<li><p>Rekan sesama programmer membutuhkan bantuan</p></li>
<li><p>dsb</p></li>
</ul>


<p>Pada sebagian besar kasus, kita dengan senang hati akan membantu. Sudah menjadi sifat programmer untuk memiliki rasa keingintahuan yang tinggi dan senang terhadap teka-teki. Aplikasi yang error adalah teka-teki yang menarik.</p>

<p>Sayangnya, seringkali informasi error yang kita terima tidak lengkap sehingga butuh usaha tambahan untuk mengorek kejadian yang sebenarnya. Inilah yang membuat programmer seringkali keburu malas, sehingga akhirnya kegiatan solving error menjadi tidak fun lagi.</p>

<p>Berikut adalah beberapa tips untuk membuat laporan error yang baik, supaya programmer yang akan memecahkan masalah tersebut bisa segera bekerja dengan efektif.</p>

<p>Prinsip utama dalam melaporkan error adalah sebagai berikut</p>

<blockquote><p>Programmer bukan <del>Mama Loren</del> Baby Djenar atau Ki Joko Bodo. Dia tidak bisa membaca pikiran ataupun melakukan telepati. Jadi jangan menganggap programmer melihat apa yang dilihat user. User harus menjelaskan apa yang dia lihat.</p></blockquote>

<h2>Jelaskan lokasinya</h2>

<p>Seringkali si informan error berkata seperti ini,</p>

<blockquote><p>Help, aplikasinya error nih</p></blockquote>

<p>Nah, yang menerima informasi jelas bingung. Aplikasi yang mana?
Kalo client yang jadi informan, bisa jadi kita punya banyak project di sana.
Walaupun projectnya cuma satu, tapi aplikasi kan bisa terdiri dari banyak modul, screen, fitur, dsb.</p>

<p>Jadi, jelaskan di mana errornya. Di aplikasi apa, modul apa, screen yang mana. Terdengar simple, tapi nyatanya ada saja yang melewatkan hal pertama ini.</p>

<p>Mari kita lanjutkan.</p>

<h2>Tujuan</h2>

<p>Kita menggunakan aplikasi tentu ingin mencapai tujuan tertentu. Ingin menyimpan data customer, menampilkan laporan bulanan, dan lain sebagainya. Nah, tujuan ini harus disampaikan ke programmer. Soalnya sering terjadi percakapan seperti ini :</p>

<p>User (U) : Pak, fitur daftar produknya error.<br/>
Programmer (P) : Harusnya bisa kok, sudah kami test di sini tidak ada masalah.<br/>
U : Tapi saya coba tidak bisa<br/>
P : Coba jelaskan langkahnya<br/>
U : Saya buka menu daftar produk, muncul tabel berisi produk.
Kemudian saya klik dua kali nama produk dalam tabel, saya ganti isinya.
Setelah itu, saya tutup screennya.
Pas dibuka lagi, datanya tetap sama.<br/>
P : Lho, memangnya Ibu mau melakukan apa?<br/>
U : Saya mau edit harga produknya<br/>
P : Walah, bukan dari situ Bu. Gunakan menu edit produk</p>

<p>Nah, seringkali tujuan user tidak sesuai dengan fitur aplikasi. Jadi, beri tahukan tujuan user pada programmer.</p>

<h2>Langkah Reproduksi</h2>

<p>Begitu programmer akan mencoba memperbaiki error, dia akan mencoba mereproduksi error tersebut di komputernya sendiri. Nah di sinilah biasanya terjadi percakapan seperti ini :</p>

<p>U : Ini aplikasi error, tidak bisa simpan data<br/>
P : Oh, di sini saya coba bisa kok<br/>
U : Di sini tidak bisa<br/>
P : Di sini bisa<br/>
U : Tidak bisa<br/>
P : Bisa<br/>
dst</p>

<p>Akan lebih produktif kalau percakapannya seperti ini :</p>

<p>U : Ini aplikasi error, tidak bisa simpan data<br/>
P : Apa yang dilakukan?</p>

<p>U : Seperti ini :</p>

<ol>
<li>Buka screen Edit Produk</li>
<li>Pilih kategori Komputer dan Elektronik</li>
<li>Isi kode produk</li>
<li>Isi nama produk</li>
<li>Harga dikosongkan</li>
<li>Tekan tombol simpan</li>
</ol>


<p>Nah, dengan percakapan seperti ini, programmer bisa mengulangi apa yang dilakukan user.
Apakah langkah repro saja sudah cukup? Belum, masih ada 1 hal penting lainnya.</p>

<h2>Harapan dan Kenyataan</h2>

<p>Mari kita lanjutkan percakapan di atas.</p>

<p>U : Setelah ditekan tombol simpan, datanya tidak tersimpan.<br/>
P : Di tempat saya masuk kok ke database.<br/>
U : Di sini, setelah ditekan simpan tidak terjadi apa-apa<br/>
P : Maksudnya?<br/>
U : Ya harusnya kan ada pesan, &#8220;Data sudah tersimpan&#8221;<br/>
Ini tidak ada.</p>

<p>Nah, di sini harapan user adalah ada notifikasi dari aplikasi bahwa data sudah tersimpan. Tapi kenyataannya tidak ada notifikasi apa-apa dari aplikasi. User mengira ini error,
padahal programmer memang tidak menyediakan notifikasi tersebut, walaupun datanya sudah masuk ke database. Dari sini, programmer bisa menambahkan notifikasi sesuai harapan user.</p>

<p>Jadi, harapan dan kenyataan harus disampaikan pada programmer.</p>

<h2>Environment</h2>

<p>Ini maksudnya adalah kondisi di mana aplikasi dijalankan, seperti</p>

<ul>
<li><p>Sistem Operasi</p></li>
<li><p>Versi Aplikasi</p></li>
<li><p>Aplikasi lain yang terinstal</p></li>
</ul>


<p>Sering terjadi aplikasi error hanya di Linux saja, atau di Mac saja, tapi berjalan lancar di Windows. Atau sebaliknya. Dengan memberi informasi ini, programmer bisa lebih terarah dalam mencari kesalahan dalam kode program.</p>

<p>Demikian juga dengan versi aplikasi dan aplikasi lain yang terinstal. Seringkali sudah diketahui bahwa aplikasi kita tidak kompatibel dengan versi library tertentu, versi OS tertentu, atau dengan aplikasi lain. Misalnya seperti ini :</p>

<p>Tanya (T) : Saya instal Tomcat tapi error<br/>
Jawab (J) : Errornya gimana?<br/>
T : Katanya port 8080 tidak bisa digunakan. <br/>
J : Apakah ada webserver lain yang terinstal?<br/>
T : Web server sih tidak ada, saya cuma install database Oracle saja.<br/>
J : Oh, Oracle itu membawa web server sendiri, jalannya juga di 8080.<br/>
Coba matikan Oraclenya, atau ganti port Tomcat ke angka lain.</p>

<p>Demikian beberapa tips melaporkan error.</p>

<p>Berikut ringkasannya :</p>

<ol>
<li><p>Jelaskan Lokasinya</p></li>
<li><p>Sebutkan Tujuan</p></li>
<li><p>Langkah Reproduksi</p></li>
<li><p>Harapan dan Kenyataan</p></li>
<li><p>Environment</p></li>
</ol>


<p>Berikut template yang bisa digunakan untuk mengajukan pertanyaan.</p>

<p>Saya ingin &#8230;&#8230; (misal : mendeploy aplikasi di glassfish),
untuk itu saya melakukan langkah2 berikut :</p>

<ol>
<li>&#8230;.</li>
<li>&#8230;.</li>
<li>&#8230;.</li>
</ol>


<p>Setelah saya lakukan langkah di atas, saya mengharapkan hasil sbb:</p>

<ol>
<li>&#8230;..</li>
<li>&#8230;..</li>
<li>&#8230;..</li>
</ol>


<p>Tapi ternyata kok malah muncul hasil seperti ini :</p>

<ol>
<li>&#8230;.</li>
<li>&#8230;.</li>
<li>&#8230;.</li>
</ol>


<p>Sebagai tambahan informasi, saya menggunakan :</p>

<ol>
<li>Sistem Operasi &#8230; versi &#8230;</li>
<li>Bahasa Pemrograman &#8230; versi &#8230;</li>
<li>Database &#8230; versi &#8230;</li>
<li>Framework/Tools &#8230; versi &#8230;</li>
</ol>


<p>Dengan mengikuti tips ini berarti Anda sudah membantu kami untuk membantu Anda.
:D</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/dokumentasi-project/">Dokumentasi Project</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-03-10T07:41:06+07:00" pubdate data-updated="true">Mar 10<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pertanyaan yang sering muncul dalam pengelolaan proyek software adalah, &#8220;Dokumen apa saja yang harus dibuat?&#8221;</p>

<p>Tidak ada jawaban absolut untuk pertanyaan ini, semuanya tergantung situasi dan kondisi. Bahkan di satu perusahaan yang sama, kelengkapan dokumen projectnya bisa saja berbeda antar project.</p>

<p>Dalam artikel ini, kita akan membahas bagaimana menentukan dokumen yang digunakan dalam project.</p>

<blockquote><p>Disclaimer : Semua yang dijelaskan pada artikel ini ditulis berdasarkan pengalaman dan kebutuhan internal ArtiVisi. Kebutuhan Anda belum tentu sama dengan kami.</p></blockquote>

<p>Pertama, kita harus tahu dulu latar belakang kenapa dokumen project dibutuhkan. Setidaknya ada beberapa kegunaan dokumen project, yaitu</p>

<ul>
<li><p>sebagai media komunikasi di internal tim, dengan client, dengan manajemen, dan pihak lain yang berkepentingan (stakeholder)</p></li>
<li><p>sebagai catatan historis jalannya project</p></li>
<li><p>sebagai alat bantu untuk melihat kondisi terkini project (project visibility)</p></li>
<li><p>sebagai kontrak legal bila terjadi perselisihan</p></li>
</ul>


<p>Setelah kita mengetahui apa saja kegunaan dokumen, mari kita teliti satu persatu berdasarkan fase dalam project.</p>

<h2>Fase Sales</h2>

<p>Biasanya pada saat ada tawaran project, kita akan membuat proposal yang relatif tebal (> 10 halaman). Kami di ArtiVisi saat ini sudah hampir tidak pernah membuat proposal project, karena beberapa alasan berikut :</p>

<ul>
<li><p>semakin tebal dokumen, semakin tidak dibaca</p></li>
<li><p>membuang effort percuma untuk membuat dan maintenance</p></li>
</ul>


<p>Fungsi proposal sebenarnya adalah panduan awal untuk membuat agreement. Poin-poin yang ada di proposal akan dipindahkan ke agreement yang selanjutnya akan ditandatangani kedua belah pihak.</p>

<p>Kami menyederhanakan proposal menjadi quotation biasa, yang berisi informasi sbb :</p>

<ul>
<li><p>scope pekerjaan</p></li>
<li><p>out of scope</p></li>
<li><p>estimasi durasi</p></li>
<li><p>requirement khusus (misalnya performance requirement, integrasi dengan aplikasi lain, dsb)</p></li>
<li><p>nilai project</p></li>
<li><p>termin pembayaran</p></li>
</ul>


<p>Ada beberapa informasi yang biasa ada di proposal dan tidak ada di quotation, yaitu</p>

<ul>
<li><p>teknologi yang digunakan. Biasanya client kami menurut saja apa solusi yang kita rekomendasikan. Kalaupun ada requirement khusus, akan ditulis di bagian requirement khusus di quotation</p></li>
<li><p>skema layer, tier, database diagram, dsb. Biasanya, implementasi internal aplikasi tidak perlu dipikirkan client. Client cukup menentukan what to be built, dan kami yang memikirkan how to build. Kalau client ingin ikut cawe-cawe urusan internal, biasanya kita tawarkan outsourcing programmer saja, bukan project software.</p></li>
</ul>


<p>Selanjutnya, setelah quotation dinegosiasikan dan disetujui, tiba saatnya membuat agreement, atau perjanjian kerja sama. Ada beberapa poin yang dicantumkan dalam agreement, yaitu :</p>

<ul>
<li><p>scope pekerjaan</p></li>
<li><p>out of scope</p></li>
<li><p>estimasi durasi</p></li>
<li><p>klausul keterlambatan delivery</p></li>
<li><p>termin pembayaran</p></li>
<li><p>klausul keterlambatan pembayaran</p></li>
<li><p>prosedur change management</p></li>
</ul>


<p>Dari beberapa poin di atas, poin klausul keterlambatan delivery harus mendapat perhatian khusus. Keterlambatan delivery bisa terjadi karena banyak sekali sebab. Tidak semua diantaranya adalah kesalahan tim project. Oleh karena itu, kalau ada klausul seperti ini di agreement, tim project harus mengeluarkan effort ekstra untuk melakukan project tracking. Dengan demikian, bila terjadi keterlambatan, ada data yang lengkap mengenai riwayat dan penyebab keterlambatan tersebut.</p>

<p>Selesai bagian agreement, mari kita masuk ke tahap berikutnya.</p>

<h2>Project Planning</h2>

<p>Tujuan dari dilakukannya dokumentasi pada fase ini adalah untuk mengkomunikasikan bagaimana project akan berjalan, baik ke internal tim maupun ke client. Berikut informasi yang ada dalam project plan :</p>

<ul>
<li><p>Milestone dan Delivery : list urutan delivery yang akan disampaikan, isi dari masing-masing delivery, dan estimasi tanggalnya</p></li>
<li><p>Daftar Task untuk Milestone berikut. Kita tidak melakukan breakdown untuk milestone lainnya, karena masih banyak ketidakpastiannya. Breakdown task hanya dilakukan untuk milestone yang ada di depan mata. Begitu suatu milestone akan selesai, baru dilakukan breakdown task untuk milestone selanjutnya.</p></li>
<li><p>Daftar Resiko Project : ini adalah hal-hal yang berpotensi menghambat jalannya project, seperti misalnya ada PIC client yang akan resign, teknologi yang belum familiar, dsb</p></li>
</ul>


<p>Kami tidak membuat Gantt chart. Sebabnya karena Gantt chart sangat menekankan pada dependensi antar task. Sedangkan di project software, dependensi sangat mudah berubah. Misalnya, kita definisikan Modul B dikerjakan setelah Modul A. Ternyata karena PIC client di modul A sedang ada training di luar kota, diputuskan bahwa Modul B akan dikerjakan duluan. Atau, tadinya direncanakan skema database akan dikerjakan sebelum desain UI. Tapi ternyata karena satu dan lain hal, terpaksa UI dikerjakan duluan.</p>

<p>Hal-hal seperti ini cukup sering terjadi dalam project. Sehingga penggunaan Gantt chart justru akan merepotkan kita dalam mengupdate project plan. Kita tahu, semakin sulit dokumen diubah, semakin malas kita mengubahnya, dan akhirnya dokumen tersebut menjadi tidak up to date.</p>

<h2>Project Tracking</h2>

<p>Project tracking adalah kegiatan untuk memantau jalannya project. Dalam kegiatan ini, project manager melihat kemajuan project, mengidentifikasi masalah yang terjadi, dan mencarikan solusinya. Kalau masalah yang terjadi berada di luar kemampuan PM, dia akan melakukan eskalasi, yaitu meminta bantuan ke atasannya.</p>

<p>Di ArtiVisi, kita cuma menggunakan satu dokumen untuk melakukan project tracking, yaitu progress report mingguan, yang berisi informasi sbb:</p>

<ul>
<li><p>Daftar task yang dikerjakan minggu ini dan statusnya, apakah sudah selesai, sedang dikerjakan, atau belum dimulai</p></li>
<li><p>Daftar task yang akan dikerjakan minggu depan</p></li>
<li><p>Daftar deliverable yang akan diberikan minggu depan</p></li>
<li><p>Resiko project saat ini. Daftar ini dibuat pada saat planning, terus menerus dipantau setiap minggu, dan dilaporkan statusnya</p></li>
<li><p>Masalah yang terjadi dalam project dan action plan yang dilakukan</p></li>
<li><p>Perubahan terhadap estimasi awal</p></li>
</ul>


<p>Dokumen ini dibuat oleh PM setelah berkonsultasi dengan pasukannya, kemudian dikirim ke manajemen internal dan client. Dengan tidak adanya Gantt chart, kita tidak perlu mengeluarkan effort ekstra untuk mengupdate Gantt chart.</p>

<h2>Fase Requirement</h2>

<p>Pada fase ini, tim project menganalisa kebutuhan user sebagai patokan di fase coding. ArtiVisi cuma membuat satu dokumen pada fase ini, yaitu User Story. Dokumen user story berisi informasi sbb:</p>

<ul>
<li><p>User Goal : tujuan yang ingin dicapai client dalam menggunakan fitur ini</p></li>
<li><p>Ijin Akses : security level untuk menjalankan fitur ini</p></li>
<li><p>Penjelasan : deskripsi naratif tentang fitur ini</p></li>
<li><p>Flow aplikasi : langkah-langkah untuk menjalankan fitur ini</p></li>
<li><p>Desain screen : screenshot prototype atau scan paper prototype</p></li>
<li><p>Rincian field : penjelasan masing-masing komponen dalam desain screen</p></li>
<li><p>Prasyarat : hal-hal yang harus terjadi/ada sebelum fitur ini bisa dijalankan</p></li>
<li><p>Kondisi awal : kondisi aplikasi (data, screen, dsb) sebelum fitur dijalankan</p></li>
<li><p>Kondisi akhir : kondisi aplikasi setelah fitur selesai dijalankan</p></li>
<li><p>Karakteristik khusus : kebutuhan khusus seperti response time, usability, dsb</p></li>
<li><p>Flow pengetesan : bagaimana cara mengetes fitur ini</p></li>
<li><p>Sign Off : persetujuan user bahwa deskripsi dalam fitur ini sudah sesuai keinginan</p></li>
</ul>


<p>Nantinya akan ada banyak dokumen User Story sesuai jumlah fitur dalam aplikasi. Setelah User Story ditandatangani, semua perubahan harus melalui change procedure, yaitu dengan mengisi change request form. Berikut informasi yang ada di dalam change request form :</p>

<ul>
<li><p>Penjelasan Perubahan : deskripsi dari apa saja yang ingin diubah</p></li>
<li><p>Alasan Perubahan : mengapa perubahan ini diajukan</p></li>
<li><p>Benefit : keuntungan bila perubahan diimplementasikan</p></li>
<li><p>Dampak : akibat terhadap durasi, effort, dokumen, source code bila perubahan jadi diimplementasikan</p></li>
<li><p>Estimasi : estimasi effort, durasi, cost untuk menjalankan perubahan ini</p></li>
<li><p>Approval : persetujuan manajemen baik kedua belah pihak terhadap perubahan ini</p></li>
</ul>


<h2>Fase Desain</h2>

<p>Di fase desain biasanya kami mendesain beberapa hal berikut:</p>

<ul>
<li><p>skema database</p></li>
<li><p>interkoneksi antar modul</p></li>
<li><p>protokol komunikasi</p></li>
<li><p>format data</p></li>
</ul>


<p>Walaupun prosesnya dilakukan, tapi tidak ada dokumen permanen yang dihasilkan. Skema database misalnya. Desain dibuat di papan tulis, dan langsung ditulis dalam bentuk source code (SQL atau Hibernate mapping). Bila suatu saat diperlukan diagram, akan digenerate dengan tools dari database development. Protokol komunikasi dan format data akan dibuat di dokumen user story sebagai requirement internal.</p>

<h2>Fase Coding</h2>

<p>Pada fase ini, kita menghasilkan source code dan user manual.</p>

<h2>Fase UAT</h2>

<p>Pada fase ini, kita membuat dua dokumen, yaitu hasil pengetesan sesuai skenario di User Story dan Berita Acara UAT. Biasanya (tapi tidak selalu), berita acara dan hasil pengetesan digunakan sebagai lampiran penagihan.</p>

<h2>Fase Implementasi</h2>

<p>Pada fase ini, cuma satu dokumen yang dihasilkan, yaitu Berita Acara Serah Terima Aplikasi. Dokumen ini dibuat dan ditandatangani setelah kegiatan implementasi selesai dilakukan. Beberapa kegiatan dalam fase ini antara lain :</p>

<ul>
<li><p>Instalasi Aplikasi</p></li>
<li><p>Training User</p></li>
<li><p>Deployment Aplikasi</p></li>
<li><p>Paralel Run</p></li>
</ul>


<p>Demikian dokumentasi project yang kita buat selama project. Tidak terlalu banyak kan? Berikut daftarnya</p>

<ol>
<li><p>Quotation</p></li>
<li><p>Agreement</p></li>
<li><p>Project Plan</p></li>
<li><p>Progress Report</p></li>
<li><p>User Story</p></li>
<li><p>Requirement Sign Off</p></li>
<li><p>Change Request Form (kalau perlu)</p></li>
<li><p>User Manual</p></li>
<li><p>Berita Acara UAT</p></li>
<li><p>Berita Acara Serah Terima Aplikasi</p></li>
</ol>


<p>Kesimpulannya, buatlah dokumen sesuai kebutuhan, bukan sesuai hype yang sedang trend saat ini dan bukan juga sesuai warisan leluhur.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/manajemen-proyek-sederhana/">Manajemen Proyek Sederhana</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-02-17T04:55:40+07:00" pubdate data-updated="true">Feb 17<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di berbagai milis yang saya ikuti, ada diskusi menarik yang muncul. Apa saja yang harus dilakukan untuk dalam project management? Bagaimana SOP (standard operating procedure) nya? Tools apa yang digunakan?</p>

<p>Saya sudah mencoba berbagai metodologi manajemen proyek sepanjang karir saya. Ala koboi di jaman jahiliah dulu, ala waterfall di perusahaan terdahulu, ala CMMI di BaliCamp, dan berbagai ala-ala lainnya. Sepanjang perjalanan tersebut, saya juga membaca tentang berbagai metodologi seperti XP, Scrum, Crystal, RUP, dsb.</p>

<p>Dari semuanya, tentu tidak ada metodologi yang bisa digunakan di semua kondisi. Segalanya serba tergantung keadaan. Walaupun demikian, hasil pengalaman bertahun-tahun tersebut sudah memberikan saya pemahaman tentang latar belakang di aturan-aturan CMMI maupun di metodologi lainnya. Begitu kita mendapatkan alasan dibalik aturan tersebut, kita bisa mengambil esensinya dan mengimplementasikannya dengan bentuk lain yang sesuai dengan situasi kita.</p>

<p>Berikut adalah manajemen proyek ala ArtiVisi.</p>

<h2>Fase dan Siklus</h2>

<p>Sebelum membahas lebih jauh tentang manajemen proyek, kita luruskan dulu beberapa istilah. Kita mengenal istilah fase dan siklus (lifecycle)</p>

<p>Fase adalah tahapan yang dilalui dalam membuat aplikasi. Biasanya, dalam satu fase akan terdiri dari banyak task.</p>

<p>Fase yang ada di internal ArtiVisi adalah sebagai berikut :
1. Requirement Development
2. Coding
3. User Acceptance Test
4. Implementasi</p>

<p>Keempat fase ini berjalan secara serial, artinya, fase coding baru bisa dimulai setelah requirement development selesai, dsb.
Mendengar ini, pembaca yang beraliran progresif revolusioner pasti langsung demo di Bundaran HI, &#8220;Waterfall is dead, long live Agile !!!&#8221;</p>

<p>Tunggu dulu sebentar, waterfall dan iteratif itu adalah lifecycle, bukan fase.</p>

<p>Lalu apa itu lifecycle? Lifecycle adalah urutan kita menjalankan fase tersebut <strong>di keseluruhan project</strong>. Bagaimana maksudnya ini?</p>

<p>Begini, misalnya kita membuat aplikasi akunting. Aplikasi ini terdiri dari beberapa modul yaitu; ledger, hutang/piutang, dan manajemen kas. Lifecycle waterfall adalah apabila kita menjalankan project dengan urutan seperti ini :</p>

<ol>
<li><p>Project Planning</p>

<ol>
<li>Modul Ledger</li>
<li>Modul Hutang/Piutang</li>
<li>Modul Kas</li>
</ol>
</li>
<li><p>Requirement Development</p>

<ol>
<li>Modul Ledger</li>
<li>Modul Hutang/Piutang</li>
<li>Modul Kas</li>
</ol>
</li>
<li><p>Coding</p>

<ol>
<li>Modul Ledger</li>
<li>Modul Hutang/Piutang</li>
<li>Modul Kas</li>
</ol>
</li>
<li><p>UAT</p>

<ol>
<li>Modul Ledger</li>
<li>Modul Hutang/Piutang</li>
<li>Modul Kas</li>
</ol>
</li>
<li><p>Implementasi</p>

<ol>
<li>Modul Ledger</li>
<li>Modul Hutang/Piutang</li>
<li>Modul Kas</li>
</ol>
</li>
</ol>


<p>Lifecycle waterfall memang memiliki banyak kelemahan, apalagi kalau projectnya besar. Karena rentang waktu yang jauh antara fase requirement dan fase UAT, maka biasanya pada saat UAT user merasa kaget karena merasa aplikasi yang dibuat tidak sesuai ekspektasi. Entah karena user sudah lupa requirement yang dia bikin sendiri, ataupun karena proses bisnisnya memang sudah berubah.</p>

<p>Lifecycle yang dijalankan ArtiVisi adalah Staged Delivery, seperti yang dijelaskan di bukunya Steve McConnell berjudul Rapid Development. Berikut urutannya.</p>

<ol>
<li><p>Global / High Level</p>

<ol>
<li>Project Planning</li>
<li>Requirement Development</li>
</ol>
</li>
<li><p>Modul Ledger</p>

<ol>
<li>Project Planning</li>
<li>Requirement Development</li>
<li>Coding</li>
<li>UAT</li>
<li>Implementasi</li>
</ol>
</li>
<li><p>Modul Hutang/Piutang</p>

<ol>
<li>Project Planning</li>
<li>Requirement Development</li>
<li>Coding</li>
<li>UAT</li>
<li>Implementasi</li>
</ol>
</li>
<li><p>Modul Kas</p>

<ol>
<li>Project Planning</li>
<li>Requirement Development</li>
<li>Coding</li>
<li>UAT</li>
<li>Implementasi</li>
</ol>
</li>
</ol>


<p>Pendekatan ini bukan waterfall, karena delivery-nya iteratif dan kecil-kecil. Satu modul biasanya berkisar 1 - 2 bulan saja, kira-kira sesuai dengan panjang sprint yang dianjurkan di metodologi Scrum. Tapi pendekatan ini juga bukan murni agile, karena ada global project planning dan requirement di awal. Untuk apa ada kegiatan itu? Tidak lain dan tidak bukan adalah untuk mengantisipasi interkoneksi antar modul.</p>

<p>Bila kita langsung mengambil salah satu modul untuk diiterasi, maka ada resiko modul tersebut tidak nyambung dengan modul lainnya. Memang bisa disambungkan, tapi nanti akan berkesan tambal sulam. Istilahnya Fred Brooks dalam Mythical Man Month, tidak ada Conceptual Integrity. Oleh karena itu kita perlu melakukan global requirement development untuk melihat interaksi antar modul.</p>

<p>Pembaca yang teliti mungkin juga akan bertanya, mengapa kita menggunakan istilah Requirement Development, bukannya Requirement Gathering? Ini karena untuk mendapatkan requirement, perlu usaha ekstra, tidak sekedar memungut (gathering) informasi di sana-sini. Seringkali kita harus menanyakan hal yang sama dari beberapa sudut pandang untuk mendapatkan apa maunya user. Di saat lain, kita harus bisa menebak fitur yang tersirat. Kalau user bilang, &#8220;Harus ada fitur untuk menyimpan data transaksi&#8221;, berarti tidak cuma ada screen edit dan list. Tapi juga harus ada fitur search berdasarkan tanggal, produk, nilai transaksi, dan atribut lainnya. Kadangkala ini juga berarti harus ada fitur untuk export/import ke format file lainnya. Jadi, untuk mendapatkan requirement, perlu proses development. Mulai dari sedikit, lalu diakumulasi, dan dikristalisasi sehingga benar-benar akurat dan lengkap. Jangan sampai ada yang ketinggalan.</p>

<p>Kelima fase yang dijelaskan di atas merupakan fase yang sekuensial. Artinya, satu fase dijalankan setelah fase lain selesai. Kita tidak bisa mulai implementasi sebelum UAT selesai. Well, bisa sih, tapi hasilnya <em>tidak akan menyenangkan</em>. Demikian juga, kalau belum selesai coding, ya jangan UAT dulu. Bisa sih maksain UAT, tapi tentu <em>tidak akan menyenangkan</em>. Begitu juga halnya kalau kita coding sebelum jelas requirementnya.</p>

<p>Selain fase yang sekuensial tersebut, ada juga serangkaian kegiatan yang harus kita lakukan secara kontinyu sepanjang project. Yaitu project tracking dan change management.</p>

<h2>Project Tracking</h2>

<p>Project tracking tidak sulit. Setiap minggu, harus ada orang yang melihat project plan dan membandingkan dengan kondisi sekarang. Task mana yang sudah selesai, mana yang sedang dikerjakan, mana yang sudah selesai. Kondisi sekarang ini direkap ke dalam satu laporan, 1-2 halaman, dan dilaporkan ke client dan manajemen. Di ArtiVisi, mengadopsi dari BaliCamp, selain rekap task juga disertakan rekap resiko dan masalah yang terjadi dalam proyek. Ini akan menjadi bahan diskusi dengan client, bagaimana cara memecahkan masalah tersebut, dan bagaimana mencegah resiko agar tidak berdampak merugikan.</p>

<h2>Requirement Development</h2>

<p>Sebelum membahas change management, kita bahas dulu requirement. Di ArtiVisi, requirement bentuknya adalah daftar screen aplikasi, biasanya dibuat dengan Netbeans. Kami tidak menggunakan format naratif seperti yang dianut beberapa organisasi dan dinamai User Requirement Specification (URS), Business Requirement Specification (BRS), atau Software Requirement Specification (SRS), User Story, atau istilah-istilah lainnya. Berdasarkan pengalaman, dokumen naratif membuat user malas berinteraksi. Untuk aplikasi shopping cart sederhana saja, bila dibuatkan <em>RS, akan menjadi lebih dari 20 halaman. Apalagi untuk aplikasi yang besar. Client akan malas membaca, dan akibatnya pada saat aplikasi dideliver hasilnya tidak sesuai ekspektasi, walaupun sesuai dengan </em>RS.</p>

<p>ArtiVisi menggunakan prototype aplikasi untuk requirement. Kita buatkan screen desktop ataupun web, diisi data hardcoded, dan sudah memiliki menu dan flow. Dari screen registrasi klik submit akan masuk screen konfirmasi, dst. Dengan menggunakan prototype yang bisa diisi dan diklik, user akan lebih bersemangat untuk berinteraksi, sehingga hasil requirement akan menjadi berkualitas. Pada fase requirement ini user bebas meminta modifikasi apapun asal masih dalam scope yang disepakati.</p>

<p>Setelah tidak ada lagi perubahan signifikan, semua screen dicapture, dimasukkan ke dokumen, dan diapprove client (sign off). Ini akan menjadi patokan dalam proses development, diantaranya digunakan oleh programmer untuk coding, dan technical writer untuk membuat user manual.</p>

<h2>Change Management</h2>

<p>Perubahan setelah sign off harus melalui prosedur change management. Ini gunanya agar progress project bisa terkendali. Sering sekali banyak project molor dan tidak selesai-selesai karena banyak perubahan ini itu yang tidak dikelola dengan baik sehingga tidak terlihat titik akhirnya.</p>

<p><img src="/images/uploads/2010/02/change-procedure_id-212x300.png" title="Prosedur Change Management" ></p>

<p>Prosedur change management tidak rumit. Hanya terdiri dari tiga langkah saja, yaitu :</p>

<ol>
<li>Requester menjelaskan perubahan yang diminta, apa alasan yang mendasari perubahan</li>
<li>Tim development menganalisa dampak perubahan, apakah ada coding yang berubah, user manual, test scenario, dsb. Output dari analisa ini adalah estimasi berapa tambahan waktu, tenaga, dan biaya untuk mengeksekusi perubahan ini</li>
<li><p>Manajemen di sisi client memutuskan berdasarkan estimasi tersebut, apakah perubahan ini akan :</p>

<ul>
<li>Dijalankan segera</li>
<li>Ditunda ke iterasi berikut</li>
<li>Ditolak, artinya tidak jadi dijalankan pada project ini, mungkin saja dijadikan project baru.</li>
</ul>
</li>
</ol>


<p>Dengan adanya proses ini, akan jelas berapa hari project akan mundur, dan berapa biaya tambahannya.</p>

<p>Demikian sharing tentang praktek yang kita gunakan di ArtiVisi. Metodologi ini cukup sederhana, sehingga bisa dijalankan bahkan di project yang one-man-show. Project manager dia, business analyst dia, programmer dia juga, training lagi-lagi dia, terima transferan tidak lain dan tidak bukan adalah dia juga. Di project berskala besar, metodologi ini juga cukup efektif untuk membuat project berjalan secara predictable.</p>

<p>Masih ada penjelasan lebih lanjut yang harus ditulis, diantaranya bagaimana cara menghitung (estimasi) project, dan bagaimana melakukan project planning dan tracking yang efektif. Ini akan dibahas di tulisan yang lain.</p>

<p>Bila ingin berkomentar atau berdiskusi, silahkan bergabung di milis it-project-indonesia@googlegroups.com dengan cara mengirim email kosong ke it-project-indonesia-subscribe@googlegroups.com</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/log4j-spring-mvc/">Konfigurasi Lokasi Logfile Pada Spring MVC</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-15T19:38:18+07:00" pubdate data-updated="true">Jul 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di mana kita harus menyimpan log output aplikasi kita? Tentunya kita ingin menggunakan lokasi yang dinamis sesuai dengan lokasi deployment. Misalnya, di Windows kita mungkin mendeploy aplikasi kita di</p>

<pre><code>C:\Program Files\Apache Tomcat\webapps\aplikasi-saya
</code></pre>

<p>Sedangkan di Linux, kita mendeploy aplikasi di</p>

<pre><code>/opt/apache-tomcat/webapps/aplikasi-saya
</code></pre>

<p>Dengan kemungkinan seperti di atas, bagaimana kita harus menulis konfigurasi log4j?
Mudah, bila kita menggunakan Spring MVC.</p>

<p>Kita bisa menggunakan <code>Log4jConfigListener</code> yang disediakan Spring. Class ini memungkinkan kita menggunakan variabel di konfigurasi log4j kita. Kita mendaftarkan class ini di dalam <code>web.xml</code>, sebelum <code>ContextLoaderListener</code>, seperti ini :</p>

<pre><code>    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>

<p>Dengan adanya <code>Log4jConfigListener</code> ini, kita bisa menyebutkan lokasi konfigurasi log4j seperti ini :</p>

<pre><code>    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:artivisi-log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>

<p>Isi <code>artivisi-log4j.properties</code> terlihat seperti ini :</p>

<pre><code># Konfigurasi kategori
log4j.rootLogger=INFO,fileout

# File output
log4j.appender.fileout=org.apache.log4j.DailyRollingFileAppender
log4j.appender.fileout.file=${webapp.root.path}/WEB-INF/logs/application.log
log4j.appender.fileout.datePattern='.'yyyy-MM-dd
log4j.appender.fileout.layout=org.apache.log4j.PatternLayout
log4j.appender.fileout.layout.conversionPattern=%d [%t] %p (%F:%L) ­ %m%n
</code></pre>

<p>Perhatikan konfigurasi <code>log4j.appender.fileout.file</code>. Kita menggunakan variabel <code>${webapp.root.path}</code> yang akan diisi dengan nilai lokasi deployment aplikasi web kita. Variabel <code>${webapp.root.path}</code> ini didefinisikan dalam web.xml sebagai berikut :</p>

<pre><code>    &lt;context-param&gt;
        &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;
        &lt;param-value&gt;webapp.root.path&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>

<p>Dengan konfigurasi ini, kita dapat meletakkan log output kita di</p>

<pre><code>C:\Program Files\Apache Tomcat\webapps\aplikasi-saya\WEB-INF\logs\application.log
</code></pre>

<p>bila kita mendeploy di Windows, dan di</p>

<pre><code>/opt/apache-tomcat/webapps/aplikasi-saya/WEB-INF/logs/application.log
</code></pre>

<p>bila kita deploy di Linux.</p>

<p>Konfigurasi di atas bisa disederhanakan lagi bila kita mengikuti nilai default yang disediakan Spring, yaitu cukup seperti ini dalam <code>web.xml</code> :</p>

<pre><code>    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>

<p>Kemudian memberi nama file konfigurasi logger kita <code>log4j.properties</code> yang berada di top level dalam classpath, dan berisi seperti ini :</p>

<pre><code># Konfigurasi kategori
log4j.rootLogger=INFO,fileout

# File output
log4j.appender.fileout=org.apache.log4j.DailyRollingFileAppender
log4j.appender.fileout.file=${webapp.root}/WEB-INF/logs/application.log
log4j.appender.fileout.datePattern='.'yyyy-MM-dd
log4j.appender.fileout.layout=org.apache.log4j.PatternLayout
log4j.appender.fileout.layout.conversionPattern=%d [%t] %p (%F:%L) ­ %m%n
</code></pre>

<p>Nilai variabel <code>${webapp.root}</code> secara default akan diisi dengan lokasi deployment tanpa harus mengkonfigurasi <code>webAppRootKey</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/spring-httpinvoker-sun-jre6-httpserver/">Menjalankan Spring HTTP Invoker Di Sun JRE 6 HTTP Server</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-03T21:41:28+07:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Dulu, kita sudah mencoba untuk <a href="http://endy.artivisi.com/blog/java/remoting-dengan-spring/">membuat remoting service dengan menggunakan Spring Framework</a>. Salah satu protokol yang digunakan adalah Spring HTTP Invoker. Untuk mempublish service dengan protokol ini, kita harus menggunakan servlet engine, misalnya Tomcat.</p>

<p>Akan tetapi, Sun Microsystem merilis Java versi 6 yang sudah dilengkapi dengan HTTP Server sederhana. Dengan memanfaatkan fitur ini, kita tidak perlu lagi menggunakan Tomcat hanya untuk mempublish service dengan HTTP Invoker. Ini akan sangat bermanfaat untuk aplikasi kecil yang ingin dipanggil oleh aplikasi lain.</p>

<p>Pada artikel ini, kita akan mempublish service dengan protokol HTTP Invoker pada HTTP Server yang disediakan oleh Sun JRE versi 6.</p>

<p>Di Netbeans, kita akan membuat tiga project, yaitu</p>

<ul>
<li><p>remoting-shared : project ini menampung interface RemotingService, yang akan digunakan di client dan server</p></li>
<li><p>remoting-server : project ini yang akan mempublish service. Implementasi RemotingService juga ada di sini</p></li>
<li><p>remoting-client : project ini yang akan mengakses service yang dipublish remoting-server</p></li>
</ul>


<p>Berikut screenshot Netbeans. Project remoting-server dan remoting-client memiliki dependensi terhadap remoting-shared.</p>

<p>Pertama, mari kita lihat dulu service interfacenya. Berikut adalah kode programnya.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.service.api;

public interface RemotingService {
    public String halo(String nama);
}
</code></pre>

<p>Kode program ini berada di project remoting-shared.</p>

<p>Berikutnya, kita lihat dulu di sisi client. Kita cuma butuh satu class untuk menjalankan aplikasi, yaitu ClientLauncher sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.client;

public class ClientLauncher {
    private static final Logger log = Logger.getLogger(ClientLauncher.class.getName());
    public static void main(String[] args) {
        AbstractApplicationContext ctx = 
                new ClassPathXmlApplicationContext("client-ctx.xml", ClientLauncher.class);
        ctx.registerShutdownHook();

        RemotingService service = (RemotingService) ctx.getBean("remotingService");

        String msg = service.halo("endy");

        log.info("Pesan dari server : "+msg);
    }
}
</code></pre>

<p>ClientLauncher akan membaca client-ctx.xml yang isinya seperti ini.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;!--  proxy dengan protokol HTTP Invoker  --&gt;
    &lt;bean id="remotingService"
    class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
         &lt;property name="serviceUrl" 
         value="http://localhost:9090/RemotingService"/&gt;

         &lt;property name="serviceInterface"
         value="com.artivisi.tutorial.remoting.spring.service.api.RemotingService"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>Seperti kita lihat di atas, client mengakses service yang ada di komputer lokal (localhost) di port 9090, dengan nama service RemotingService.</p>

<p>Selanjutnya, mari kita implement project remoting-server. Di sini ada implementasi RemotingService sebagai berikut</p>

<pre><code>/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package com.artivisi.tutorial.remoting.spring.service.impl;

@Service("remotingService")
public class RemotingServiceImpl implements RemotingService {
    Logger log = Logger.getLogger(RemotingServiceImpl.class.getName());

    public String halo(String nama) {
        log.info("Terima dari client : "+nama);
        return "Halo, "+nama;
    }

}
</code></pre>

<p>Kemudian ada class untuk menjalankan aplikasi di sisi server. Berikut ServerLauncher.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.server;

public class ServerLauncher {
    public static void main(String[] args) {
        AbstractApplicationContext ctx =
                new ClassPathXmlApplicationContext("server-ctx.xml", ServerLauncher.class);
        ctx.registerShutdownHook();
    }
}
</code></pre>

<p>ServerLauncher membaca file konfigurasi server-ctx.xml. Inilah isinya.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;!-- menginstankan Sun HttpServer dalam JRE 6 --&gt;
    &lt;bean class="org.springframework.remoting.support.SimpleHttpServerFactoryBean"&gt;
        &lt;property name="contexts"&gt;
            &lt;map&gt;
                &lt;entry key="/RemotingService" value-ref="remotingServiceHttpInvoker"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="port" value="9090" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>

<p>Pada blok konfigurasi pertama, kita menginstankan Sun HttpServer yang ada di JRE 6. HttpServer ini akan berjalan di port 9090, sesuai dengan yang kita konfigurasi di sisi client. Di sana terlihat bahwa URL /RemotingService akan ditangani oleh remotingServiceHttpInvoker. Berikut konfigurasinya</p>

<pre><code>    &lt;!--  publish service dengan protokol HttpInvoker  --&gt;
    &lt;bean id="remotingServiceHttpInvoker" 
          class="org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"
          p:service-ref="remotingService"
          p:serviceInterface="com.artivisi.tutorial.remoting.spring.service.api.RemotingService"
     /&gt;
</code></pre>

<p>Selanjutnya, kita suruh Spring mendeteksi implementasi service kita secara otomatis, yaitu class yang ada anotasi @Service.</p>

<pre><code>     &lt;context:component-scan base-package="com.artivisi"/&gt;
</code></pre>

<p>Berikut adalah dependensi pustaka di project client.</p>

<p><img src="/images/uploads/2009/07/remoting-library-client-300x220.png" title="Library untuk Project Client" ></p>

<p>Dan ini untuk di server.</p>

<p><img src="/images/uploads/2009/07/remoting-library-server-300x234.png" title="Library untuk Project Server" ></p>

<p>Keseluruhan project akan terlihat seperti ini.</p>

<p><img src="/images/uploads/2009/07/remoting-folder-structure-231x300.png" title="Struktur Folder semua Project" ></p>

<p>Semua library dapat diambil dari <a href="http://www.springsource.org/download">distribusi Spring Framework</a> dan <a href="http://www.springsource.com/repository/app/">Repository SpringSource</a>.</p>

<p>Coba jalankan ServerLauncher, kita akan melihat log seperti ini.</p>

<pre><code>Jul 3, 2009 2:57:25 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@be2358: display name [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]; startup date [Fri Jul 03 14:57:25 WIT 2009]; root of context hierarchy
Jul 3, 2009 2:57:26 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [server-ctx.xml]
Jul 3, 2009 2:57:26 PM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactory
INFO: Bean factory for application context [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]: org.springframework.beans.factory.support.DefaultListableBeanFactory@f11404
Jul 3, 2009 2:57:26 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@f11404: defining beans [org.springframework.remoting.support.SimpleHttpServerFactoryBean#0,remotingServiceHttpInvoker,remotingService,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor]; root of factory hierarchy
Jul 3, 2009 2:57:27 PM org.springframework.remoting.support.SimpleHttpServerFactoryBean afterPropertiesSet
INFO: Starting HttpServer at address 0.0.0.0/0.0.0.0:9090
</code></pre>

<p>Lalu jalankan ClientLauncher, inilah log yang muncul.</p>

<pre><code>Jul 3, 2009 2:58:12 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@be2358: display name [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]; startup date [Fri Jul 03 14:58:12 WIT 2009]; root of context hierarchy
Jul 3, 2009 2:58:12 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [client-ctx.xml]
Jul 3, 2009 2:58:13 PM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactory
INFO: Bean factory for application context [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]: org.springframework.beans.factory.support.DefaultListableBeanFactory@d2906a
Jul 3, 2009 2:58:13 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@d2906a: defining beans [remotingService]; root of factory hierarchy
Jul 3, 2009 2:58:13 PM com.artivisi.tutorial.remoting.spring.client.ClientLauncher main
INFO: Pesan dari server : Halo, endy
</code></pre>

<p>Setelah ClientLauncher dijalankan, di log server akan muncul informasi sebagai berikut.</p>

<pre><code>INFO: Terima dari client : endy
</code></pre>

<p>Demikianlah cara menggunakan embedded HttpServer. Selamat mencoba.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/postgresql-sequence-hibernate/">PostgreSQL Sequence Dengan Hibernate</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-22T22:08:58+07:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Menggunakan PostgreSQL Sequence dengan Hibernate</p>

<p>Pada artikel ini, kita akan membahas tentang bagaimana membuat Hibernate menggunakan sequence yang dibuat PostgreSQL.</p>

<p>Bila kita membuat Hibernate mapping untuk entity class sebagai berikut:</p>

<pre><code>@Entity @Table(name="example")
public class Example {
    @Id @GeneratedValue
    private Integer id;

    private String name;

    // getter dan setter    
}
</code></pre>

<p>kemudian menyuruh Hibernate untuk menggenerate DDL ke PostgreSQL, maka kita akan mendapatkan hasil sebagai berikut.</p>

<pre><code>create table example (id int4 not null, name varchar(255), primary key (id))
create sequence example_id_seq
</code></pre>

<p>Artinya, Hibernate akan membuat sequence bernama example_id_seq dan menggunakannya untuk menghasilkan id.</p>

<p>Skema yang dihasilkan ini berbeda dengan skema yang biasa digunakan DBA PostgreSQL dalam membuat tabel, yaitu seperti ini</p>

<pre><code>CREATE TABLE example (id serial, name text)
</code></pre>

<p>Bila kita menggunakan mapping di atas ke skema tabel dengan id bertipe serial ini, kita akan mendapatkan exception sebagai berikut.</p>

<pre><code>SEVERE: ERROR: relation "hibernate_sequence" does not exist
Exception in thread "main" org.hibernate.exception.SQLGrammarException: could not get next sequence value
Caused by: org.postgresql.util.PSQLException: ERROR: relation "hibernate_sequence" does not exist
</code></pre>

<p>Ini disebabkan karena mapping di atas akan mencari sequence bernama hibernate_sequence yang tidak ada kalau kita membuat tabel dengan id serial.</p>

<p>Solusinya adalah dengan menggunakan Hibernate Annotation Extension, yaitu anotasi @GenericGenerator seperti ini.</p>

<pre><code>@Entity @Table(name="example")
public class Example {
    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="pg_seq")
    @GenericGenerator(name="pg_seq", strategy="sequence", parameters={
        @Parameter(name="sequence", value="example_id_seq")
    })
    private Integer id;

    private String name;
}
</code></pre>

<p>Nama sequence diambil dari sequence yang dibuatkan PostgreSQL pada saat kita melakukan create table.
Nama sequence ini bisa dilihat dengan mengetikkan \d example, yang akan menghasilkan output sebagai berikut.</p>

<pre><code>\d example
                          Table "public.example"
 Column |  Type   |                       Modifiers                       
--------+---------+-------------------------------------------------------
 id     | integer | not null default nextval('example_id_seq'::regclass)
 name   | text    | 
</code></pre>

<p>Barulah setelah itu kita bisa menyimpan object ke database dengan mulus.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/integrasi-pusat-cabang-3/">Integrasi Aplikasi Kantor Pusat Dan Cabang [Bagian 3]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-16T17:56:28+07:00" pubdate data-updated="true">Jun 16<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada artikel sebelumnya, kita telah membahas tentang <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-1/">konsep integrasi aplikasi</a>, dan <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-2/">implementasinya menggunakan Spring Integration</a>. Contoh implementasi kita kemarin, walaupun mencakup integrasi end-to-end, masih sangat sederhana.</p>

<p>Kali ini kita akan mengeksplorasi use-case yang lebih kompleks, yaitu cara menangani berbagai operasi service. Misalnya untuk tipe data yang sama, contohnya Penjualan, kita memiliki service untuk simpan dan hapus. Object penjualan juga lebih kompleks daripada object produk.</p>

<p>Untuk memecahkan masalah ini, kita menggunakan Router. Router bertugas memilih channel sesuai dengan message yang datang. Berikut skema penggunaan router.</p>

<p><img src="/images/uploads/2009/06/router-demo-300x91.png" title="Skema Penggunaan Router" ></p>

<p>Sebelum membahas tentang router, baiklah kita lihat dulu data penjualan yang akan dikirim. Berikut class penjualan</p>

<h4>Penjualan</h4>

<pre><code>public class Penjualan {
    private Integer id;
    private Date tanggal = new Date();
    private List&lt;PenjualanDetail&gt; details = new ArrayList&lt;PenjualanDetail&gt;();
    // getter dan setter
}
</code></pre>

<p>Berikutnya, penjualan detail.</p>

<h4>PenjualanDetail</h4>

<pre><code>public class PenjualanDetail {
    private Integer id;
    private Penjualan penjualan;
    private Produk produk;
    private Integer jumlah;

    // getter dan setter
}
</code></pre>

<p>Object baru ini tentu saja harus kita buatkan transformernya untuk mengkonversi object menjadi JSON.</p>

<h4>CabangService</h4>

<pre><code>public class JsonTransformer{
    public Penjualan jsonToPenjualan(String json){
        Map&lt;String , Class&gt; binding = new HashMap&lt;String , Class&gt;();
        binding.put("details", PenjualanDetail.class);
        return (Penjualan) JSONObject.toBean(JSONObject.fromObject(json), Penjualan.class, binding);
    }

    public String penjualanToJson(Penjualan p){
        // remove dulu cyclic dependency
        for (PenjualanDetail detail : p.getDetails()) {
            detail.setPenjualan(null);
        }

        return JSONObject.fromObject(p).toString();
    }
}
</code></pre>

<p>Penjualan dan PenjualanDetail akan kita proses melalui method simpan dan hapus yang ada di CabangService.</p>

<h4>CabangService</h4>

<pre><code>public class CabangService {
    public void save(Penjualan p) {
        System.out.println("Simpan penjualan dengan ID : "+p.getId());
        System.out.println("Tanggal : "+new SimpleDateFormat("dd MMM yyyy").format(p.getTanggal()));
        System.out.println("Details : ");
        for (PenjualanDetail detail : p.getDetails()) {
            System.out.println("Produk : "+detail.getProduk().getKode());
            System.out.println("Jumlah : "+detail.getJumlah());
        }
    }

    public void delete(Penjualan p) {
        System.out.println("Hapus penjualan dengan ID : "+p.getId());
    }
}
</code></pre>

<p>Tentunya nanti method save dan delete ini akan lebih canggih dari ini, misalnya insert dan delete ke database.</p>

<p>Kalau kita lihat skemanya, ada satu titik di mana message akan dilihat dan disalurkan ke channel yang sesuai.</p>

<p><img src="/images/uploads/2009/06/router-only-300x104.png" title="Routing Message" ></p>

<p>Penjualan yang akan disimpan dimasukkan ke channel penjualan-simpan. Sedangkan object penjualan yang akan dihapus dimasukkan ke channel penjualan-hapus. Dengan demikian, kita harus membuat router yang mampu menentukan channel yang akan dipilih dengan melihat message yang masuk ke dalam router tersebut. Operasi yang akan dilakukan (simpan atau hapus) harus dimasukkan ke message header atau message content. Agar sederhana, kita tambahkan saja satu property di class Penjualan untuk menentukan operasi yang akan dilakukan. Bila class Penjualan ini dimapping menggunakan JPA, kita bisa menandai property ini dengan anotasi @Transient agar isinya tidak disimpan di database.</p>

<p>Karena nantinya property operasi ini akan digunakan tidak saja untuk Penjualan, tapi juga transaksi lainnya, baiklah kita buat saja di superclass DomainObject sebagai berikut.</p>

<h4>Penjualan</h4>

<pre><code>public class DomainObject {
    private String operasi;
}
</code></pre>

<p>Berikut class Penjualan yang sudah dimodifikasi.</p>

<h4>Penjualan</h4>

<pre><code>public class Penjualan extends DomainObject {
    private Integer id;
    private Date tanggal = new Date();
    private List&lt;PenjualanDetail&gt; details = new ArrayList&lt; &lt;PenjualanDetail&gt;();

    // getter dan setter
}
</code></pre>

<p>Property operasi ini akan dilihat oleh router untuk menentukan nama channel. Berikut implementasi Router.</p>

<h4>Router</h4>

<pre><code>public class NamaKelasDanOperasiRouter {
    public String pilihChannel(Object msg){
        String classname = msg.getClass().getSimpleName().toLowerCase();

        if(!DomainObject.class.isAssignableFrom(msg.getClass())) {
            throw new IllegalArgumentException("Harus object bertipe : "+DomainObject.class.getName());
        }

        DomainObject obj = (DomainObject) msg;
        String operasi = obj.getOperasi().toLowerCase();

        return classname + "-" + operasi;
    }
}
</code></pre>

<p>Router ini akan membaca nama class dari object yang diterimanya dan menggabungkannya dengan property operasi. Jadi, object Penjualan dengan operasi simpan akan menghasilkan nama channel penjualan-simpan. Demikian juga object Pembelian dengan operasi hapus akan menghasilkan channel pembelian-hapus.</p>

<p>Berikut unit test untuk router di atas.</p>

<h4>Router</h4>

<pre><code>public class NamaKelasDanOperasiRouterTest {

    @Test
    public void testPilihChannel() {
        Penjualan p = new Penjualan();
        p.setOperasi("simpan");
        assertEquals("penjualan-simpan", new NamaKelasDanOperasiRouter().pilihChannel(p));
    }

}
</code></pre>

<p>Berikut aliran message mulai dari gateway sampai menjadi JSON.</p>

<p><img src="/images/uploads/2009/06/gateway-to-json-300x31.png" title="Dari Gateway sampai menjadi JSON" ></p>

<p>Dan ini adalah konfigurasi Spring Integration untuk flow di atas.</p>

<h4>Gateway ke JSON</h4>

<pre><code>&lt;gateway id="gateway"
    service-interface="com.artivisi.explore.spring.integration.gateway.Gateway"
    default-request-channel="outgoingPenjualan"
/&gt;

&lt;channel id="outgoingPenjualan"/&gt;

&lt;transformer 
    input-channel="outgoingPenjualan" 
    output-channel="outgoingJson"
    ref="jsonTransformer" 
    method="penjualanToJson"
/&gt;

&lt;channel id="outgoingJson"/&gt;
</code></pre>

<p>Pada artikel sebelumnya, kita mengganti implementasi email dengan shared folder supaya proses development lebih cepat. Akses ke shared folder jauh lebih cepat daripada email yang dibatasi oleh kecepatan internet. Kali ini, kita akan menggunakan bridge, yaitu hubungan langsung antar channel. Ini kita gunakan untuk menghubungkan channel outgoingJson dengan incomingJson. Hubungan ini pada artikel sebelumnya diimplementasikan menggunakan shared folder dan email.</p>

<p><img src="/images/uploads/2009/06/bridge-300x45.png" title="bridge antara incoming dan outgoing" ></p>

<p>Berikut konfigurasi bridge untuk menghubungkan outgoingJson dan incomingJson.</p>

<h4>Bridge</h4>

<pre><code>&lt;bridge 
    input-channel="outgoingJson" 
    output-channel="incomingJson" 
/&gt;
</code></pre>

<p>Dari incomingJson, kita konversi dulu menjadi object.
Berikut konfigurasinya.</p>

<h4>JSON ke Object</h4>

<pre><code>&lt;channel id="incomingJson"/&gt;

&lt;transformer 
    input-channel="incomingJson" 
    output-channel="incomingPenjualan"
    ref="jsonTransformer" 
    method="jsonToPenjualan"
/&gt;
</code></pre>

<p>Setelah menjadi object, kita masukkan ke router untuk ditentukan channelnya.</p>

<h4>Routing</h4>

<pre><code>&lt;router 
    input-channel="incomingPenjualan" 
    ref="namaKelasDanOperasiRouter" 
    method="pilihChannel"
/&gt;
</code></pre>

<p>Kemudian, dari channel kita sambungkan ke method save dan delete.</p>

<h4>Method Save</h4>

<pre><code>&lt;channel id="penjualan-simpan"/&gt;

&lt;service-activator 
    input-channel="penjualan-simpan"
    ref="cabangService"
    method="save"/&gt;
</code></pre>

<h4>Method Delete</h4>

<pre><code>&lt;channel id="penjualan-hapus"/&gt;

&lt;service-activator 
    input-channel="penjualan-hapus"
    ref="cabangService"
    method="delete"/&gt;
</code></pre>

<p>Terakhir, kita buat class untuk menjalankan semua rangkaian integrasi ini.</p>

<h4>CabangRouterDemo</h4>

<pre><code>public class CabangRouterDemo {
    public static void main(String[] args) {
         // 1. Menginstankan Spring Application Context
        AbstractApplicationContext ctx 
            = new ClassPathXmlApplicationContext("cabang-router-ctx.xml", CabangRouterDemo.class);
        ctx.registerShutdownHook();
        Gateway gw = (Gateway) ctx.getBean("gateway");
        Penjualan p1 = bikinTransaksi(100, "simpan");
        Penjualan p2 = bikinTransaksi(102, "hapus");

        gw.send(p1);
        gw.send(p2);

        System.exit(0);
    }

    private static Penjualan bikinTransaksi(Integer id, String operasi) {
        Penjualan p = new Penjualan();
        p.setId(id);
        p.setOperasi(operasi);

        Produk pr1 = new Produk(1001, "PR-001", "Produk 001");
        Produk pr2 = new Produk(1002, "PR-002", "Produk 002");
        Produk pr3 = new Produk(1003, "PR-003", "Produk 003");

        PenjualanDetail pd1 = new PenjualanDetail(11, pr1, 1);
        PenjualanDetail pd2 = new PenjualanDetail(12, pr2, 2);
        PenjualanDetail pd3 = new PenjualanDetail(13, pr3, 3);

        p.addPenjualanDetail(pd1);
        p.addPenjualanDetail(pd2);
        p.addPenjualanDetail(pd3);

        return p;
    }
}
</code></pre>

<p>Demikianlah penggunaan routing dengan Spring Integration. Seperti kita lihat, dengan menggunakan Spring Integration, aplikasi kita menjadi fleksibel dan mudah ditest. Semua implementasi kode program Java, baik itu transformer, router, dan service method, bisa ditest dengan mudah menggunakan JUnit. Kita juga lihat bahwa semua kode program Java kita tidak memiliki ketergantungan terhadap Spring Integration.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/linux/simulasi-slow-network/">Simulasi Slow Network</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-15T15:21:33+07:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di salah satu proyek ArtiVisi, kita memiliki aplikasi client-server yang terhubung melalui koneksi internet berbandwidth kecil. Client menghubungi server melalui modem GPRS.</p>

<p>Permasalahannya adalah bagaimana cara mengetes koneksi lemot ini pada saat development? Umumnya pada saat development kita menjalankan server dan client di komputer yang sama. Atau kalaupun di komputer berbeda, dijalankan di satu LAN, sehingga kecepatan bisa mencapai 100Mbps.</p>

<p>Ada dua alternatif yang bisa kita gunakan. Yang pertama adalah aplikasi tc (traffic control) yang biasanya sudah terinstal secara default di Ubuntu. Kalau belum terinstal, kita bisa menginstal paket iproute atau iproute2, tergantung distro yang Anda gunakan.</p>

<p>Alternatif kedua, menggunakan aplikasi ip_relay. Aplikasi ini bisa diinstal dengan nama paket iprelay.</p>

<p>Berikut adalah referensi pemakaian tc :</p>

<ul>
<li><p><a href="http://www.kdedevelopers.org/node/1878">pipita&#8217;s blog</a></p></li>
<li><p><a href="http://henrydu.com/blog/how-to/simulate-a-slow-link-by-linux-bridge-123.html">Henry&#8217;s Point</a></p></li>
</ul>


<p>Dan ini adalah referensi pemakaian iprelay :</p>

<ul>
<li><p><a href="http://ubuntuforums.org/showthread.php?t=670628">Ubuntu Forum</a></p></li>
<li><p><a href="http://www.stewart.com.au/ip_relay/README">Readme di website ip_relay</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/integrasi-pusat-cabang-2/">Integrasi Aplikasi Kantor Pusat Dan Cabang [Bagian 2]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-12T20:43:16+07:00" pubdate data-updated="true">Jun 12<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-1/">artikel sebelumnya</a>, kita sudah mendiskusikan requirement yang diinginkan. Sekarang kita akan melakukan implementasi menggunakan <a href="http://www.springsource.org/spring-integration">Spring Integration</a>.</p>

<p>Spring Integration memiliki beberapa abstraksi utama yang perlu kita ketahui agar bisa membuat implementasi, yaitu :</p>

<ul>
<li><p>Message : ini adalah data yang akan kita kirim, proses, dan terima</p></li>
<li><p>Channel : ini adalah saluran tempat lewatnya message</p></li>
<li><p>Endpoint : ini adalah ujung dari channel</p></li>
<li><p>Transport : mekanisme pengiriman message. Spring Integration mendukung messaging (email,JMS), remoting (Web Service, RMI, HttpInvoker, HTTP), file, dan lainnya (stream)</p></li>
</ul>


<p>Ilustrasi hubungan antara message, channel, dan endpoint bisa dilihat di gambar berikut :</p>

<p><img src="/images/uploads/2009/06/msg-channel-endpoint-300x59.png" title="Hubungan Message, Channel, dan Endpoint" ></p>

<p>Message terdiri dari dua bagian utama, yaitu header dan payload (isi message).</p>

<h3>Channel</h3>

<p>Berdasarkan kemampuan menampung message, channel dibedakan menjadi :</p>

<ul>
<li><p>Pollable : memiliki buffer untuk menampung message. Dengan adanya kapasitas buffer, pengirim tidak perlu menunggu sampai penerima mendapatkan message, kecuali bila buffernya penuh. Dalam kondisi buffer penuh, pengirim akan menunggu (blocking) sampai ada slot kosong yang bisa digunakan untuk menyimpan message. Penerima dapat memeriksa keberadaan message dalam buffer. Dalam melakukan pemeriksaan, penerima dapat menunggu sampai ada message, atau sampai jangka waktu tertentu (timeout)</p></li>
<li><p>Subscribable : tidak memiliki buffer, tiap message yang masuk langsung dikirim ke endpoint. Pengirim harus menunggu sampai message diterima.</p></li>
</ul>


<p>Berdasarkan perilaku pengiriman message, channel dibedakan menjadi :</p>

<ul>
<li><p>Point to Point (PTP) : tiap message hanya dikirimkan ke satu penerima saja. Walaupun ada beberapa penerima yang terhubung ke channel PTP, tapi hanya salah satu saja yang akan menerima message</p></li>
<li><p>Point to Multipoint (PTM) : tiap message akan dikirim ke semua penerima yang terdaftar.</p></li>
</ul>


<p>Ada beberapa implementasi channel :</p>

<ul>
<li><p>Direct Channel : subscribable dan point-to-point. Seluruh proses (kirim, masuk channel, terima) akan dilakukan dalam thread yang sama</p></li>
<li><p>Queue Channel : pollable dan point to point. Message yang datang duluan akan dikirim duluan juga (FIFO)</p></li>
<li><p>Priority Channel : mirip dengan Queue Channel, tapi tidak menggunakan FIFO, melainkan melihat field Priority di Message Header untuk menentukan mana message yang harus dikirim terlebih dulu</p></li>
<li><p>Rendezvous Channel : mirip dengan Direct Channel, tapi pengirim dan penerima menggunakan thread yang berbeda. Pengirim akan menunggu sampai message diterima atau sampai timeout. Atau sebaliknya, penerima akan menunggu sampai ada message yang masuk. Biasanya digunakan untuk mengimplementasikan request-reply.</p></li>
<li><p>ThreadLocal Channel : pollable dan point-to-point. Message disimpan di thread local, sehingga tidak disharing dengan thread yang berbeda.</p></li>
<li><p>Publish Subscribe Channel : subscribable dan point-to-multipoint. Setiap penerima yang terdaftar akan menerima message. Tidak bisa menyimpan message, sehingga kalau kita butuh buffer, kita harus merangkainya dengan channel jenis lain yang memiliki buffer.</p></li>
</ul>


<h3>Endpoint</h3>

<p>Endpoint digunakan untuk menghubungkan channel. Pemrosesan message dilakukan dalam endpoint. Ada beberapa jenis endpoint, yaitu:</p>

<ul>
<li><p>Service Activator : kalau kita ingin memanggil business method kita, gunakan endpoint ini.</p></li>
<li><p>Channel Adapter : ini adalah penghubung channel dengan transport, baik untuk menerima message (inbound) ataupun mengirim message (outbound).</p></li>
<li><p>Transformer : digunakan untuk mengubah format message</p></li>
<li><p>Filter : digunakan untuk memutuskan apakah suatu message akan diterima atau dibuang</p></li>
<li><p>Router : digunakan untuk memilih channel mana yang akan menerima message</p></li>
<li><p>Splitter : digunakan untuk memecah message menjadi beberapa bagian untuk diproses secara independen</p></li>
<li><p>Aggregator : digunakan untuk menggabungkan beberapa message menjadi satu message untuk diteruskan ke channel berikutnya</p></li>
<li><p>Resequencer : digunakan untuk menyusun urutan message</p></li>
</ul>


<h3>Implementasi Kantor Pusat</h3>

<p>Sekarang, setelah kita memahami berbagai istilah dalam Spring Integration, kita bisa merancang implementasi dari requirement kita. Berikut adalah aliran message di sisi kantor pusat. Kantor pusat mengirim beberapa data produk baru, dan akan dikonversi menjadi JSON.</p>

<p><img src="/images/uploads/2009/06/pusat-json-300x24.png" title="Flow konversi data menjadi JSON" ></p>

<p>Setelah menjadi JSON, selanjutnya kita bisa kirim melalui berbagai transport yang disediakan. Untuk tahap development, kita kirim saja melalui file ke folder /tmp, supaya mudah didebug dan tidak butuh internet.</p>

<p><img src="/images/uploads/2009/06/json-file-300x56.png" title="Flow message JSON ke shared folder" ></p>

<p>Selanjutnya, setelah transport melalui file sudah dipastikan benar, baik format data, isi data, maupun rangkaian filternya, kita bisa mengganti channel adapter untuk mengirim ke GMail.</p>

<p><img src="/images/uploads/2009/06/json-email-300x35.png" title="Flow message JSON ke Email" ></p>

<p>Kita harus membuat beberapa file sebagai berikut :</p>

<ul>
<li><p>Produk.java : domain model dari data yang akan kita kirim</p></li>
<li><p>JsonTransformer.java : kode program untuk mengubah object Produk menjadi JSON</p></li>
<li><p>JsonTransformerTest.java : kode program untuk mengetes ProdukTransformer</p></li>
<li><p>PusatSender.java : kode program untuk mengaktifkan Spring Integration dan mengirim data produk</p></li>
<li><p>Gateway.java : interface untuk mengirim message. Kita harus membuat ini agar tidak ada dependensi ke library Spring Integration</p></li>
<li><p>pusat-integration-ctx.xml : konfigurasi Spring Integration</p></li>
</ul>


<p>Berikut kode programnya.</p>

<h4>Produk.java</h4>

<pre><code>public class Produk implements Serializable {
    private Integer id;
    private String kode;
    private String nama;

    // getter dan setter generate dengan IDE
}
</code></pre>

<h4>JsonTransformer.java</h4>

<pre><code>public class JsonTransformer {
    public Produk jsonToProduk(String json){
        return (Produk) JSONObject.toBean(JSONObject.fromObject(json), Produk.class);
    }

    public String produkToJson(Produk p){
        return JSONObject.fromObject(p).toString();
    }
}
</code></pre>

<h4>JsonTransformerTest.java</h4>

<pre><code>public class JsonTransformerTest {

    @Test
    public void testJsonToProduk() {
        Produk p = new JsonTransformer()
                    .jsonToProduk("{\"id\":99,\"kode\":\"T-001\",\"nama\":\"Produk Test\"}");
        assertEquals(new Integer(99), p.getId());
        assertEquals("T-001", p.getKode());
        assertEquals("Produk Test", p.getNama());
    }

    @Test
    public void testProdukToJson() {
        Produk p = new Produk();
        p.setId(99);
        p.setKode("T-001");
        p.setNama("Produk Test");

        assertEquals("{\"id\":99,\"kode\":\"T-001\",\"nama\":\"Produk Test\"}",
                new JsonTransformer().produkToJson(p));
    }
}
</code></pre>

<h4>PusatSender.java</h4>

<pre><code>public class PusatSender {
    public static void main(String[] args) {
        // 1. Menginstankan Spring Application Context
        AbstractApplicationContext ctx 
            = new ClassPathXmlApplicationContext("pusat-integration-ctx.xml", Gateway.class);
        ctx.registerShutdownHook();
        Gateway gw = (Gateway) ctx.getBean("gateway");

        // 2. Kirim produk ke gateway
        int jumlahProduk = 5;
        for (int i = 0; i &lt; jumlahProduk; i++) {
            Produk p = new Produk();
            p.setId(i);
            p.setKode("PRD-00"+i);
            p.setNama("Produk "+i);
            gw.send(p);
            System.out.println("Kirim produk "+i);
        }
        System.out.println("Produk terkirim");
        System.exit(0);
    }
}
</code></pre>

<h4>Gateway.java</h4>

<pre><code>public interface Gateway {
    public void send(Produk p);
}
</code></pre>

<h4>pusat-integration-ctx.xml</h4>

<pre><code>&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:beans="http://www.springframework.org/schema/beans"
       xmlns:file="http://www.springframework.org/schema/integration/file"
       xmlns:mail="http://www.springframework.org/schema/integration/mail"
       xmlns:transformer="http://www.springframework.org/schema/integration/transformer"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
           http://www.springframework.org/schema/integration/file
           http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd
           http://www.springframework.org/schema/integration/mail
           http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd
           http://www.springframework.org/schema/integration/stream
           http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd
           http://www.springframework.org/schema/integration/transformer
           http://www.springframework.org/schema/integration/transformer/spring-integration-transformer-1.0.xsd"&gt;


    &lt;gateway id="gateway"
                service-interface="com.artivisi.explore.spring.integration.pusat.Gateway"
                default-request-channel="outgoingProduk"/&gt;

    &lt;channel id="outgoingProduk" /&gt;

    &lt;transformer input-channel="outgoingProduk" output-channel="outgoingJson"
    ref="jsonTransformer" method="produkToJson"/&gt;

    &lt;publish-subscribe-channel id="outgoingJson" /&gt;

    &lt;file:outbound-channel-adapter channel="outgoingJson" directory="/tmp"/&gt;

    &lt;mail:header-enricher
        id="mailHeaderEnricher"
        subject="Spring Integration Demo"
        to="cabang@gmail.com"
        from="pusat@gmail.com"
        reply-to="pusat@gmail.com"
        overwrite="false"
        input-channel="outgoingJson"
        output-channel="outgoingEmail"/&gt;

    &lt;channel id="outgoingEmail" /&gt;

    &lt;mail:outbound-channel-adapter
        mail-sender="mailSender"
        channel="outgoingEmail"
        /&gt;

    &lt;beans:bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
        &lt;beans:property name="defaultEncoding" value="UTF-8"/&gt;
        &lt;beans:property name="host" value="smtp.gmail.com"/&gt;
        &lt;beans:property name="port" value="465"/&gt;
        &lt;beans:property name="username" value="mygmailaccount"/&gt;
        &lt;beans:property name="password" value="mygmailpassword"/&gt;
        &lt;beans:property name="javaMailProperties"&gt;
            &lt;beans:value&gt;
                mail.debug=true
                mail.smtp.starttls.enable=true
                mail.smtp.auth=true
                mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
                mail.smtp.socketFactory.fallback=false
            &lt;/beans:value&gt;
        &lt;/beans:property&gt;
    &lt;/beans:bean&gt;

    &lt;beans:bean id="jsonTransformer" class="com.artivisi.explore.spring.integration.model.JsonTransformer"/&gt;
&lt;/beans:beans&gt;
</code></pre>

<h3>Implementasi Kantor Cabang</h3>

<p>Di sisi kantor cabang, berikut aliran message dari transport hingga menjadi JSON. Kita mulai dengan transport file.</p>

<p><img src="/images/uploads/2009/06/file-json-300x35.png" title="Flow dari shared folder menjadi JSON" ></p>

<p>Bila kita menggunakan email, berikut gambarnya</p>

<p><img src="/images/uploads/2009/06/email-json-300x35.png" title="Flow dari Email menjadi JSON" ></p>

<p>Setelah menjadi JSON, kita proses sampai ke CabangService</p>

<p><img src="/images/uploads/2009/06/json-cabang-300x25.png" title="Flow pemrosesan JSON menjadi Produk" ></p>

<p>Kita harus membuat beberapa file sebagai berikut :</p>

<ul>
<li><p>CabangReceiver.java : kode program untuk mengaktifkan Spring Integration</p></li>
<li><p>CabangService.java : kode program yang akan dipanggil setelah message diterima, dikonversi dari JSON menjadi Produk</p></li>
<li><p>cabang-integration-ctx.xml : konfigurasi Spring Integration</p></li>
</ul>


<p>Kode programnya.</p>

<h4>CabangReceiver.java</h4>

<pre><code>public class CabangReceiver {
    public static void main(String[] args) {
        AbstractApplicationContext ctx 
                = new ClassPathXmlApplicationContext("cabang-integration-ctx.xml", CabangReceiver.class);
        ctx.registerShutdownHook();
    }
}
</code></pre>

<h4>CabangService.java</h4>

<pre><code>public class CabangService {
    public void terimaProduk(Produk p){
        // Tampilkan data produk, tapi bisa juga disimpan di database
        System.out.println("Terima produk");
        System.out.println("ID : "+p.getId());
        System.out.println("Kode : "+p.getKode());
        System.out.println("Nama : "+p.getNama());
    }
}
</code></pre>

<h4>cabang-integration-ctx.xml</h4>

<pre><code>&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:beans="http://www.springframework.org/schema/beans"
       xmlns:file="http://www.springframework.org/schema/integration/file"
       xmlns:mail="http://www.springframework.org/schema/integration/mail"
       xmlns:transformer="http://www.springframework.org/schema/integration/transformer"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
           http://www.springframework.org/schema/integration/stream
           http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd
           http://www.springframework.org/schema/integration/file
           http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd
           http://www.springframework.org/schema/integration/mail
           http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd
           http://www.springframework.org/schema/integration/transformer
           http://www.springframework.org/schema/integration/transformer/spring-integration-transformer-1.0.xsd"&gt;


    &lt;file:inbound-channel-adapter id="filePoller"
       directory="/tmp"
       filename-pattern="^.*\.msg$"
       channel="incomingFile"/&gt;

    &lt;channel id="incomingFile" /&gt;

    &lt;file:file-to-string-transformer
       input-channel="incomingFile"
       output-channel="incomingJson"
       delete-files="true" /&gt;

    &lt;channel id="incomingJson" /&gt;

    &lt;transformer input-channel="incomingJson" output-channel="incomingProduk"
    ref="jsonTransformer" method="jsonToProduk"/&gt;

    &lt;channel id="incomingProduk" /&gt;

    &lt;service-activator input-channel="incomingProduk"
                      ref="cabangService"
                      method="terimaProduk"/&gt;

    &lt;poller id="defaultPoller" default="true"&gt;
        &lt;interval-trigger interval="3" time-unit="SECONDS"/&gt;
    &lt;/poller&gt;


    &lt;beans:bean id="jsonTransformer" class="com.artivisi.explore.spring.integration.model.JsonTransformer"/&gt;
    &lt;beans:bean id="cabangService" class="com.artivisi.explore.spring.integration.cabang.CabangService"/&gt;
&lt;/beans:beans&gt;
</code></pre>

<p>Untuk menerima email, kita dapat memilih protokol POP3, IMAP, atau IMAP-Idle. POP3 dan IMAP akan mendownload semua email yang masuk, setelah itu, kita harus melakukan polling dengan interval tertentu untuk memeriksa apakah ada email baru. Bila kita menggunakan IMAP-Idle, kita tidak perlu melakukan polling. Mail server akan memberikan notifikasi bila ada email baru yang masuk, setelah itu kita bisa mendownloadnya.</p>

<p>Berikut konfigurasi untuk GMail</p>

<h4>Debug Output</h4>

<pre><code>    &lt;beans:bean id="javaMailProperty" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
        &lt;beans:property name="properties"&gt;
            &lt;beans:value&gt;
                mail.debug=true
            &lt;/beans:value&gt;
        &lt;/beans:property&gt;
    &lt;/beans:bean&gt;
</code></pre>

<h4>POP3</h4>

<pre><code>    &lt;mail:inbound-channel-adapter
    channel="incomingMail"
    store-uri="pop3s://mygmailaccount:mygmailpassword@pop.gmail.com:995/INBOX"
    java-mail-properties="javaMailProperty"/&gt;
</code></pre>

<h4>IMAP</h4>

<pre><code>    &lt;mail:inbound-channel-adapter
    channel="incomingMail"
    store-uri="imaps://mygmailaccount:mygmailpassword@imap.gmail.com:993/INBOX" /&gt;
</code></pre>

<h4>IMAP-Idle</h4>

<pre><code>    &lt;mail:imap-idle-channel-adapter channel="incomingMail"
    store-uri="imaps://mygmailaccount:mygmailpassword@imap.gmail.com:993/INBOX"/&gt;
</code></pre>

<p>Setelah email masuk, jangan lupa konversi dulu jadi String.</p>

<pre><code>    &lt;channel id="incomingMail" /&gt;

    &lt;mail:mail-to-string-transformer 
    input-channel="incomingMail" 
    output-channel="incomingJson"/&gt;
</code></pre>

<p>Demikianlah tutorial penggunaan Spring Integration. Dengan menggunakan Spring Integration ini, ada beberapa benefit yang kita dapatkan dibandingkan coding sendiri :</p>

<ul>
<li><p>Kode program lebih sedikit</p></li>
<li><p>Kode program lebih mudah ditest. Kita bisa menggunakan JUnit untuk JsonTransformer. Alur pengiriman data juga bisa ditest di komputer lokal tanpa koneksi ke GMail, sehingga kalau ada error bisa diperbaiki dengan lebih cepat.</p></li>
<li><p>Aliran data lebih mudah dibaca, yaitu dalam konfigurasi Spring Integration</p></li>
<li><p>Fleksibilitas dalam pemilihan transport. Bukan cuma email, tapi juga banyak opsi lain seperti remoting dan file. Opsi ini cuma butuh beberapa baris konfigurasi saja untuk mengaktifkannya.</p></li>
</ul>


<p>Konsumsi effort :</p>

<ul>
<li><p>Download : 1 jam</p></li>
<li><p>Browsing tutorial : 2 jam</p></li>
<li><p>Mempelajari Spring Integration : 8 jam</p></li>
<li><p>Membuat sample aplikasi : 4 jam</p></li>
<li><p>Menulis blog dan membuat gambar : 8 jam</p></li>
<li><p><strong>Total : 23 jam (3 hari)</strong></p></li>
</ul>


<p>Apakah dalam 3 hari kita bisa membuat implementasi kirim-terima data produk via email yang bebas bug ??</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/10/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
    <a class="next" href="/page/8/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Endy Muhardin</h1>

<p>Software Developer berdomisili di Jabodetabek, berkutat di lingkungan open source, terutama Java dan Linux.</p>

<p>
    <ul>
        <li>
            <span class="icon-phone" style="text-align: left; width: 100%">&nbsp;
            +62 812 98000 468
            </span>
        </li>
        <li>
            <span class="icon-envelope" style="text-align: left; width: 100%">&nbsp;
                <a href="mailto:endy.muhardin@gmail.com">endy.muhardin@gmail.com</a>
            </span>
        </li>
        <li>
            <span class="icon-twitter" style="text-align: left; width: 100%">&nbsp;
                <a href="http://twitter.com/endymuhardin">@endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-github" style="text-align: left; width: 100%">&nbsp;
                <a href="https://github.com/endymuhardin">github.com/endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-facebook" style="text-align: left; width: 100%">&nbsp;
                <a href="http://facebook.com/endy.muhardin">facebook.com/endy.muhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-google-plus" style="text-align: left; width: 100%">&nbsp;
                <a href="http://google.com/+EndyMuhardin">google.com/+EndyMuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-linkedin" style="text-align: left; width: 100%">&nbsp;
                <a href="http://id.linkedin.com/pub/endy-muhardin/3/940/1bb">LinkedIn</a>
            </span>
        </li>
    </ul>
</p>
</section>

<section>

Bila artikel di website ini membantu meningkatkan penghasilan Anda, 
jangan ragu untuk memberikan donasi :)

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYByjmBHWB1u9oWkn33FHJ7Lu41iidZkdKLciblvSz2Oa/oBArw42F4/7nq3imMAWUvpA6Cx9zwNr3R7WqjnMlDr91VTkeyl1jusRB6Knw/JAaNI2yz20lbFtVNMhUrh2LJ6qXUwvdL4jvZeNUeOcvq/muETfy8BzgdKwCF3gNGpoTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQId7q7vUD8KwOAgaAyBdpVvmsdYWgKdVROwaJazFrOpQpWEncNGoycnyfeJRNwHXXZU1mj0oTJuvj/CUGr6cZC5RnQNBHC6FLnbjCVheTNtjBSs/CjD7HZMn28kElykLad2wDrFUsBkQCdRU43ZBLoRedRKbGVWP4wk6DgLovkwPzYNLKtl3clJbgm3UDXigmJqeAyvmafF2yk8LV4ACLTJtCu6qtSBVHkuUPToIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTMwNzExMDY0MjAwWjAjBgkqhkiG9w0BCQQxFgQUwzp1u86AW3VypUoSwjzfYA4KYn8wDQYJKoZIhvcNAQEBBQAEgYBExEV1zgHTrd+4zfXwIP0KO0/W7b4s2KDLbZ3Vq9FrtdtC9W3NEf6SbVZDYE+bEheP10XokfC8BslN7nZgsfPTvSNXv7ixfpWUVBb/gQB+QO70q1NZ2tuF2M/t1QzFUEZ9FeA0sgFMBS7nxmu7ynaSzez3B4FTG/jUzuRljVWhew==-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
</form>

</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/manajemen/belajar-project-management-dari-ubuntu/">Belajar Project Management dari Ubuntu</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/capacity-planning/">Capacity Planning</a>
      </li>
    
      <li class="post">
        <a href="/java/memahami-authentication/">Memahami Authentication</a>
      </li>
    
      <li class="post">
        <a href="/java/desain-skema-database/">Desain Skema Database</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/tahapan-membuat-aplikasi/">Tahapan Membuat Aplikasi</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/aplikasi-prakarya-vs-aplikasi-production/">Aplikasi Prakarya vs Aplikasi Production</a>
      </li>
    
      <li class="post">
        <a href="/java/membuat-subreport-jasper-dalam-springmvc/">Membuat subreport Jasper dalam SpringMVC</a>
      </li>
    
      <li class="post">
        <a href="/linux/cara-mengetahui-ip-address-dari-mac-address/">Cara Mengetahui IP Address dari MAC Address</a>
      </li>
    
      <li class="post">
        <a href="/life/menjadi-mahasiswa-hi-tech/">Menjadi Mahasiswa Hi-Tech</a>
      </li>
    
      <li class="post">
        <a href="/java/silabus-kuliah-pemrograman/">Silabus Kuliah Pemrograman</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
