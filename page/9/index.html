
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Di mana kita harus menyimpan log output aplikasi kita? Tentunya kita ingin menggunakan lokasi yang dinamis sesuai dengan lokasi deployment. Misalnya &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://software.endy.muhardin.com/page/9/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36102948-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:software.endy.muhardin.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="my_site_title">
            Living life and make it better
        </span>
       
           <span class="my_site_subtitle">
             life, learn, contribute
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/calendar">Calendar</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/log4j-spring-mvc/">Konfigurasi Lokasi Logfile Pada Spring MVC</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-15T19:38:18+07:00" pubdate data-updated="true">Jul 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di mana kita harus menyimpan log output aplikasi kita? Tentunya kita ingin menggunakan lokasi yang dinamis sesuai dengan lokasi deployment. Misalnya, di Windows kita mungkin mendeploy aplikasi kita di</p>

<pre><code>C:\Program Files\Apache Tomcat\webapps\aplikasi-saya
</code></pre>

<p>Sedangkan di Linux, kita mendeploy aplikasi di</p>

<pre><code>/opt/apache-tomcat/webapps/aplikasi-saya
</code></pre>

<p>Dengan kemungkinan seperti di atas, bagaimana kita harus menulis konfigurasi log4j?
Mudah, bila kita menggunakan Spring MVC.</p>

<p>Kita bisa menggunakan <code>Log4jConfigListener</code> yang disediakan Spring. Class ini memungkinkan kita menggunakan variabel di konfigurasi log4j kita. Kita mendaftarkan class ini di dalam <code>web.xml</code>, sebelum <code>ContextLoaderListener</code>, seperti ini :</p>

<pre><code>    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>

<p>Dengan adanya <code>Log4jConfigListener</code> ini, kita bisa menyebutkan lokasi konfigurasi log4j seperti ini :</p>

<pre><code>    &lt;context-param&gt;
        &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:artivisi-log4j.properties&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>

<p>Isi <code>artivisi-log4j.properties</code> terlihat seperti ini :</p>

<pre><code># Konfigurasi kategori
log4j.rootLogger=INFO,fileout

# File output
log4j.appender.fileout=org.apache.log4j.DailyRollingFileAppender
log4j.appender.fileout.file=${webapp.root.path}/WEB-INF/logs/application.log
log4j.appender.fileout.datePattern='.'yyyy-MM-dd
log4j.appender.fileout.layout=org.apache.log4j.PatternLayout
log4j.appender.fileout.layout.conversionPattern=%d [%t] %p (%F:%L) ­ %m%n
</code></pre>

<p>Perhatikan konfigurasi <code>log4j.appender.fileout.file</code>. Kita menggunakan variabel <code>${webapp.root.path}</code> yang akan diisi dengan nilai lokasi deployment aplikasi web kita. Variabel <code>${webapp.root.path}</code> ini didefinisikan dalam web.xml sebagai berikut :</p>

<pre><code>    &lt;context-param&gt;
        &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;
        &lt;param-value&gt;webapp.root.path&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>

<p>Dengan konfigurasi ini, kita dapat meletakkan log output kita di</p>

<pre><code>C:\Program Files\Apache Tomcat\webapps\aplikasi-saya\WEB-INF\logs\application.log
</code></pre>

<p>bila kita mendeploy di Windows, dan di</p>

<pre><code>/opt/apache-tomcat/webapps/aplikasi-saya/WEB-INF/logs/application.log
</code></pre>

<p>bila kita deploy di Linux.</p>

<p>Konfigurasi di atas bisa disederhanakan lagi bila kita mengikuti nilai default yang disediakan Spring, yaitu cukup seperti ini dalam <code>web.xml</code> :</p>

<pre><code>    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>

<p>Kemudian memberi nama file konfigurasi logger kita <code>log4j.properties</code> yang berada di top level dalam classpath, dan berisi seperti ini :</p>

<pre><code># Konfigurasi kategori
log4j.rootLogger=INFO,fileout

# File output
log4j.appender.fileout=org.apache.log4j.DailyRollingFileAppender
log4j.appender.fileout.file=${webapp.root}/WEB-INF/logs/application.log
log4j.appender.fileout.datePattern='.'yyyy-MM-dd
log4j.appender.fileout.layout=org.apache.log4j.PatternLayout
log4j.appender.fileout.layout.conversionPattern=%d [%t] %p (%F:%L) ­ %m%n
</code></pre>

<p>Nilai variabel <code>${webapp.root}</code> secara default akan diisi dengan lokasi deployment tanpa harus mengkonfigurasi <code>webAppRootKey</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/spring-httpinvoker-sun-jre6-httpserver/">Menjalankan Spring HTTP Invoker Di Sun JRE 6 HTTP Server</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-03T21:41:28+07:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Dulu, kita sudah mencoba untuk <a href="http://endy.artivisi.com/blog/java/remoting-dengan-spring/">membuat remoting service dengan menggunakan Spring Framework</a>. Salah satu protokol yang digunakan adalah Spring HTTP Invoker. Untuk mempublish service dengan protokol ini, kita harus menggunakan servlet engine, misalnya Tomcat.</p>

<p>Akan tetapi, Sun Microsystem merilis Java versi 6 yang sudah dilengkapi dengan HTTP Server sederhana. Dengan memanfaatkan fitur ini, kita tidak perlu lagi menggunakan Tomcat hanya untuk mempublish service dengan HTTP Invoker. Ini akan sangat bermanfaat untuk aplikasi kecil yang ingin dipanggil oleh aplikasi lain.</p>

<p>Pada artikel ini, kita akan mempublish service dengan protokol HTTP Invoker pada HTTP Server yang disediakan oleh Sun JRE versi 6.</p>

<p>Di Netbeans, kita akan membuat tiga project, yaitu</p>

<ul>
<li><p>remoting-shared : project ini menampung interface RemotingService, yang akan digunakan di client dan server</p></li>
<li><p>remoting-server : project ini yang akan mempublish service. Implementasi RemotingService juga ada di sini</p></li>
<li><p>remoting-client : project ini yang akan mengakses service yang dipublish remoting-server</p></li>
</ul>


<p>Berikut screenshot Netbeans. Project remoting-server dan remoting-client memiliki dependensi terhadap remoting-shared.</p>

<p>Pertama, mari kita lihat dulu service interfacenya. Berikut adalah kode programnya.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.service.api;

public interface RemotingService {
    public String halo(String nama);
}
</code></pre>

<p>Kode program ini berada di project remoting-shared.</p>

<p>Berikutnya, kita lihat dulu di sisi client. Kita cuma butuh satu class untuk menjalankan aplikasi, yaitu ClientLauncher sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.client;

public class ClientLauncher {
    private static final Logger log = Logger.getLogger(ClientLauncher.class.getName());
    public static void main(String[] args) {
        AbstractApplicationContext ctx = 
                new ClassPathXmlApplicationContext("client-ctx.xml", ClientLauncher.class);
        ctx.registerShutdownHook();

        RemotingService service = (RemotingService) ctx.getBean("remotingService");

        String msg = service.halo("endy");

        log.info("Pesan dari server : "+msg);
    }
}
</code></pre>

<p>ClientLauncher akan membaca client-ctx.xml yang isinya seperti ini.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;!--  proxy dengan protokol HTTP Invoker  --&gt;
    &lt;bean id="remotingService"
    class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
         &lt;property name="serviceUrl" 
         value="http://localhost:9090/RemotingService"/&gt;

         &lt;property name="serviceInterface"
         value="com.artivisi.tutorial.remoting.spring.service.api.RemotingService"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>Seperti kita lihat di atas, client mengakses service yang ada di komputer lokal (localhost) di port 9090, dengan nama service RemotingService.</p>

<p>Selanjutnya, mari kita implement project remoting-server. Di sini ada implementasi RemotingService sebagai berikut</p>

<pre><code>/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package com.artivisi.tutorial.remoting.spring.service.impl;

@Service("remotingService")
public class RemotingServiceImpl implements RemotingService {
    Logger log = Logger.getLogger(RemotingServiceImpl.class.getName());

    public String halo(String nama) {
        log.info("Terima dari client : "+nama);
        return "Halo, "+nama;
    }

}
</code></pre>

<p>Kemudian ada class untuk menjalankan aplikasi di sisi server. Berikut ServerLauncher.</p>

<pre><code>package com.artivisi.tutorial.remoting.spring.server;

public class ServerLauncher {
    public static void main(String[] args) {
        AbstractApplicationContext ctx =
                new ClassPathXmlApplicationContext("server-ctx.xml", ServerLauncher.class);
        ctx.registerShutdownHook();
    }
}
</code></pre>

<p>ServerLauncher membaca file konfigurasi server-ctx.xml. Inilah isinya.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;!-- menginstankan Sun HttpServer dalam JRE 6 --&gt;
    &lt;bean class="org.springframework.remoting.support.SimpleHttpServerFactoryBean"&gt;
        &lt;property name="contexts"&gt;
            &lt;map&gt;
                &lt;entry key="/RemotingService" value-ref="remotingServiceHttpInvoker"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="port" value="9090" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>

<p>Pada blok konfigurasi pertama, kita menginstankan Sun HttpServer yang ada di JRE 6. HttpServer ini akan berjalan di port 9090, sesuai dengan yang kita konfigurasi di sisi client. Di sana terlihat bahwa URL /RemotingService akan ditangani oleh remotingServiceHttpInvoker. Berikut konfigurasinya</p>

<pre><code>    &lt;!--  publish service dengan protokol HttpInvoker  --&gt;
    &lt;bean id="remotingServiceHttpInvoker" 
          class="org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"
          p:service-ref="remotingService"
          p:serviceInterface="com.artivisi.tutorial.remoting.spring.service.api.RemotingService"
     /&gt;
</code></pre>

<p>Selanjutnya, kita suruh Spring mendeteksi implementasi service kita secara otomatis, yaitu class yang ada anotasi @Service.</p>

<pre><code>     &lt;context:component-scan base-package="com.artivisi"/&gt;
</code></pre>

<p>Berikut adalah dependensi pustaka di project client.</p>

<p><img src="/images/uploads/2009/07/remoting-library-client-300x220.png" title="Library untuk Project Client" ></p>

<p>Dan ini untuk di server.</p>

<p><img src="/images/uploads/2009/07/remoting-library-server-300x234.png" title="Library untuk Project Server" ></p>

<p>Keseluruhan project akan terlihat seperti ini.</p>

<p><img src="/images/uploads/2009/07/remoting-folder-structure-231x300.png" title="Struktur Folder semua Project" ></p>

<p>Semua library dapat diambil dari <a href="http://www.springsource.org/download">distribusi Spring Framework</a> dan <a href="http://www.springsource.com/repository/app/">Repository SpringSource</a>.</p>

<p>Coba jalankan ServerLauncher, kita akan melihat log seperti ini.</p>

<pre><code>Jul 3, 2009 2:57:25 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@be2358: display name [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]; startup date [Fri Jul 03 14:57:25 WIT 2009]; root of context hierarchy
Jul 3, 2009 2:57:26 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [server-ctx.xml]
Jul 3, 2009 2:57:26 PM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactory
INFO: Bean factory for application context [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]: org.springframework.beans.factory.support.DefaultListableBeanFactory@f11404
Jul 3, 2009 2:57:26 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@f11404: defining beans [org.springframework.remoting.support.SimpleHttpServerFactoryBean#0,remotingServiceHttpInvoker,remotingService,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor]; root of factory hierarchy
Jul 3, 2009 2:57:27 PM org.springframework.remoting.support.SimpleHttpServerFactoryBean afterPropertiesSet
INFO: Starting HttpServer at address 0.0.0.0/0.0.0.0:9090
</code></pre>

<p>Lalu jalankan ClientLauncher, inilah log yang muncul.</p>

<pre><code>Jul 3, 2009 2:58:12 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@be2358: display name [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]; startup date [Fri Jul 03 14:58:12 WIT 2009]; root of context hierarchy
Jul 3, 2009 2:58:12 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [client-ctx.xml]
Jul 3, 2009 2:58:13 PM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactory
INFO: Bean factory for application context [org.springframework.context.support.ClassPathXmlApplicationContext@be2358]: org.springframework.beans.factory.support.DefaultListableBeanFactory@d2906a
Jul 3, 2009 2:58:13 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@d2906a: defining beans [remotingService]; root of factory hierarchy
Jul 3, 2009 2:58:13 PM com.artivisi.tutorial.remoting.spring.client.ClientLauncher main
INFO: Pesan dari server : Halo, endy
</code></pre>

<p>Setelah ClientLauncher dijalankan, di log server akan muncul informasi sebagai berikut.</p>

<pre><code>INFO: Terima dari client : endy
</code></pre>

<p>Demikianlah cara menggunakan embedded HttpServer. Selamat mencoba.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/postgresql-sequence-hibernate/">PostgreSQL Sequence Dengan Hibernate</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-22T22:08:58+07:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Menggunakan PostgreSQL Sequence dengan Hibernate</p>

<p>Pada artikel ini, kita akan membahas tentang bagaimana membuat Hibernate menggunakan sequence yang dibuat PostgreSQL.</p>

<p>Bila kita membuat Hibernate mapping untuk entity class sebagai berikut:</p>

<pre><code>@Entity @Table(name="example")
public class Example {
    @Id @GeneratedValue
    private Integer id;

    private String name;

    // getter dan setter    
}
</code></pre>

<p>kemudian menyuruh Hibernate untuk menggenerate DDL ke PostgreSQL, maka kita akan mendapatkan hasil sebagai berikut.</p>

<pre><code>create table example (id int4 not null, name varchar(255), primary key (id))
create sequence example_id_seq
</code></pre>

<p>Artinya, Hibernate akan membuat sequence bernama example_id_seq dan menggunakannya untuk menghasilkan id.</p>

<p>Skema yang dihasilkan ini berbeda dengan skema yang biasa digunakan DBA PostgreSQL dalam membuat tabel, yaitu seperti ini</p>

<pre><code>CREATE TABLE example (id serial, name text)
</code></pre>

<p>Bila kita menggunakan mapping di atas ke skema tabel dengan id bertipe serial ini, kita akan mendapatkan exception sebagai berikut.</p>

<pre><code>SEVERE: ERROR: relation "hibernate_sequence" does not exist
Exception in thread "main" org.hibernate.exception.SQLGrammarException: could not get next sequence value
Caused by: org.postgresql.util.PSQLException: ERROR: relation "hibernate_sequence" does not exist
</code></pre>

<p>Ini disebabkan karena mapping di atas akan mencari sequence bernama hibernate_sequence yang tidak ada kalau kita membuat tabel dengan id serial.</p>

<p>Solusinya adalah dengan menggunakan Hibernate Annotation Extension, yaitu anotasi @GenericGenerator seperti ini.</p>

<pre><code>@Entity @Table(name="example")
public class Example {
    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="pg_seq")
    @GenericGenerator(name="pg_seq", strategy="sequence", parameters={
        @Parameter(name="sequence", value="example_id_seq")
    })
    private Integer id;

    private String name;
}
</code></pre>

<p>Nama sequence diambil dari sequence yang dibuatkan PostgreSQL pada saat kita melakukan create table.
Nama sequence ini bisa dilihat dengan mengetikkan \d example, yang akan menghasilkan output sebagai berikut.</p>

<pre><code>\d example
                          Table "public.example"
 Column |  Type   |                       Modifiers                       
--------+---------+-------------------------------------------------------
 id     | integer | not null default nextval('example_id_seq'::regclass)
 name   | text    | 
</code></pre>

<p>Barulah setelah itu kita bisa menyimpan object ke database dengan mulus.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/integrasi-pusat-cabang-3/">Integrasi Aplikasi Kantor Pusat Dan Cabang [Bagian 3]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-16T17:56:28+07:00" pubdate data-updated="true">Jun 16<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada artikel sebelumnya, kita telah membahas tentang <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-1/">konsep integrasi aplikasi</a>, dan <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-2/">implementasinya menggunakan Spring Integration</a>. Contoh implementasi kita kemarin, walaupun mencakup integrasi end-to-end, masih sangat sederhana.</p>

<p>Kali ini kita akan mengeksplorasi use-case yang lebih kompleks, yaitu cara menangani berbagai operasi service. Misalnya untuk tipe data yang sama, contohnya Penjualan, kita memiliki service untuk simpan dan hapus. Object penjualan juga lebih kompleks daripada object produk.</p>

<p>Untuk memecahkan masalah ini, kita menggunakan Router. Router bertugas memilih channel sesuai dengan message yang datang. Berikut skema penggunaan router.</p>

<p><img src="/images/uploads/2009/06/router-demo-300x91.png" title="Skema Penggunaan Router" ></p>

<p>Sebelum membahas tentang router, baiklah kita lihat dulu data penjualan yang akan dikirim. Berikut class penjualan</p>

<h4>Penjualan</h4>

<pre><code>public class Penjualan {
    private Integer id;
    private Date tanggal = new Date();
    private List&lt;PenjualanDetail&gt; details = new ArrayList&lt;PenjualanDetail&gt;();
    // getter dan setter
}
</code></pre>

<p>Berikutnya, penjualan detail.</p>

<h4>PenjualanDetail</h4>

<pre><code>public class PenjualanDetail {
    private Integer id;
    private Penjualan penjualan;
    private Produk produk;
    private Integer jumlah;

    // getter dan setter
}
</code></pre>

<p>Object baru ini tentu saja harus kita buatkan transformernya untuk mengkonversi object menjadi JSON.</p>

<h4>CabangService</h4>

<pre><code>public class JsonTransformer{
    public Penjualan jsonToPenjualan(String json){
        Map&lt;String , Class&gt; binding = new HashMap&lt;String , Class&gt;();
        binding.put("details", PenjualanDetail.class);
        return (Penjualan) JSONObject.toBean(JSONObject.fromObject(json), Penjualan.class, binding);
    }

    public String penjualanToJson(Penjualan p){
        // remove dulu cyclic dependency
        for (PenjualanDetail detail : p.getDetails()) {
            detail.setPenjualan(null);
        }

        return JSONObject.fromObject(p).toString();
    }
}
</code></pre>

<p>Penjualan dan PenjualanDetail akan kita proses melalui method simpan dan hapus yang ada di CabangService.</p>

<h4>CabangService</h4>

<pre><code>public class CabangService {
    public void save(Penjualan p) {
        System.out.println("Simpan penjualan dengan ID : "+p.getId());
        System.out.println("Tanggal : "+new SimpleDateFormat("dd MMM yyyy").format(p.getTanggal()));
        System.out.println("Details : ");
        for (PenjualanDetail detail : p.getDetails()) {
            System.out.println("Produk : "+detail.getProduk().getKode());
            System.out.println("Jumlah : "+detail.getJumlah());
        }
    }

    public void delete(Penjualan p) {
        System.out.println("Hapus penjualan dengan ID : "+p.getId());
    }
}
</code></pre>

<p>Tentunya nanti method save dan delete ini akan lebih canggih dari ini, misalnya insert dan delete ke database.</p>

<p>Kalau kita lihat skemanya, ada satu titik di mana message akan dilihat dan disalurkan ke channel yang sesuai.</p>

<p><img src="/images/uploads/2009/06/router-only-300x104.png" title="Routing Message" ></p>

<p>Penjualan yang akan disimpan dimasukkan ke channel penjualan-simpan. Sedangkan object penjualan yang akan dihapus dimasukkan ke channel penjualan-hapus. Dengan demikian, kita harus membuat router yang mampu menentukan channel yang akan dipilih dengan melihat message yang masuk ke dalam router tersebut. Operasi yang akan dilakukan (simpan atau hapus) harus dimasukkan ke message header atau message content. Agar sederhana, kita tambahkan saja satu property di class Penjualan untuk menentukan operasi yang akan dilakukan. Bila class Penjualan ini dimapping menggunakan JPA, kita bisa menandai property ini dengan anotasi @Transient agar isinya tidak disimpan di database.</p>

<p>Karena nantinya property operasi ini akan digunakan tidak saja untuk Penjualan, tapi juga transaksi lainnya, baiklah kita buat saja di superclass DomainObject sebagai berikut.</p>

<h4>Penjualan</h4>

<pre><code>public class DomainObject {
    private String operasi;
}
</code></pre>

<p>Berikut class Penjualan yang sudah dimodifikasi.</p>

<h4>Penjualan</h4>

<pre><code>public class Penjualan extends DomainObject {
    private Integer id;
    private Date tanggal = new Date();
    private List&lt;PenjualanDetail&gt; details = new ArrayList&lt; &lt;PenjualanDetail&gt;();

    // getter dan setter
}
</code></pre>

<p>Property operasi ini akan dilihat oleh router untuk menentukan nama channel. Berikut implementasi Router.</p>

<h4>Router</h4>

<pre><code>public class NamaKelasDanOperasiRouter {
    public String pilihChannel(Object msg){
        String classname = msg.getClass().getSimpleName().toLowerCase();

        if(!DomainObject.class.isAssignableFrom(msg.getClass())) {
            throw new IllegalArgumentException("Harus object bertipe : "+DomainObject.class.getName());
        }

        DomainObject obj = (DomainObject) msg;
        String operasi = obj.getOperasi().toLowerCase();

        return classname + "-" + operasi;
    }
}
</code></pre>

<p>Router ini akan membaca nama class dari object yang diterimanya dan menggabungkannya dengan property operasi. Jadi, object Penjualan dengan operasi simpan akan menghasilkan nama channel penjualan-simpan. Demikian juga object Pembelian dengan operasi hapus akan menghasilkan channel pembelian-hapus.</p>

<p>Berikut unit test untuk router di atas.</p>

<h4>Router</h4>

<pre><code>public class NamaKelasDanOperasiRouterTest {

    @Test
    public void testPilihChannel() {
        Penjualan p = new Penjualan();
        p.setOperasi("simpan");
        assertEquals("penjualan-simpan", new NamaKelasDanOperasiRouter().pilihChannel(p));
    }

}
</code></pre>

<p>Berikut aliran message mulai dari gateway sampai menjadi JSON.</p>

<p><img src="/images/uploads/2009/06/gateway-to-json-300x31.png" title="Dari Gateway sampai menjadi JSON" ></p>

<p>Dan ini adalah konfigurasi Spring Integration untuk flow di atas.</p>

<h4>Gateway ke JSON</h4>

<pre><code>&lt;gateway id="gateway"
    service-interface="com.artivisi.explore.spring.integration.gateway.Gateway"
    default-request-channel="outgoingPenjualan"
/&gt;

&lt;channel id="outgoingPenjualan"/&gt;

&lt;transformer 
    input-channel="outgoingPenjualan" 
    output-channel="outgoingJson"
    ref="jsonTransformer" 
    method="penjualanToJson"
/&gt;

&lt;channel id="outgoingJson"/&gt;
</code></pre>

<p>Pada artikel sebelumnya, kita mengganti implementasi email dengan shared folder supaya proses development lebih cepat. Akses ke shared folder jauh lebih cepat daripada email yang dibatasi oleh kecepatan internet. Kali ini, kita akan menggunakan bridge, yaitu hubungan langsung antar channel. Ini kita gunakan untuk menghubungkan channel outgoingJson dengan incomingJson. Hubungan ini pada artikel sebelumnya diimplementasikan menggunakan shared folder dan email.</p>

<p><img src="/images/uploads/2009/06/bridge-300x45.png" title="bridge antara incoming dan outgoing" ></p>

<p>Berikut konfigurasi bridge untuk menghubungkan outgoingJson dan incomingJson.</p>

<h4>Bridge</h4>

<pre><code>&lt;bridge 
    input-channel="outgoingJson" 
    output-channel="incomingJson" 
/&gt;
</code></pre>

<p>Dari incomingJson, kita konversi dulu menjadi object.
Berikut konfigurasinya.</p>

<h4>JSON ke Object</h4>

<pre><code>&lt;channel id="incomingJson"/&gt;

&lt;transformer 
    input-channel="incomingJson" 
    output-channel="incomingPenjualan"
    ref="jsonTransformer" 
    method="jsonToPenjualan"
/&gt;
</code></pre>

<p>Setelah menjadi object, kita masukkan ke router untuk ditentukan channelnya.</p>

<h4>Routing</h4>

<pre><code>&lt;router 
    input-channel="incomingPenjualan" 
    ref="namaKelasDanOperasiRouter" 
    method="pilihChannel"
/&gt;
</code></pre>

<p>Kemudian, dari channel kita sambungkan ke method save dan delete.</p>

<h4>Method Save</h4>

<pre><code>&lt;channel id="penjualan-simpan"/&gt;

&lt;service-activator 
    input-channel="penjualan-simpan"
    ref="cabangService"
    method="save"/&gt;
</code></pre>

<h4>Method Delete</h4>

<pre><code>&lt;channel id="penjualan-hapus"/&gt;

&lt;service-activator 
    input-channel="penjualan-hapus"
    ref="cabangService"
    method="delete"/&gt;
</code></pre>

<p>Terakhir, kita buat class untuk menjalankan semua rangkaian integrasi ini.</p>

<h4>CabangRouterDemo</h4>

<pre><code>public class CabangRouterDemo {
    public static void main(String[] args) {
         // 1. Menginstankan Spring Application Context
        AbstractApplicationContext ctx 
            = new ClassPathXmlApplicationContext("cabang-router-ctx.xml", CabangRouterDemo.class);
        ctx.registerShutdownHook();
        Gateway gw = (Gateway) ctx.getBean("gateway");
        Penjualan p1 = bikinTransaksi(100, "simpan");
        Penjualan p2 = bikinTransaksi(102, "hapus");

        gw.send(p1);
        gw.send(p2);

        System.exit(0);
    }

    private static Penjualan bikinTransaksi(Integer id, String operasi) {
        Penjualan p = new Penjualan();
        p.setId(id);
        p.setOperasi(operasi);

        Produk pr1 = new Produk(1001, "PR-001", "Produk 001");
        Produk pr2 = new Produk(1002, "PR-002", "Produk 002");
        Produk pr3 = new Produk(1003, "PR-003", "Produk 003");

        PenjualanDetail pd1 = new PenjualanDetail(11, pr1, 1);
        PenjualanDetail pd2 = new PenjualanDetail(12, pr2, 2);
        PenjualanDetail pd3 = new PenjualanDetail(13, pr3, 3);

        p.addPenjualanDetail(pd1);
        p.addPenjualanDetail(pd2);
        p.addPenjualanDetail(pd3);

        return p;
    }
}
</code></pre>

<p>Demikianlah penggunaan routing dengan Spring Integration. Seperti kita lihat, dengan menggunakan Spring Integration, aplikasi kita menjadi fleksibel dan mudah ditest. Semua implementasi kode program Java, baik itu transformer, router, dan service method, bisa ditest dengan mudah menggunakan JUnit. Kita juga lihat bahwa semua kode program Java kita tidak memiliki ketergantungan terhadap Spring Integration.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/linux/simulasi-slow-network/">Simulasi Slow Network</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-15T15:21:33+07:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di salah satu proyek ArtiVisi, kita memiliki aplikasi client-server yang terhubung melalui koneksi internet berbandwidth kecil. Client menghubungi server melalui modem GPRS.</p>

<p>Permasalahannya adalah bagaimana cara mengetes koneksi lemot ini pada saat development? Umumnya pada saat development kita menjalankan server dan client di komputer yang sama. Atau kalaupun di komputer berbeda, dijalankan di satu LAN, sehingga kecepatan bisa mencapai 100Mbps.</p>

<p>Ada dua alternatif yang bisa kita gunakan. Yang pertama adalah aplikasi tc (traffic control) yang biasanya sudah terinstal secara default di Ubuntu. Kalau belum terinstal, kita bisa menginstal paket iproute atau iproute2, tergantung distro yang Anda gunakan.</p>

<p>Alternatif kedua, menggunakan aplikasi ip_relay. Aplikasi ini bisa diinstal dengan nama paket iprelay.</p>

<p>Berikut adalah referensi pemakaian tc :</p>

<ul>
<li><p><a href="http://www.kdedevelopers.org/node/1878">pipita&#8217;s blog</a></p></li>
<li><p><a href="http://henrydu.com/blog/how-to/simulate-a-slow-link-by-linux-bridge-123.html">Henry&#8217;s Point</a></p></li>
</ul>


<p>Dan ini adalah referensi pemakaian iprelay :</p>

<ul>
<li><p><a href="http://ubuntuforums.org/showthread.php?t=670628">Ubuntu Forum</a></p></li>
<li><p><a href="http://www.stewart.com.au/ip_relay/README">Readme di website ip_relay</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/integrasi-pusat-cabang-2/">Integrasi Aplikasi Kantor Pusat Dan Cabang [Bagian 2]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-12T20:43:16+07:00" pubdate data-updated="true">Jun 12<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-1/">artikel sebelumnya</a>, kita sudah mendiskusikan requirement yang diinginkan. Sekarang kita akan melakukan implementasi menggunakan <a href="http://www.springsource.org/spring-integration">Spring Integration</a>.</p>

<p>Spring Integration memiliki beberapa abstraksi utama yang perlu kita ketahui agar bisa membuat implementasi, yaitu :</p>

<ul>
<li><p>Message : ini adalah data yang akan kita kirim, proses, dan terima</p></li>
<li><p>Channel : ini adalah saluran tempat lewatnya message</p></li>
<li><p>Endpoint : ini adalah ujung dari channel</p></li>
<li><p>Transport : mekanisme pengiriman message. Spring Integration mendukung messaging (email,JMS), remoting (Web Service, RMI, HttpInvoker, HTTP), file, dan lainnya (stream)</p></li>
</ul>


<p>Ilustrasi hubungan antara message, channel, dan endpoint bisa dilihat di gambar berikut :</p>

<p><img src="/images/uploads/2009/06/msg-channel-endpoint-300x59.png" title="Hubungan Message, Channel, dan Endpoint" ></p>

<p>Message terdiri dari dua bagian utama, yaitu header dan payload (isi message).</p>

<h3>Channel</h3>

<p>Berdasarkan kemampuan menampung message, channel dibedakan menjadi :</p>

<ul>
<li><p>Pollable : memiliki buffer untuk menampung message. Dengan adanya kapasitas buffer, pengirim tidak perlu menunggu sampai penerima mendapatkan message, kecuali bila buffernya penuh. Dalam kondisi buffer penuh, pengirim akan menunggu (blocking) sampai ada slot kosong yang bisa digunakan untuk menyimpan message. Penerima dapat memeriksa keberadaan message dalam buffer. Dalam melakukan pemeriksaan, penerima dapat menunggu sampai ada message, atau sampai jangka waktu tertentu (timeout)</p></li>
<li><p>Subscribable : tidak memiliki buffer, tiap message yang masuk langsung dikirim ke endpoint. Pengirim harus menunggu sampai message diterima.</p></li>
</ul>


<p>Berdasarkan perilaku pengiriman message, channel dibedakan menjadi :</p>

<ul>
<li><p>Point to Point (PTP) : tiap message hanya dikirimkan ke satu penerima saja. Walaupun ada beberapa penerima yang terhubung ke channel PTP, tapi hanya salah satu saja yang akan menerima message</p></li>
<li><p>Point to Multipoint (PTM) : tiap message akan dikirim ke semua penerima yang terdaftar.</p></li>
</ul>


<p>Ada beberapa implementasi channel :</p>

<ul>
<li><p>Direct Channel : subscribable dan point-to-point. Seluruh proses (kirim, masuk channel, terima) akan dilakukan dalam thread yang sama</p></li>
<li><p>Queue Channel : pollable dan point to point. Message yang datang duluan akan dikirim duluan juga (FIFO)</p></li>
<li><p>Priority Channel : mirip dengan Queue Channel, tapi tidak menggunakan FIFO, melainkan melihat field Priority di Message Header untuk menentukan mana message yang harus dikirim terlebih dulu</p></li>
<li><p>Rendezvous Channel : mirip dengan Direct Channel, tapi pengirim dan penerima menggunakan thread yang berbeda. Pengirim akan menunggu sampai message diterima atau sampai timeout. Atau sebaliknya, penerima akan menunggu sampai ada message yang masuk. Biasanya digunakan untuk mengimplementasikan request-reply.</p></li>
<li><p>ThreadLocal Channel : pollable dan point-to-point. Message disimpan di thread local, sehingga tidak disharing dengan thread yang berbeda.</p></li>
<li><p>Publish Subscribe Channel : subscribable dan point-to-multipoint. Setiap penerima yang terdaftar akan menerima message. Tidak bisa menyimpan message, sehingga kalau kita butuh buffer, kita harus merangkainya dengan channel jenis lain yang memiliki buffer.</p></li>
</ul>


<h3>Endpoint</h3>

<p>Endpoint digunakan untuk menghubungkan channel. Pemrosesan message dilakukan dalam endpoint. Ada beberapa jenis endpoint, yaitu:</p>

<ul>
<li><p>Service Activator : kalau kita ingin memanggil business method kita, gunakan endpoint ini.</p></li>
<li><p>Channel Adapter : ini adalah penghubung channel dengan transport, baik untuk menerima message (inbound) ataupun mengirim message (outbound).</p></li>
<li><p>Transformer : digunakan untuk mengubah format message</p></li>
<li><p>Filter : digunakan untuk memutuskan apakah suatu message akan diterima atau dibuang</p></li>
<li><p>Router : digunakan untuk memilih channel mana yang akan menerima message</p></li>
<li><p>Splitter : digunakan untuk memecah message menjadi beberapa bagian untuk diproses secara independen</p></li>
<li><p>Aggregator : digunakan untuk menggabungkan beberapa message menjadi satu message untuk diteruskan ke channel berikutnya</p></li>
<li><p>Resequencer : digunakan untuk menyusun urutan message</p></li>
</ul>


<h3>Implementasi Kantor Pusat</h3>

<p>Sekarang, setelah kita memahami berbagai istilah dalam Spring Integration, kita bisa merancang implementasi dari requirement kita. Berikut adalah aliran message di sisi kantor pusat. Kantor pusat mengirim beberapa data produk baru, dan akan dikonversi menjadi JSON.</p>

<p><img src="/images/uploads/2009/06/pusat-json-300x24.png" title="Flow konversi data menjadi JSON" ></p>

<p>Setelah menjadi JSON, selanjutnya kita bisa kirim melalui berbagai transport yang disediakan. Untuk tahap development, kita kirim saja melalui file ke folder /tmp, supaya mudah didebug dan tidak butuh internet.</p>

<p><img src="/images/uploads/2009/06/json-file-300x56.png" title="Flow message JSON ke shared folder" ></p>

<p>Selanjutnya, setelah transport melalui file sudah dipastikan benar, baik format data, isi data, maupun rangkaian filternya, kita bisa mengganti channel adapter untuk mengirim ke GMail.</p>

<p><img src="/images/uploads/2009/06/json-email-300x35.png" title="Flow message JSON ke Email" ></p>

<p>Kita harus membuat beberapa file sebagai berikut :</p>

<ul>
<li><p>Produk.java : domain model dari data yang akan kita kirim</p></li>
<li><p>JsonTransformer.java : kode program untuk mengubah object Produk menjadi JSON</p></li>
<li><p>JsonTransformerTest.java : kode program untuk mengetes ProdukTransformer</p></li>
<li><p>PusatSender.java : kode program untuk mengaktifkan Spring Integration dan mengirim data produk</p></li>
<li><p>Gateway.java : interface untuk mengirim message. Kita harus membuat ini agar tidak ada dependensi ke library Spring Integration</p></li>
<li><p>pusat-integration-ctx.xml : konfigurasi Spring Integration</p></li>
</ul>


<p>Berikut kode programnya.</p>

<h4>Produk.java</h4>

<pre><code>public class Produk implements Serializable {
    private Integer id;
    private String kode;
    private String nama;

    // getter dan setter generate dengan IDE
}
</code></pre>

<h4>JsonTransformer.java</h4>

<pre><code>public class JsonTransformer {
    public Produk jsonToProduk(String json){
        return (Produk) JSONObject.toBean(JSONObject.fromObject(json), Produk.class);
    }

    public String produkToJson(Produk p){
        return JSONObject.fromObject(p).toString();
    }
}
</code></pre>

<h4>JsonTransformerTest.java</h4>

<pre><code>public class JsonTransformerTest {

    @Test
    public void testJsonToProduk() {
        Produk p = new JsonTransformer()
                    .jsonToProduk("{\"id\":99,\"kode\":\"T-001\",\"nama\":\"Produk Test\"}");
        assertEquals(new Integer(99), p.getId());
        assertEquals("T-001", p.getKode());
        assertEquals("Produk Test", p.getNama());
    }

    @Test
    public void testProdukToJson() {
        Produk p = new Produk();
        p.setId(99);
        p.setKode("T-001");
        p.setNama("Produk Test");

        assertEquals("{\"id\":99,\"kode\":\"T-001\",\"nama\":\"Produk Test\"}",
                new JsonTransformer().produkToJson(p));
    }
}
</code></pre>

<h4>PusatSender.java</h4>

<pre><code>public class PusatSender {
    public static void main(String[] args) {
        // 1. Menginstankan Spring Application Context
        AbstractApplicationContext ctx 
            = new ClassPathXmlApplicationContext("pusat-integration-ctx.xml", Gateway.class);
        ctx.registerShutdownHook();
        Gateway gw = (Gateway) ctx.getBean("gateway");

        // 2. Kirim produk ke gateway
        int jumlahProduk = 5;
        for (int i = 0; i &lt; jumlahProduk; i++) {
            Produk p = new Produk();
            p.setId(i);
            p.setKode("PRD-00"+i);
            p.setNama("Produk "+i);
            gw.send(p);
            System.out.println("Kirim produk "+i);
        }
        System.out.println("Produk terkirim");
        System.exit(0);
    }
}
</code></pre>

<h4>Gateway.java</h4>

<pre><code>public interface Gateway {
    public void send(Produk p);
}
</code></pre>

<h4>pusat-integration-ctx.xml</h4>

<pre><code>&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:beans="http://www.springframework.org/schema/beans"
       xmlns:file="http://www.springframework.org/schema/integration/file"
       xmlns:mail="http://www.springframework.org/schema/integration/mail"
       xmlns:transformer="http://www.springframework.org/schema/integration/transformer"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
           http://www.springframework.org/schema/integration/file
           http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd
           http://www.springframework.org/schema/integration/mail
           http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd
           http://www.springframework.org/schema/integration/stream
           http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd
           http://www.springframework.org/schema/integration/transformer
           http://www.springframework.org/schema/integration/transformer/spring-integration-transformer-1.0.xsd"&gt;


    &lt;gateway id="gateway"
                service-interface="com.artivisi.explore.spring.integration.pusat.Gateway"
                default-request-channel="outgoingProduk"/&gt;

    &lt;channel id="outgoingProduk" /&gt;

    &lt;transformer input-channel="outgoingProduk" output-channel="outgoingJson"
    ref="jsonTransformer" method="produkToJson"/&gt;

    &lt;publish-subscribe-channel id="outgoingJson" /&gt;

    &lt;file:outbound-channel-adapter channel="outgoingJson" directory="/tmp"/&gt;

    &lt;mail:header-enricher
        id="mailHeaderEnricher"
        subject="Spring Integration Demo"
        to="cabang@gmail.com"
        from="pusat@gmail.com"
        reply-to="pusat@gmail.com"
        overwrite="false"
        input-channel="outgoingJson"
        output-channel="outgoingEmail"/&gt;

    &lt;channel id="outgoingEmail" /&gt;

    &lt;mail:outbound-channel-adapter
        mail-sender="mailSender"
        channel="outgoingEmail"
        /&gt;

    &lt;beans:bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
        &lt;beans:property name="defaultEncoding" value="UTF-8"/&gt;
        &lt;beans:property name="host" value="smtp.gmail.com"/&gt;
        &lt;beans:property name="port" value="465"/&gt;
        &lt;beans:property name="username" value="mygmailaccount"/&gt;
        &lt;beans:property name="password" value="mygmailpassword"/&gt;
        &lt;beans:property name="javaMailProperties"&gt;
            &lt;beans:value&gt;
                mail.debug=true
                mail.smtp.starttls.enable=true
                mail.smtp.auth=true
                mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
                mail.smtp.socketFactory.fallback=false
            &lt;/beans:value&gt;
        &lt;/beans:property&gt;
    &lt;/beans:bean&gt;

    &lt;beans:bean id="jsonTransformer" class="com.artivisi.explore.spring.integration.model.JsonTransformer"/&gt;
&lt;/beans:beans&gt;
</code></pre>

<h3>Implementasi Kantor Cabang</h3>

<p>Di sisi kantor cabang, berikut aliran message dari transport hingga menjadi JSON. Kita mulai dengan transport file.</p>

<p><img src="/images/uploads/2009/06/file-json-300x35.png" title="Flow dari shared folder menjadi JSON" ></p>

<p>Bila kita menggunakan email, berikut gambarnya</p>

<p><img src="/images/uploads/2009/06/email-json-300x35.png" title="Flow dari Email menjadi JSON" ></p>

<p>Setelah menjadi JSON, kita proses sampai ke CabangService</p>

<p><img src="/images/uploads/2009/06/json-cabang-300x25.png" title="Flow pemrosesan JSON menjadi Produk" ></p>

<p>Kita harus membuat beberapa file sebagai berikut :</p>

<ul>
<li><p>CabangReceiver.java : kode program untuk mengaktifkan Spring Integration</p></li>
<li><p>CabangService.java : kode program yang akan dipanggil setelah message diterima, dikonversi dari JSON menjadi Produk</p></li>
<li><p>cabang-integration-ctx.xml : konfigurasi Spring Integration</p></li>
</ul>


<p>Kode programnya.</p>

<h4>CabangReceiver.java</h4>

<pre><code>public class CabangReceiver {
    public static void main(String[] args) {
        AbstractApplicationContext ctx 
                = new ClassPathXmlApplicationContext("cabang-integration-ctx.xml", CabangReceiver.class);
        ctx.registerShutdownHook();
    }
}
</code></pre>

<h4>CabangService.java</h4>

<pre><code>public class CabangService {
    public void terimaProduk(Produk p){
        // Tampilkan data produk, tapi bisa juga disimpan di database
        System.out.println("Terima produk");
        System.out.println("ID : "+p.getId());
        System.out.println("Kode : "+p.getKode());
        System.out.println("Nama : "+p.getNama());
    }
}
</code></pre>

<h4>cabang-integration-ctx.xml</h4>

<pre><code>&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:beans="http://www.springframework.org/schema/beans"
       xmlns:file="http://www.springframework.org/schema/integration/file"
       xmlns:mail="http://www.springframework.org/schema/integration/mail"
       xmlns:transformer="http://www.springframework.org/schema/integration/transformer"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
           http://www.springframework.org/schema/integration/stream
           http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd
           http://www.springframework.org/schema/integration/file
           http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd
           http://www.springframework.org/schema/integration/mail
           http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd
           http://www.springframework.org/schema/integration/transformer
           http://www.springframework.org/schema/integration/transformer/spring-integration-transformer-1.0.xsd"&gt;


    &lt;file:inbound-channel-adapter id="filePoller"
       directory="/tmp"
       filename-pattern="^.*\.msg$"
       channel="incomingFile"/&gt;

    &lt;channel id="incomingFile" /&gt;

    &lt;file:file-to-string-transformer
       input-channel="incomingFile"
       output-channel="incomingJson"
       delete-files="true" /&gt;

    &lt;channel id="incomingJson" /&gt;

    &lt;transformer input-channel="incomingJson" output-channel="incomingProduk"
    ref="jsonTransformer" method="jsonToProduk"/&gt;

    &lt;channel id="incomingProduk" /&gt;

    &lt;service-activator input-channel="incomingProduk"
                      ref="cabangService"
                      method="terimaProduk"/&gt;

    &lt;poller id="defaultPoller" default="true"&gt;
        &lt;interval-trigger interval="3" time-unit="SECONDS"/&gt;
    &lt;/poller&gt;


    &lt;beans:bean id="jsonTransformer" class="com.artivisi.explore.spring.integration.model.JsonTransformer"/&gt;
    &lt;beans:bean id="cabangService" class="com.artivisi.explore.spring.integration.cabang.CabangService"/&gt;
&lt;/beans:beans&gt;
</code></pre>

<p>Untuk menerima email, kita dapat memilih protokol POP3, IMAP, atau IMAP-Idle. POP3 dan IMAP akan mendownload semua email yang masuk, setelah itu, kita harus melakukan polling dengan interval tertentu untuk memeriksa apakah ada email baru. Bila kita menggunakan IMAP-Idle, kita tidak perlu melakukan polling. Mail server akan memberikan notifikasi bila ada email baru yang masuk, setelah itu kita bisa mendownloadnya.</p>

<p>Berikut konfigurasi untuk GMail</p>

<h4>Debug Output</h4>

<pre><code>    &lt;beans:bean id="javaMailProperty" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
        &lt;beans:property name="properties"&gt;
            &lt;beans:value&gt;
                mail.debug=true
            &lt;/beans:value&gt;
        &lt;/beans:property&gt;
    &lt;/beans:bean&gt;
</code></pre>

<h4>POP3</h4>

<pre><code>    &lt;mail:inbound-channel-adapter
    channel="incomingMail"
    store-uri="pop3s://mygmailaccount:mygmailpassword@pop.gmail.com:995/INBOX"
    java-mail-properties="javaMailProperty"/&gt;
</code></pre>

<h4>IMAP</h4>

<pre><code>    &lt;mail:inbound-channel-adapter
    channel="incomingMail"
    store-uri="imaps://mygmailaccount:mygmailpassword@imap.gmail.com:993/INBOX" /&gt;
</code></pre>

<h4>IMAP-Idle</h4>

<pre><code>    &lt;mail:imap-idle-channel-adapter channel="incomingMail"
    store-uri="imaps://mygmailaccount:mygmailpassword@imap.gmail.com:993/INBOX"/&gt;
</code></pre>

<p>Setelah email masuk, jangan lupa konversi dulu jadi String.</p>

<pre><code>    &lt;channel id="incomingMail" /&gt;

    &lt;mail:mail-to-string-transformer 
    input-channel="incomingMail" 
    output-channel="incomingJson"/&gt;
</code></pre>

<p>Demikianlah tutorial penggunaan Spring Integration. Dengan menggunakan Spring Integration ini, ada beberapa benefit yang kita dapatkan dibandingkan coding sendiri :</p>

<ul>
<li><p>Kode program lebih sedikit</p></li>
<li><p>Kode program lebih mudah ditest. Kita bisa menggunakan JUnit untuk JsonTransformer. Alur pengiriman data juga bisa ditest di komputer lokal tanpa koneksi ke GMail, sehingga kalau ada error bisa diperbaiki dengan lebih cepat.</p></li>
<li><p>Aliran data lebih mudah dibaca, yaitu dalam konfigurasi Spring Integration</p></li>
<li><p>Fleksibilitas dalam pemilihan transport. Bukan cuma email, tapi juga banyak opsi lain seperti remoting dan file. Opsi ini cuma butuh beberapa baris konfigurasi saja untuk mengaktifkannya.</p></li>
</ul>


<p>Konsumsi effort :</p>

<ul>
<li><p>Download : 1 jam</p></li>
<li><p>Browsing tutorial : 2 jam</p></li>
<li><p>Mempelajari Spring Integration : 8 jam</p></li>
<li><p>Membuat sample aplikasi : 4 jam</p></li>
<li><p>Menulis blog dan membuat gambar : 8 jam</p></li>
<li><p><strong>Total : 23 jam (3 hari)</strong></p></li>
</ul>


<p>Apakah dalam 3 hari kita bisa membuat implementasi kirim-terima data produk via email yang bebas bug ??</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/integrasi-pusat-cabang-1/">Integrasi Aplikasi Kantor Pusat Dan Cabang [Bagian 1]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-11T21:39:48+07:00" pubdate data-updated="true">Jun 11<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Integrasi Aplikasi Pusat Cabang - Bagian I</p>

<p>Beberapa waktu yang lalu, kami di ArtiVisi dihadapkan pada suatu tantangan, yaitu sinkronisasi aplikasi antara pusat dan cabang.
Aplikasi pusat maupun cabang memiliki database masing-masing, dan tentunya data transaksi masing-masing pula.</p>

<p>Pada artikel ini, saya akan mengelaborasi proses problem solving yang dilakukan, solusi yang dipilih, dan tentunya dilengkapi dengan source code.</p>

<h3>Use Case</h3>

<p>Ada beberapa use case yang ingin didukung oleh aplikasi, sebagai berikut :</p>

<ul>
<li><p>Pusat menambahkan jenis produk baru, data ini harus segera diimplementasikan juga di cabang</p></li>
<li><p>Transaksi yang dilakukan di cabang harus dikirim ke pusat agar bisa dibuatkan laporan keseluruhan</p></li>
<li><p>Data pelanggan di cabang harus juga dikirim ke pusat</p></li>
<li><p>Perpindahan stok barang dari pusat ke cabang dan sebaliknya</p></li>
</ul>


<h3>Constraint</h3>

<p>Bicara requirement, tentu tidak bisa dilepaskan dari constraint. Berikut constraint yang ada :</p>

<ul>
<li><p>Pusat dan cabang sama-sama terhubung ke internet menggunakan Speedy</p></li>
<li><p>Karena pakai Speedy, kita bisa mengekspose satu mesin ke internet menggunakan IP Public</p></li>
<li><p>IP Public tidak dedicated, dan mungkin berubah sewaktu-waktu</p></li>
<li><p>Server aplikasi dan database di pusat/cabang belum tentu hidup. Kalaupun hidup, belum tentu hidup berbarengan.
Bisa saja pusat sedang nyala, cabang mati lampu, dan sebaliknya.</p></li>
</ul>


<h3>Alternatif Solusi</h3>

<p>Setelah kita memiliki requirement dan constraint, tahap berikutnya adalah membuat daftar alternatif solusi.
Berikut adalah alternatif yang bisa kita lakukan untuk memecahkan masalah di atas.</p>

<ul>
<li><p>Remoting</p>

<ul>
<li><p>Web Services</p></li>
<li><p>RMI</p></li>
<li><p>HttpInvoker</p></li>
</ul>
</li>
<li><p>Messaging</p>

<ul>
<li><p>JMS</p></li>
<li><p>Email (POP3/IMAP dan SMTP)</p></li>
</ul>
</li>
<li><p>File</p>

<ul>
<li><p>Shared Folder</p></li>
<li><p>FTP</p></li>
<li><p>SSH/SCP</p></li>
</ul>
</li>
<li><p>Database</p>

<ul>
<li><p>Shared Database</p></li>
<li><p>Replikasi Database</p></li>
</ul>
</li>
</ul>


<h3>Pemilihan Solusi</h3>

<p>Jaringan publik melalui internet sangat tidak reliable dan memiliki banyak keterbatasan.
Kita tidak bisa membuka sembarang port, karena mungkin saja diblokir di tengah jalan.
Kita juga tidak bisa menggunakan protokol yang terlalu kompleks atau cerewet (membutuhkan transfer data yang sering).
Oleh karena itu, kita bisa menyingkirkan alternatif berikut.</p>

<ul>
<li><p>Remoting dengan RMI : port tidak standar</p></li>
<li><p>Messaging dengan JMS : port tidak standar</p></li>
<li><p>Replikasi MySQL : protokol terlalu kompleks dan cerewet, port tidak standar</p></li>
</ul>


<p>Kita harus mempertimbangkan konsumsi bandwidth. Protokol yang rakus bandwidth bisa kita singkirkan, yaitu Remoting dengan WS.</p>

<p>Melihat constraint terakhir, kita juga harus mengeliminasi beberapa alternatif yang mengharuskan pusat dan cabang online bersamaan, yaitu Remoting dengan Spring HTTPInvoker dan File Transfer, baik FTP maupun SSH/SCP.</p>

<p>Dengan demikian, yang tersisa adalah Messaging dengan Email. Kita bisa mengirim data dengan attachment. Untuk menghemat bandwidth, attachment bisa dikompresi. Pusat dan cabang bisa online kapanpun mereka mau, dan akan tetap menerima message. Kalau ada message yang hilang di tengah jalan, orang pusat/cabang bisa menelepon untuk minta dikirim ulang datanya.</p>

<p>Sebagai bonus, dengan memilih email sebagai media transfer data, kita tidak perlu repot-repot mengelola infrastruktur sendiri. Kita bisa gunakan layanan GMail yang gratis, berkapasitas besar, dan memiliki implementasi POP3, IMAP, dan SMTP. Ada satu fitur istimewa dari IMAP, yaitu <a href="http://en.wikipedia.org/wiki/IMAP_IDLE">IMAP-Idle</a>. Fitur ini akan sangat berguna kelak di kemudian hari. Kebetulan <a href="http://samj.net/2008/07/proof-gmail-imap-gimap-supports-imap.html">GMail sudah mendukung fitur ini</a>.</p>

<h3>Desain Implementasi</h3>

<p>Baiklah, mari kita implementasikan sinkronisasi melalui email. Ada beberapa pertanyaan lanjutan. Pertama, apa yang ingin dikirim? Sebagai contoh sederhana, kita ingin mengirim data produk baru dari pusat ke cabang. Inilah class Produk.</p>

<pre><code>public class Produk {
  private Integer id;
  private String kode;
  private String nama;

  // getter dan setter
}
</code></pre>

<p>Bila kita membuat object Produk, datanya akan tersimpan di memori. Kita harus mengkonversi format data di memori ini ke bentuk file, supaya bisa dikirim dalam bentuk attachment. Ada beberapa pilihan lagi di sini, yaitu :</p>

<ul>
<li><p>java.io.Serializable, konversi dengan ObjectInputStream dan ObjectOutputStream</p></li>
<li><p>JSON</p></li>
<li><p>XML</p></li>
</ul>


<p>Serializable lebih unggul dalam hal kemudahan coding dan kecepatan marshall/unmarshall. Di Java menulis object ke file sangat mudah dan cepat. Prosesnya sama untuk apapun object yang ingin kita konversi. Untuk memproses konversi juga tidak dibutuhkan CPU dan Memori tinggi. Walaupun demikian, file yang dihasilkan berbentuk binary, sehingga menyulitkan debugging.</p>

<p>JSON dan XML berbentuk text, sehingga mudah didebug kalau ada masalah. Walaupun demikian, kita harus membuat atau memilih dari yang ada implementasi generator dan parser untuk proses konversi. Proses konversinya butuh resource CPU dan memori. Dan yang paling penting, kita mungkin harus membuat generator/parser untuk tiap tipe data yang akan kita kirim.</p>

<p>Sementara saya pilih JSON, karena ada <a href="http://json-lib.sourceforge.net/usage.html">json-lib</a> yang bisa mengkonversi object menjadi JSON dan sebaliknya dengan mudah.</p>

<p>Selanjutnya, bagaimana cara mengirim email?</p>

<p>Cara mengirim email dengan Java sudah ditunjukkan Ifnu <a href="http://ifnu.artivisi.com/?p=80">di sini</a>. Tapi saya tidak mau coding tangan kosong seperti itu. Bukan apa-apa, setiap baris kode yang kita tulis harus ditest dan dimaintain. Belum lagi kalo nanti ada perubahan requirement, bisa coding ulang.</p>

<p>Nah, pertama saya memutuskan <a href="http://static.springframework.org/spring/docs/2.5.x/reference/mail.html">menggunakan Spring untuk mengirim email</a>. Ibaratnya kalau coding sendiri itu berkelahi dengan tangan kosong, pakai Spring berkelahi pakai pistol. Jauh lebih cepat dan mudah.</p>

<p>Tapi ternyata, pistol juga tidak cukup, karena kita belum bisa menerima email. Bisa kirim gak bisa terima ya percuma, karena di sisi kantor cabang kita tentu harus mengambil dan memproses data yang dikirim dari pusat. Ifnu sebetulnya sudah membuat implementasi penerima emailnya, tapi nampaknya belum diposting.</p>

<p>Saatnya membuka gudang senjata dan mencari senjata yang lebih besar. Saya menemukan rocket launcher, yaitu <a href="http://www.springsource.org/spring-integration">Spring Integration</a>.</p>

<p>Bukan saja bisa menerima email, Spring Integration juga bisa menggunakan semua alternatif transport yang disebutkan di atas (WS, HTTPInvoker, RMI, FTP, SSH, JMS, Email) hanya dengan mengganti beberapa baris konfigurasi. Wow &#8230;. canggih sekali. Baiklah, saya akan pakai ini saja.</p>

<p>Berhubung artikel ini sudah terlalu panjang. Implementasi Spring Integrationnya diteruskan di <a href="http://endy.artivisi.com/blog/java/integrasi-pusat-cabang-2">bagian kedua</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ejb-remote-clien/">Mengakses EJB Secara Remote</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-03T20:46:00+07:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mengakses EJB secara Remote</p>

<p>Beberapa buku tentang EJB, seperti EJB 3 in Action karangan Reza Rahman maupun Enterprise Java Beans 3.0 karangan Bill Burke, membahas secara detail tentang penggunaan EJB. Akan tetapi, ada satu hal kecil namun penting yang tidak dibahas. Bagaimana cara mengakses EJB secara remote?</p>

<p>Di sisi server, ini mudah. Cukup membuat remote interface saja beres. Tapi bagaimana cara lookupnya dari client? Artikel ini akan membahas cara memanggil EJB dari method main.</p>

<p>Sebelumnya, berikut adalah EJB yang akan kita panggil.</p>

<h3>HaloBean.java</h3>

<pre><code>package com.artivisi.belajar.ejb.session;

@Stateless
public class HaloBean implements HaloRemote {
   public String halo(String nama) {
     return "Halo "+nama;
   }
}
</code></pre>

<h3>HaloRemote.java</h3>

<pre><code>package com.artivisi.belajar.ejb.session;

@Remote
public interface HaloRemote {
   public String halo(String nama);
}
</code></pre>

<p>EJB ini akan kita deploy ke Glassfish menggunakan Netbeans. Bagaimana caranya? Silahkan buka menu Help Netbeans.</p>

<p>Berikut adalah kode untuk memanggil HaloBean secara remote.</p>

<h3>HaloClient.java</h3>

<pre><code>package com.artivisi.belajar.ejb.client;

public class HaloClient {
  public static void main(String[] args){
    // 0. Konfigurasi host dan port
    String ejbHost = "localhost";
    String ejbPort = 12345;
    String ejbName = HaloRemote.class.getName();

    // 1. JNDI Context
    Properties props = new Properties();
    props.put("org.omg.CORBA.ORBInitialHost", ejbHost);
    props.put("org.omg.CORBA.ORBInitialPort", ejbPort);

    InitialContext ctx = new InitialContext(props);

    // 2. Lookup EJB
    HaloRemote haloBean = (HaloRemote) ctx.lookup(ejbName);

    // 3. Panggil methodnya
    System.out.println("Halo EJB : "+haloBean.halo("endy"));
  }
}
</code></pre>

<p>Ada beberapa variabel yang perlu diperhatikan di sini, yaitu ejbHost, ejbPort, dan ejbName. Variabel ejbHost tentunya adalah komputer tempat EJB dideploy. Variabel ejbPort adalah port yang digunakan oleh Application Server untuk mempublish EJB. Port ini berbeda-beda tergantung merek application server dan cara deploymentnya. Karena saya menggunakan Netbeans untuk mendeploy ke Glassfish, maka saya harus cari tahu dulu berapa port yang digunakan Netbeans.</p>

<p>Caranya, login ke admin console Glassfish melalui Netbeans. Buka tab Services, klik kanan Glassfish, dan pilih View Admin Console.
(/images/uploads/2009/06/netbeans-view-admin-console.png)
Browser akan terbuka dan menampilkan halaman login Glassfish.
(/images/uploads/2009/06/glassfish-login.png)
Setelah login, klik Application Server di panel kiri. Port yang digunakan akan ditampilkan di panel kanan, yaitu dengan nama IIOP Port(s). Coba-coba saja semuanya. Di komputer saya, port yang benar adalah 10275.
(/images/uploads/2009/06/glassfish-iiop-port.png)
Variabel ejbName juga berbeda tergantung dari application server yang digunakan. Baca dokumentasi server Anda untuk memastikannya.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/lain/backup-mysql/">Backup MySQL</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-02T15:23:43+07:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sebelumnya, saya telah membahas script backup untuk <a href="http://endy.artivisi.com/blog/lain/backup-trac/">Trac</a> maupun <a href="http://endy.artivisi.com/blog/aplikasi/svn-parentpath-backup/">Subversion</a>. Kali ini, kita akan bahas backup script untuk MySQL.</p>

<p>Sama seperti backup script sebelumnya, script ini akan membuat folder sesuai dengan tanggal dan jam backup. Selanjutnya, script akan melakukan backup terhadap database MySQL sesuai dengan nama database yang ditentukan. Backup ini akan disimpan di folder yang kita tentukan.</p>

<p>Berikut backup scriptnya.</p>

<p>[Update - 7 Des 2009] Sudah ditambahkan perintah untuk kompresi hasil backupnya.</p>

<pre><code>#!/bin/sh

test -x /bin/date || exit -1
test -x /usr/bin/mysqldump || exit -1
test -x /bin/tar || exit -1
test -x /bin/bzip2 || exit -1

DBHOST=$1
DBNAME=$2
USERNAME=$3
PASSWORD=$4
BACKUP_FOLDER=$5
CURR_DATE="$(/bin/date +%Y%m%d-%H%M)"


if [ "$1" = '' ]; then
    echo "Usage : $0 &lt;db name&gt; &lt;username&gt; &lt;password&gt; &lt;backup folder&gt;"
    return 1
fi

if [ "$2" = '' ]; then
    echo "Usage : $0 &lt;db name&gt; &lt;username&gt; &lt;password&gt; &lt;backup folder&gt;"
    return 1
fi

if [ "$3" = '' ]; then
    echo "Usage : $0 &lt;db name&gt; &lt;username&gt; &lt;password&gt; &lt;backup folder&gt;"
    return 1
fi

if [ "$4" = '' ]; then
    echo "Usage : $0 &lt;db name&gt; &lt;username&gt; &lt;password&gt; &lt;backup folder&gt;"
    return 1
fi


echo "Create backup folder $BACKUP_FOLDER/$CURR_DATE"
echo "..."

/bin/mkdir "$BACKUP_FOLDER/$CURR_DATE"

echo "Backup $DBNAME schema to $BACKUP_FOLDER/$CURR_DATE/$DBNAME-schema-$CURR_DATE.sql"
echo "..."

/usr/bin/mysqldump $DBNAME -u $USERNAME -p$PASSWORD -h$DBHOST -d &gt; "$BACKUP_FOLDER/$CURR_DATE/$DBNAME-schema-$CURR_DATE.sql"

echo "Backup $DBNAME data to $BACKUP_FOLDER/$CURR_DATE/$DBNAME-data-$CURR_DATE.sql"
echo "..."

/usr/bin/mysqldump $DBNAME -u $USERNAME -p$PASSWORD -h $DBHOST -n -c -t --single-transaction &gt; "$BACKUP_FOLDER/$CURR_DATE/$DBNAME-data-$CURR_DATE.sql"

echo "Compressing folder $CURR_DATE"
echo "..."

/bin/tar cvf - "$BACKUP_FOLDER/$CURR_DATE" | /bin/bzip2 -c9 &gt; "$BACKUP_FOLDER/$CURR_DATE.tar.bz2"

echo "Removing folder $BACKUP_FOLDER/$CURR_DATE"
echo "..."

/bin/rm -rf "$BACKUP_FOLDER/$CURR_DATE"

echo "Completed"
</code></pre>

<p>Script di atas dapat dijalankan setiap Jumat malam jam 23.00 dengan konfigurasi sebagai berikut.</p>

<pre><code>0 23 * * 5 /bin/sh /path/ke/mysql-backup.sh db_user db_pass db_name backup_folder_mysql
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ssh-dengan-jsch/">SSH Dengan JSch</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-03T00:38:00+07:00" pubdate data-updated="true">May 3<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mengakses Remote Server dengan Java</p>

<p>Kita sudah biasa mengakses komputer lain menggunakan SSH.
Cukup ketikkan ssh username@namaserver, tekan enter, dan lakukan apa yang kita mau.
Nah, bagaimana kalau kita ingin membuat aplikasi yang butuh mengakses komputer lain?
Misalnya, kita ingin membuat aplikasi sederhana yang menampilkan input IP Address, Username, Password serta tombol Shutdown.
Begitu input field kita isi dan tombol Shutdown ditekan, aplikasi kita akan melakukan ssh ke komputer tersebut dan menjalankan perintah shutdown -h now.</p>

<p>Di Java, hal ini dapat dengan mudah dilakukan menggunakan pustaka <a href="http://www.jcraft.com/jsch/">JSch</a>. Berikut langkah-langkah untuk menggunakan JSch.</p>

<h2>Mendapatkan Pustaka JSch</h2>

<p>Tentunya yang pertama kita lakukan adalah membuka <a href="http://www.jcraft.com/jsch/">website JSch</a> dan mengunduh rilis terbaru. Pilih yang ZIP, jangan yang JAR, karena di dalamnya ada beberapa contoh penggunaan yang akan kita butuhkan untuk mencontek nantinya.</p>

<p>Paket ZIP ini belum dikompilasi, dan kita membutuhkan <a href="http://ant.apache.org">Ant</a> untuk melakukan proses build. Jika Anda belum pernah menggunakan Ant, baca dulu <a href="http://endy.artivisi.com/downloads/writings/Tutorial-Ant.pdf">tutorial ini</a>. Setelah proses build selesai dilakukan, akan muncul file *jar di dalam folder dist.</p>

<h2>Template Aplikasi Java</h2>

<p>Buatlah project Java menggunakan editor yang Anda sukai. Pastikan jar JSch sudah terdaftar di project Java yang barusan dibuat. Setelah itu, buatlah Java Class sebagai berikut</p>

<pre><code>public class JschDemo {
    public static void main(String[] args) throws Exception {

    }
}
</code></pre>

<p>Untuk selanjutnya, kode program akan ditulis di dalam method main.</p>

<h2>Parameter koneksi</h2>

<p>Untuk melakukan koneksi ke komputer lain, kita memerlukan beberapa variabel, ditunjukkan dengan kode sebagai berikut.</p>

<pre><code>String host = "localhost";
String user = "endy";
String pass = "java";
String command = "shutdown -h now";
</code></pre>

<p>Kita akan melakukan koneksi ke komputer kita sendiri (localhost) dengan username endy dan password java. Setelah berhasil terhubung, kita akan menjalankan perintah shutdown -h now.</p>

<h2>Pre Requisite</h2>

<p>Agar kode program kita bisa dijalankan, ada beberapa persyaratan sebagai berikut:</p>

<ul>
<li><p>Komputer yang ingin dihubungi harus menjalankan SSH server</p></li>
<li><p>Komputer yang ingin menghubungi harus melakukan koneksi SSH secara manual terlebih dulu,
agar komputer tujuan terdaftar di file known_hosts</p></li>
<li><p>User yang digunakan untuk koneksi harus memiliki akses yang cukup untuk melakukan perintah yang diinginkan</p></li>
</ul>


<h2>Menggunakan JSch</h2>

<p>Setelah parameter koneksi kita deklarasikan, dan juga prasyarat di komputer tujuan dipenuhi, sekarang kita bisa mulai menggunakan JSch.
Pertama, kita instankan dulu object dari class JSch.</p>

<pre><code>JSch jsch = new JSch();
</code></pre>

<p>Kemudian, kita berikan database known_hosts, yaitu daftar komputer tujuan beserta public keynya. Ini berguna untuk melakukan verifikasi terhadap komputer tujuan.</p>

<pre><code>jsch.setKnownHosts("/home/endy/.ssh/known_hosts");
</code></pre>

<p>File known_hosts ini akan otomatis dibuat bila kita melakukan koneksi SSH ke komputer lain. Itulah sebabnya kita harus melakukan koneksi manual terlebih dulu, sehingga public key komputer tujuan sudah terdaftar dalam file ini. Alternatif dari menggunakan file ini adalah <a href="http://endy.artivisi.com/blog/linux/login-ssh-dengan-private-key/">mendaftarkan public key di komputer tujuan dan menggunakan private key untuk login</a>.</p>

<p>Selanjutnya, kita membuka koneksi ke komputer tujuan</p>

<pre><code>Session session = jsch.getSession(user, host);
session.setPassword(pass);
session.connect();
</code></pre>

<p>Lalu, kita membuka channel. Channel menggambarkan bentuk interaksi kita dengan komputer tujuan. JSch menyediakan beberapa jenis channel, misalnya exec dan shell. Kita menggunakan exec untuk mengeksekusi satu perintah saja. Sedangkan shell bisa digunakan untuk membuka terminal interaktif yang bisa kita berikan perintah sebanyak kita mau.</p>

<pre><code>ChannelExec channel = (ChannelExec) session.openChannel("exec");
channel.setCommand(command);
channel.connect();
</code></pre>

<p>Kita bisa membaca output dari perintah yang kita jalankan menggunakan I/O Stream seperti biasa.</p>

<pre><code>BufferedReader reader = new BufferedReader(new InputStreamReader(channel.getInputStream()));
String output = reader.readLine();
while (output != null) {
    System.out.println(output);
    output = reader.readLine();
}
reader.close();
</code></pre>

<p>Segera setelah perintah selesai dijalankan, kita mengakhiri channel dan session.</p>

<pre><code>channel.disconnect();
session.disconnect();
</code></pre>

<p>Berikut adalah keseluruhan kode program.</p>

<pre><code>public class JschDemo {

    public static void main(String[] args) throws Exception {
    String host = "localhost";
    String user = "endy";
    String pass = "java";
    String command = "shutdown -h now";

        JSch jsch = new JSch();
        jsch.setKnownHosts("/home/endy/.ssh/known_hosts");

        Session session = jsch.getSession(user, host);
        session.setPassword(pass);
        session.connect();

        ChannelExec channel = (ChannelExec) session.openChannel("exec");
        channel.setCommand(command);
        channel.connect();

        BufferedReader reader = new BufferedReader(new InputStreamReader(channel.getInputStream()));
        String output = reader.readLine();
        while (output != null) {
            System.out.println(output);
            output = reader.readLine();
        }
        reader.close();

        channel.disconnect();
        session.disconnect();

    }
}
</code></pre>

<p>Selamat mencoba. Bila percobaan Anda sukses, komputer yang sedang Anda gunakan akan shutdown setelah aplikasi selesai dijalankan.
:D</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/10/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
    <a class="next" href="/page/8/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Endy Muhardin</h1>

<p>Software Developer berdomisili di Jabodetabek, berkutat di lingkungan open source, terutama Java dan Linux.</p>

<p>
    <ul>
        <li>
            <span class="icon-phone" style="text-align: left; width: 100%">&nbsp;
            +62 812 98000 468
            </span>
        </li>
        <li>
            <span class="icon-envelope" style="text-align: left; width: 100%">&nbsp;
                <a href="mailto:endy.muhardin@gmail.com">endy.muhardin@gmail.com</a>
            </span>
        </li>
        <li>
            <span class="icon-twitter" style="text-align: left; width: 100%">&nbsp;
                <a href="http://twitter.com/endymuhardin">@endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-github" style="text-align: left; width: 100%">&nbsp;
                <a href="https://github.com/endymuhardin">github.com/endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-facebook" style="text-align: left; width: 100%">&nbsp;
                <a href="http://facebook.com/endy.muhardin">facebook.com/endy.muhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-google-plus" style="text-align: left; width: 100%">&nbsp;
                <a href="http://google.com/+EndyMuhardin">google.com/+EndyMuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-linkedin" style="text-align: left; width: 100%">&nbsp;
                <a href="http://id.linkedin.com/pub/endy-muhardin/3/940/1bb">LinkedIn</a>
            </span>
        </li>
    </ul>
</p>
</section>

<section>

Bila artikel di website ini membantu meningkatkan penghasilan Anda, 
jangan ragu untuk memberikan donasi :)

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYByjmBHWB1u9oWkn33FHJ7Lu41iidZkdKLciblvSz2Oa/oBArw42F4/7nq3imMAWUvpA6Cx9zwNr3R7WqjnMlDr91VTkeyl1jusRB6Knw/JAaNI2yz20lbFtVNMhUrh2LJ6qXUwvdL4jvZeNUeOcvq/muETfy8BzgdKwCF3gNGpoTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQId7q7vUD8KwOAgaAyBdpVvmsdYWgKdVROwaJazFrOpQpWEncNGoycnyfeJRNwHXXZU1mj0oTJuvj/CUGr6cZC5RnQNBHC6FLnbjCVheTNtjBSs/CjD7HZMn28kElykLad2wDrFUsBkQCdRU43ZBLoRedRKbGVWP4wk6DgLovkwPzYNLKtl3clJbgm3UDXigmJqeAyvmafF2yk8LV4ACLTJtCu6qtSBVHkuUPToIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTMwNzExMDY0MjAwWjAjBgkqhkiG9w0BCQQxFgQUwzp1u86AW3VypUoSwjzfYA4KYn8wDQYJKoZIhvcNAQEBBQAEgYBExEV1zgHTrd+4zfXwIP0KO0/W7b4s2KDLbZ3Vq9FrtdtC9W3NEf6SbVZDYE+bEheP10XokfC8BslN7nZgsfPTvSNXv7ixfpWUVBb/gQB+QO70q1NZ2tuF2M/t1QzFUEZ9FeA0sgFMBS7nxmu7ynaSzez3B4FTG/jUzuRljVWhew==-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
</form>

</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/manajemen/tahapan-membuat-aplikasi/">Tahapan Membuat Aplikasi</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/aplikasi-prakarya-vs-aplikasi-production/">Aplikasi Prakarya vs Aplikasi Production</a>
      </li>
    
      <li class="post">
        <a href="/java/membuat-subreport-jasper-dalam-springmvc/">Membuat subreport Jasper dalam SpringMVC</a>
      </li>
    
      <li class="post">
        <a href="/linux/cara-mengetahui-ip-address-dari-mac-address/">Cara Mengetahui IP Address dari MAC Address</a>
      </li>
    
      <li class="post">
        <a href="/life/menjadi-mahasiswa-hi-tech/">Menjadi Mahasiswa Hi-Tech</a>
      </li>
    
      <li class="post">
        <a href="/java/silabus-kuliah-pemrograman/">Silabus Kuliah Pemrograman</a>
      </li>
    
      <li class="post">
        <a href="/javascript/javascript-development-stack/">JavaScript Development Stack</a>
      </li>
    
      <li class="post">
        <a href="/javascript/persiapan-coding-nodejs/">Persiapan Coding NodeJS</a>
      </li>
    
      <li class="post">
        <a href="/life/ongoing-learning/">Ongoing Learning</a>
      </li>
    
      <li class="post">
        <a href="/java/development-stack-2014/">Development Stack 2014</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
