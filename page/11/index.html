
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Pada rangkaian artikel sebelumnya, kita telah membahas tentang: Instalasi Ivy
Build Management dengan Ivy
Otomasi Build Process dengan Ant
Publish &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://software.endy.muhardin.com/page/11/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36102948-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:software.endy.muhardin.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="my_site_title">
            Living life and make it better
        </span>
       
           <span class="my_site_subtitle">
             life, learn, contribute
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/calendar">Calendar</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-8/">Membuat Mirror Repository Ivy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-10-05T14:30:53+07:00" pubdate data-updated="true">Oct 5<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada rangkaian artikel sebelumnya, kita telah membahas tentang:</p>

<ol>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-1">Instalasi Ivy</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-2">Build Management dengan Ivy</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-3">Otomasi Build Process dengan Ant</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-4">Publish Modul ke Repository</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-5">Deklarasi internal dependency</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-6">Deklarasi external dependency</a></p></li>
<li><p><a href="http://endy.artivisi.com/blog/java/ant-ivy-7">Ivy Configuration</a></p></li>
</ol>


<p>Semua konsep dan pengetahuan di atas memungkinkan kita untuk menggunakan Ivy secara efektif untuk mengelola pembuatan aplikasi. Tetapi ada sedikit hal yang masih mengganjal, yaitu borosnya bandwidth yang digunakan selama build process dilakukan.</p>

<p>Pada artikel kali ini, kita akan membahas cara membuat mirror repository, sehingga pengambilan artifak dapat dilakukan dari server internal maupun harddisk lokal, sehingga tidak memboroskan bandwidth.</p>

<p>Di artikel sebelumnya, kita telah membahas tentang deklarasi resolver. Resolver adalah konfigurasi yang menyatakan lokasi repository. Ada beberapa jenis resolver yang disediakan Ivy:</p>

<ul>
<li><p>Filesystem : repository Ivy di harddisk lokal</p></li>
<li><p>URL : repository Ivy yang diakses melalui protokol http</p></li>
<li><p>SSH : repository Ivy yang diakses melalui protokol scp/ssh</p></li>
<li><p>SFTP : repository Ivy, diakses melalui protokol sftp</p></li>
<li><p>VFS : repository Ivy, kompatibel dengan file system yang didukung oleh <a href="http://jakarta.apache.org/commons/vfs/">Apache Commons VFS</a>, diantaranya WebDAV, FTP, ZIP, <a href="http://jakarta.apache.org/commons/vfs/filesystems.html">dan sebagainya</a></p></li>
<li><p>Ibiblio : repository Maven 2, diakses melalui protokol http</p></li>
</ul>


<p>Sebagai contoh kasus, kita akan membuat mirror dari repository ivy milik SpringSource dan repository Maven2 di Ibiblio.</p>

<p>Pertama, kita deklarasikan dulu resolver untuk kedua repository sumber.
Konfigurasi ini dibuat dalam ivysettings.xml.</p>

<p>SpringSource memiliki dua repo berbeda, untuk artifak yang dihasilkannya sendiri (Spring Portfolio) disebut dengan release, dan untuk pustaka external (Hibernate, JSF, dsb; disebut dengan external. Berikut konfigurasi untuk kedua repo SpringSource, sesuai dengan <a href="http://www.springsource.com/repository/app/faq#q7">dokumentasinya</a>:</p>

<pre><code>&lt;url name="springsource.release.repo.resolver"&gt;
    &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/url&gt;

&lt;url name="springsource.external.repo.resolver"&gt;
    &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/url&gt;
</code></pre>

<p>Dan ini adalah resolver untuk Ibiblio.</p>

<pre><code>&lt;ibiblio name="maven2" m2compatible="true" /&gt;
</code></pre>

<p>Repository SpringSource akan kita mirror di <code>http://repo.artivisi.com/ivy/springsource/</code> dengan struktur folder <code>nama-organisasi/nama-modul/nomer-revisi/[artifak]-[revisi].[extension]</code>. Folder tersebut berada di mesin <code>repo.artivisi.com</code> dalam folder <code>/var/www/repo.artivisi.com/ivy/springsource</code>. Berikut konfigurasi repo mirror-springsource.</p>

<pre><code>&lt;ssh name="springsource.mirror.resolver" keyFile="${user.home}/.ssh/id_rsa" host="repo.artivisi.com" user="${mirror.host.user}"&gt;
    &lt;ivy pattern="/var/www/repo.artivisi.com/ivy/springsource/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact pattern="/var/www/repo.artivisi.com/ivy/springsource/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/ssh&gt;
</code></pre>

<p>Repository Ibiblio akan kita mirror di <code>http://repo.artivisi.com/ibiblio</code> dengan struktur folder berbeda, untuk metadata sebagai berikut: <code>[nama-organisasi]/[nama-modul]/ivys/ivy-[nomer-revisi].xml</code>, dan untuk artifak sebagai berikut: <code>[nama-organisasi]/[nama-modul]/[jenis]s/[artifak]-[nomer-revisi].[extension]</code>. Folder tersebut berada di mesin <code>repo.artivisi.com</code> dalam folder <code>/var/www/repo.artivisi.com/ibiblio</code>. Berikut konfigurasinya:</p>

<pre><code>&lt;ssh name="ibiblio.mirror.resolver" keyFile="${user.home}/.ssh/id_rsa" host="repo.artivisi.com" user="${mirror.host.user}"&gt;
    &lt;ivy pattern="/var/www/repo.artivisi.com/ibiblio/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;
    &lt;artifact pattern="/var/www/repo.artivisi.com/ibiblio/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;
&lt;/ssh&gt;
</code></pre>

<p>Setelah kita memiliki dua repository sumber dan dua repository tujuan, kita buat target untuk melakukan mirroring. Di Ivy, kegiatan mirroring ini disebut dengan istilah install. Kita memiliki tiga target install, untuk ibiblio, SpringSource release, dan SpringSource external. Berikut deklarasi targetnya, kita masukkan di <code>ivybuilder.xml</code> bersama dengan target untuk resolve dan publish.</p>

<pre><code>&lt;target name="install-springsource-release" description="--&gt; install dependency from springsource repo"&gt;
    &lt;ivy:install 
        organisation="${organisation}" 
        module="${module}" 
        revision="${revision}"
        from="${springsource.release.repo.resolver}" 
        to="${springsource.mirror.resolver}" 
        transitive="true"
        overwrite="true"
    /&gt;  
&lt;/target&gt;

&lt;target name="install-springsource-external" description="--&gt; install dependency from springsource repo"&gt;
    &lt;ivy:install
        organisation="${organisation}" 
        module="${module}" 
        revision="${revision}"
        from="${springsource.external.repo.resolver}" 
        to="${springsource.mirror.resolver}" 
        transitive="true"
        overwrite="true"
    /&gt;

&lt;/target&gt;

&lt;target name="install-ibiblio" description="--&gt; install dependency from ibiblio maven2 repo"&gt;
    &lt;ivy:install 
        organisation="${organisation}" 
        module="${module}" 
        revision="${revision}"
        from="${ibiblio.repo.resolver}" 
        to="${ibiblio.mirror.resolver}" 
        transitive="true"
        overwrite="true"
    /&gt;
&lt;/target&gt;
</code></pre>

<p>Seperti kita lihat di atas, deklarasi target install cukup generik, dengan menggunakan variabel yang bisa di-override pada saat runtime. Untuk target <code>install-springsource-external</code>, kita gunakan repo external SpringSource sebagai sumber, dan mirror-springsource sebagai tujuan. Target <code>install-springsource-release</code> dan <code>install-ibiblio</code> juga mirip.</p>

<p>Sekarang saatnya kita coba. Mari kita install Hibernate Annotations versi 3.3.1.GA. Modul ini ada di repository SpringSource external.</p>

<p>Langkah pertama, cari dulu modul yang kita inginkan. Kita bisa gunakan <a href="http://www.springsource.com/repository">halaman search yang telah disediakan</a>. Dari <a href="http://www.springsource.com/repository/app/bundle/version/detail?name=com.springsource.org.hibernate.annotations&amp;version=3.3.1.ga">hasil pencarian</a>, kita menemukan modul yang diinginkan, berikut dengan deklarasi dependensinya. Sekarang kita telah mengetahui nama organisasi, nama modul, dan nomer revisinya.</p>

<pre><code>ant install-springsource-external -Dorganisation="org.hibernate" -Dmodule="com.springsource.org.hibernate.annotations" -Drevision="3.3.1.ga"
</code></pre>

<p>Ivy akan melakukan resolve dan melihat semua dependensi dari Hibernate Annotations versi 3.3.1.GA. Setelah itu, Ivy akan mendonlodnya ke cache lokal, untuk kemudian diupload melalui scp ke lokasi mirror.</p>

<p>Terakhir, tentunya mirror repository ini akan diakses orang menggunakan http, bukan ssh. Jadi kita harus buatkan resolver untuk mengakses <code>http://repo.artivisi.com/ivy/springsource</code> dan <code>http://repo.artivisi.com/ibiblio</code>. Berikut konfigurasinya, kita satukan menggunakan chain-resolver.</p>

<p>Demikianlah rangkaian tutorial tentang penggunaan Ivy. Mungkin banyak pembaca yang membatin,</p>

<blockquote><p>Buat apa repot-repot, pakai Netbeans atau Eclipse kan juga bisa bikin jar/war.</p></blockquote>

<p>Biar saya kasih bocoran sedikit tentang dapur ArtiVisi. Kami akan mengadopsi SOA (Service Oriented Architecture) dalam semua produk dan project kami. Adopsi ini dilakukan di level mikro dengan menggunakan platform OSGi. Karakteristik utama aplikasi SOA dengan OSGi adalah aplikasi akan terdiri dari banyak modul-modul kecil yang saling berinteraksi. Contohnya bisa dilihat di diagram modul yang disajikan di awal artikel.</p>

<p>Memecah aplikasi besar menjadi modul-modul kecil tidak terlalu sulit. Siapapun yang mengenal keyword <code>import</code> dan konsep CLASSPATH di Java bisa melakukannya. Yang sulit adalah mengelola kegiatan development dan integrasi antar modul. Oleh karena itu, penggunaan dependency management seperti Ivy atau Maven2 adalah hal yang wajib.</p>

<p>Pembaca bisa memilih apakah akan menggunakan Maven2 ataupun Ivy. Konsep dasarnya mirip, tapi implementasinya berbeda. Jadi, kalau sudah menguasai Ivy, Maven2 tidak sulit. Demikian juga sebaliknya. Silahkan mencari yang sesuai dengan kebutuhan tim Anda.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-7/">Ivy Configuration</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-10-03T17:55:34+07:00" pubdate data-updated="true">Oct 3<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Rangkaian <a href="http://endy.artivisi.com/blog/java/ant-ivy-6/">artikel sebelumnya</a> telah memberikan kita pemahaman yang memadai untuk menggunakan Ivy. Pada artikel ini, kita akan membahas satu fitur Ivy yang walaupun tidak wajib dikuasai, tapi sangat penting, karena dapat membuat konfigurasi modul kita menjadi fleksibel. Fitur ini dalam dunia Ivy dikenal dengan istilah <code>configuration</code>.</p>

<p>Sebagai paket standar kualitas di ArtiVisi, kami menggunakan Cobertura untuk melakukan coverage test. Sayangnya Cobertura dan Hibernate tidak kompatibel. Hibernate menggunakan pustaka <code>asm</code> dengan versi 1.5.3. Sedangkan Cobertura juga menggunakan <code>asm</code>, dengan versi 2.2.1. Bila kedua versi kita campur, maka akan terjadi error karena Java VM kebingungan menentukan versi mana yang akan digunakan.</p>

<p>Untuk mengatasi masalah ini, kita menggunakan fitur <code>configuration</code> Ivy. Kita membuat konfigurasi bernama <code>test</code> yang membawa <code>asm</code> versi 2.2.1 sesuai kebutuhan Cobertura. Selain itu, kita juga membuat konfigurasi bernama <code>runtime</code> dengan <code>asm</code> versi 1.5.3 untuk digunakan Hibernate. Hal ini dimungkinkan karena Cobertura hanya kita gunakan pada saat test.</p>

<p>Contoh lain penggunaan <code>configuration</code> adalah kombinasi modul untuk merakit aplikasi. Misalnya, kita memiliki modul-modul berikut dalam aplikasi kita:</p>

<ul>
<li><p>model</p></li>
<li><p>dao.api</p></li>
<li><p>dao.hibernate</p></li>
<li><p>dao.jdbc</p></li>
<li><p>ui.web</p></li>
<li><p>ui.desktop</p></li>
</ul>


<p>Kita dapat menggunakan konfigurasi Ivy untuk membentuk 4 kombinasi aplikasi, yaitu:</p>

<ul>
<li><p>Desktop dengan JDBC</p></li>
<li><p>Desktop dengan Hibernate</p></li>
<li><p>Web-based dengan JDBC</p></li>
<li><p>Web-based dengan Hibernate</p></li>
</ul>


<p>Fitur configuration juga bisa digunakan untuk mengatur rilis artifak, sehingga dari satu paket source-code, kita bisa membuat rilis:</p>

<ul>
<li><p>Hanya source-code (source only)</p></li>
<li><p>Hanya hasil kompilasi (binary only)</p></li>
<li><p>Paket dokumentasi (javadoc, reference)</p></li>
<li><p>Paket komplit (source, binary, dokumentasi)</p></li>
</ul>


<p>Kombinasi rilis ini umum kita temui dalam pustaka open-source populer seperti Spring Framework atau Hibernate.</p>

<p>Masih banyak lagi skenario penggunaan configuration. Silahkan kembangkan imajinasi Anda untuk penggunaannya. Pada artikel ini, kita akan membahas skenario kombinasi aplikasi seperti ilustrasi di atas.</p>

<p>Kita telah memiliki modul person-model, dengan deklarasi dependensi (ivy.xml) sebagai berikut:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-model"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="api"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

&lt;/ivy-module&gt;
</code></pre>

<p>Daftar konfigurasi yang kita miliki didefinisikan dalam file ivyconfigurations.xml dan di-include dari masing-masing ivy.xml. Berikut isi ivyconfigurations.xml.</p>

<pre><code>&lt;configurations&gt;
    &lt;conf name="compile"            description="dependency for compile time only" /&gt;
    &lt;conf name="api"     description="Domain Model and API only"/&gt;
    &lt;conf name="impl"    description="implementation of APIs"/&gt;
    &lt;conf name="source"  description="source code only"/&gt;
&lt;/configurations&gt;
</code></pre>

<p>Kita juga punya modul person-dao, interface yang digunakan sebagai patokan implementasi akses database, dengan dependensi sebagai berikut:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-dao-api"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="api"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

    &lt;dependencies&gt;
        &lt;dependency name="person-model" rev="latest.integration" conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Modul person-dao ini memiliki dua jenis implementasi, yaitu dengan JDBC:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-dao-jdbc"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="impl"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

        &lt;dependency name="person-dao-api" rev="latest.integration" conf="api"/&gt;

    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>dan dengan Hibernate:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-dao-hibernate"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="impl"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

        &lt;dependency name="person-dao-api" rev="latest.integration" conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Dengan memisahkan interface dan implementasi DAO, kita bisa langsung membuat dua jenis user interface, yaitu yang berbasis web sebagai berikut:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-ui-springmvc"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="impl"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

        &lt;dependency name="person-dao-api" rev="latest.integration"  conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>dan berbasis desktop sebagai berikut:</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-ui-swing"/&gt;

    &lt;configurations&gt;
        &lt;include file="${basedir}/../person-build/ivy/ivyconfigurations.xml" /&gt;
    &lt;/configurations&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="impl"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

        &lt;dependency name="person-dao-api" rev="latest.integration"  conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Seperti kita lihat, untuk bisa membuat UI, kita hanya membutuhkan modul dao saja.</p>

<p>Untuk merangkai aplikasi ini, kita membuat satu modul yang tidak berisi source-code Java sama sekali, melainkan hanya deklarasi dependensi saja.</p>

<p>Berikut konfigurasi untuk aplikasi desktop dengan JDBC.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-apps"/&gt;

    &lt;configurations&gt;
        &lt;conf name="person-app-desktop-jdbc" description="Application with desktop UI and JDBC backend"/&gt;
    &lt;/configurations&gt;

    &lt;dependencies&gt;

        &lt;dependency name="person-dao-jdbc" rev="latest.integration" 
        conf="person-app-desktop-jdbc-&gt;impl"/&gt;

        &lt;dependency name="person-ui-swing" rev="latest.integration" 
        conf="person-app-desktop-jdbc-&gt;impl"/&gt;

    &lt;/dependencies&gt;

&lt;/ivy-module&gt;
</code></pre>

<p>dan ini adalah konfigurasi untuk aplikasi web dengan Hibernate.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-apps"/&gt;

    &lt;configurations&gt;
        &lt;conf name="person-app-web-hibernate" description="Application with web-based UI and Hibernate backend"/&gt;
    &lt;/configurations&gt;

    &lt;dependencies&gt;

        &lt;dependency name="person-dao-hibernate" rev="latest.integration" 
        conf="person-app-web-hibernate-&gt;impl"/&gt;

        &lt;dependency name="person-ui-springmvc" rev="latest.integration" 
        conf="person-app-web-hibernate-&gt;impl"/&gt;


    &lt;/dependencies&gt;

&lt;/ivy-module&gt;
</code></pre>

<p>Deklarasi lengkap konfigurasi dan dependensi untuk keempat kombinasi aplikasi sebagai berikut.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-apps"/&gt;

    &lt;configurations&gt;
        &lt;conf name="person-app-web-jdbc" description="Application with web-based UI and JDBC backend"/&gt;
        &lt;conf name="person-app-desktop-jdbc" description="Application with desktop UI and JDBC backend"/&gt;
        &lt;conf name="person-app-web-hibernate" description="Application with web-based UI and Hibernate backend"/&gt;
        &lt;conf name="person-app-desktop-hibernate" description="Application with desktop UI and Hibernate backend"/&gt;
    &lt;/configurations&gt;

    &lt;dependencies&gt;

        &lt;dependency name="person-model" rev="latest.integration" conf="*-&gt;api"/&gt;

        &lt;dependency name="person-dao-api" rev="latest.integration" conf="*-&gt;api"/&gt;

        &lt;dependency name="person-dao-jdbc" rev="latest.integration" 
        conf="person-app-web-jdbc-&gt;impl;person-app-desktop-jdbc-&gt;impl"/&gt;

        &lt;dependency name="person-dao-hibernate" rev="latest.integration" 
        conf="person-app-web-hibernate-&gt;impl;person-app-desktop-hibernate-&gt;impl"/&gt;

        &lt;dependency name="person-ui-swing" rev="latest.integration" 
        conf="person-app-desktop-jdbc-&gt;impl;person-app-desktop-hibernate-&gt;impl"/&gt;

        &lt;dependency name="person-ui-springmvc" rev="latest.integration" 
        conf="person-app-web-jdbc-&gt;impl;person-app-web-hibernate-&gt;impl"/&gt;


    &lt;/dependencies&gt;

&lt;/ivy-module&gt;
</code></pre>

<p>Kita dapat merakit aplikasi dengan ant sebagai berikut</p>

<pre><code>ant resolve
</code></pre>

<p>Nanti pada folder lib akan terbentuk empat folder sesuai konfigurasi. Isi dari masing-masing folder mencerminkan paket aplikasi sesuai kombinasi yang kita inginkan.</p>

<p>Seperti kita lihat, dengan menggunakan fitur configuration, kita dapat merangkai empat kombinasi aplikasi dengan mudah. Tentunya aplikasi kita harus dirancang secara modular supaya mudah dikombinasikan seperti cerita di atas.</p>

<p><a href="http://endy.artivisi.com/blog/java/ant-ivy-8/">Artikel berikutnya</a> akan menutup seri Ivy ini dengan cara membuat repository dalam organisasi kita. Dengan adanya repository lokal, kita dapat menghemat bandwidth internasional karena kebutuhan dependensi dapat ditangani oleh server internal.</p>

<p>Kita akan melihat kemampuan Ivy untuk mengadaptasi repository baik yang memiliki metadata Ivy, maupun Maven.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-6/">External Dependency Dengan Ivy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-10-01T17:06:24+07:00" pubdate data-updated="true">Oct 1<span>st</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-5/">artikel sebelumnya</a>, kita telah menghubungkan dua modul berbeda dengan deklarasi dependensi. Tapi hal itu belum cukup, karena pada aplikasi yang sebenarnya, kita akan banyak menggunakan pustaka yang tidak kita buat sendiri.</p>

<p>Agar kita bisa menggunakan pustaka luar tersebut, kita harus mengetahui alamat repository yang menyimpan pustaka yang kita inginkan, berikut dependensinya. Misalnya, bila kita ingin menggunakan Hibernate, kita harus mengetahui repository yang memuat artifak hibernate.jar dan juga dependensinya seperti asm.jar, cglib.jar, dan segudang *.jar lainnya.</p>

<p>Selanjutnya, untuk menghemat bandwidth perusahaan, kita dapat menaruh pustaka yang sering digunakan tersebut dalam jaringan perusahaan. Dengan demikian semua orang yang akan menggunakan *.jar tersebut tidak perlu mendonlod dari lokasi asalnya, tapi cukup dari jaringan lokal. Pembuatan mirror ini akan kita diskusikan di artikel terakhir dalam seri ini.</p>

<p>Ada dua masalah utama yang kita hadapi dalam menggunakan pustaka luar. Pertama, bagaimana mencari dan memilih repository yang baik. Kedua, bagaimana mendaftarkannya dalam project kita.</p>

<p>Mencari dan memilih repository merupakan hal yang krusial. Para pengguna Maven, tools untuk dependency management seperti Ivy, memiliki repository yang dapat diakses melalui internet. Akan tetapi, ada satu masalah besar, isinya tidak lengkap dan deklarasi metadatanya banyak yang berantakan. Sebagai ilustrasi, dari dokumentasi Hibernate kita mengetahui bahwa hibernate.jar membutuhkan asm.jar, commons-collection.jar, dan cglib.jar. Tapi di repository Maven, kadang hanya tersedia asm.jar. Artifak commons-collection.jar ada di deklarasi dependensi, tapi filenya tidak ada. Bahkan cglib.jar sama sekali tidak dicantumkan dalam deklarasi dependensi. Nah, kira-kira seperti itulah kondisi repository yang tidak dipelihara dengan baik. Metadata dependensinya tidak akurat, dan koleksi artifaknya tidak lengkap.</p>

<p>Untungnya &#8211;SpringSource, perusahaan yang membekingi Spring Framework&#8211; telah membuatkan <a href="http://www.springsource.com/repository/">repository</a> yang cukup mumpuni. Mereka menjamin bahwa repository tersebut transitively complete. Artinya, bila hibernate.jar membutuhkan commons-collection.jar dan commons-collection.jar membutuhkan commons-lang.jar, kita bisa yakin bahwa ketiga .jar tersebut ada dalam repository. SpringSource menyediakan metadata untuk ivy dan maven2. Jadi selain kita pengguna Ivy, pengguna Maven2 juga bisa menggunakan repository tersebut. Semua *.jar yang ada dalam repo ini sudah dijamin OSGi compliant. Ini akan sangat berguna apabila kita membangun di platform OSGi. Yang paling penting, repository ini memiliki fasilitas pencarian.</p>

<p>Bila dependensi yang kita inginkan tidak tersedia di repository SpringSource, kita masih dapat mencari ke repository Maven2 yang disediakan oleh ibiblio.</p>

<p>Baiklah, masalah pertama sudah terpecahkan. Sekarang mari kita selesaikan masalah kedua, yaitu menggunakan kedua repository tersebut dalam aplikasi kita.</p>

<p>Repository ini, sama dengan internal repository yang sudah kita bahas pada artikel terdahulu, akan dideklarasikan dalam file ivysettings.xml. Berikut adalah entri untuk repository SpringSource.</p>

<pre><code>&lt;url name="springsource.release.repo.resolver"&gt;
    &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/url&gt;

&lt;url name="springsource.external.repo.resolver"&gt;
    &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/url&gt;
</code></pre>

<p>Cara konfigurasi ini juga bisa dilihat di situs repository SpringSource.
Dan ini adalah konfigurasi untuk repository iBiblio.</p>

<pre><code>&lt;ibiblio name="maven2" m2compatible="true" /&gt;
</code></pre>

<p>Kita dapat menyuruh Ivy untuk terlebih dulu mencari di repo SpringSource. Bila ditemukan, hentikan pencarian. Bila tidak ditemukan, lanjutkan ke iBiblio. Untuk mengaktifkan mekanisme ini, gunakan ChainResolver sebagai berikut.</p>

<pre><code>&lt;chain name="external-repository"&gt;

    &lt;chain name="springsource-repository" returnFirst="true"&gt;
        &lt;url name="springsource.release.repo.resolver"&gt;
            &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
            &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
        &lt;/url&gt;
        &lt;url name="springsource.external.repo.resolver"&gt;
            &lt;ivy pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
            &lt;artifact pattern="http://repository.springsource.com/ivy/bundles/external/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
        &lt;/url&gt;
    &lt;/chain&gt;

    &lt;chain name="ibiblio.repo.resolver"&gt;
        &lt;ibiblio name="maven2" m2compatible="true" /&gt;
    &lt;/chain&gt;

&lt;/chain&gt;
</code></pre>

<p>Atribut <code>returnFirst</code> digunakan untuk menghentikan pencarian bila artifak sudah ditemukan.</p>

<p>Setelah repository kita daftarkan, kita tinggal mengkonfigurasi dependensi di project kita. Modul person-dao-impl akan menggunakan Spring Framework 2.5.5.A dan juga Hibernate 3.2.6.ga. Kita dapat mencari di situs repository SpringSource untuk mendapatkan deklarasi dependensi yang sesuai untuk <a href="http://www.springsource.com/repository/app/search?query=spring">Spring Framework</a> dan <a href="http://www.springsource.com/repository/app/search?query=hibernate">Hibernate</a>.</p>

<p>Berikut adalah file ivy.xml dari modul person-dao-impl.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="com.artivisi.tutorial.ivy.dao.impl"/&gt;
    &lt;publications&gt;    
        &lt;artifact name="${ant.project.name}"/&gt;
        &lt;artifact name="${ant.project.name}-sources" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

    &lt;dependencies&gt;

        &lt;dependency
            org="com.artivisi"
            name="com.artivisi.tutorial.ivy.dao.api"
            rev="latest.integration"
        /&gt;

        &lt;dependency 
            org="org.springframework" 
            name="org.springframework.orm" 
            rev="2.5.5.A"
        /&gt;

        &lt;dependency 
            org="org.hibernate" 
            name="com.springsource.org.hibernate" 
            rev="3.2.6.ga"
        /&gt;

    &lt;/dependencies&gt;

&lt;/ivy-module&gt;
</code></pre>

<p>Terlihat dari ivy.xml bahwa modul ini memiliki dependensi terhadap modul person-dao-api, yang mana memiliki dependensi terhadap person-model. Dengan fitur transitive-dependency yang dimiliki Ivy, kita tidak perlu mendeklarasikan dependensi terhadap person-model, karena sudah secara otomatis didaftarkan melalui person-dao-api.</p>

<p>Modul ini memiliki satu source code, yaitu PersonDaoHibernate, sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.dao.impl;

import java.util.List;

import com.artivisi.tutorial.ivy.model.Person;
import com.artivisi.tutorial.ivy.dao.PersonDao;

@Transactional
public class PersonDaoHibernate implements PersonDao {

    private SessionFactory sessionFactory;

    @Autowired
    public void setSessionFactory(SessionFactory sf) {
        this.sessionFactory = sf;
    }

    public void save(Person person) {
        sessionFactory.getCurrentSession()
        .saveOrUpdate(person);
    }

    @SuppressWarnings("unchecked")      
    public List&lt;Person&gt; getAll(){
        return sessionFactory.getCurrentSession()
        .createCriteria(Person.class)
        .list();
    }

    public Person getById(Long id){
        return (Person) sessionFactory.getCurrentSession()
        .get(Person.class, id);
    }
}
</code></pre>

<p>Seperti kita lihat, kode program tersebut menggunakan @Transactional dari Spring Framework, dan SessionFactory milik Hibernate. Mari kita lakukan kompilasi.</p>

<pre><code>ant build
</code></pre>

<blockquote><p>PERHATIAN!!! Perintah build ini akan mengakses internet dan mendonlod semua *.jar yang dibutuhkan. Ini akan memakan banyak bandwidth internasional Anda.</p></blockquote>

<p>Dari output kita bisa lihat bahwa Ivy menemukan dependensi yang dibutuhkan di repository SpringSource, dan kemudian mendonlodnya. Hasil donlod akan disimpan dalam cache, sehingga bila kita melakukan build lagi, tidak perlu mendonlod berkali-kali.</p>

<p>Demikianlah penjelasan tentang dependensi eksternal. Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-7/">artikel selanjutnya</a>, kita akan bahas tentang configuration, fitur yang sangat canggih dari Ivy.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-5/">Internal Dependency Dengan Ivy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-28T16:51:32+07:00" pubdate data-updated="true">Sep 28<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-4/">artikel sebelumny</a>a, kita telah menyimpan artifact modul person-model di shared repository melalui mekanisme scp dengan private key. Pada artikel ini, kita akan menggunakan artifact person-model tersebut dalam modul person-dao-api. Pengambilan artifact dilakukan melalui mekanisme yang sama, yaitu scp dengan private key.</p>

<p>Berikut struktur folder modul person-dao-api.</p>

<p><img src="/images/uploads/2008/09/folder-person-dao-api-before-resolve.png" title="" ></p>

<p>Kita memiliki folder src yang berisi source code class <code>PersonDao.java</code>, yang isinya sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.dao;

import java.util.List;

import com.artivisi.tutorial.ivy.model.Person;

public interface PersonDao {

    /**
     * saves Person object into database. 
     * If object is already exists (denoted by not-null ID field), 
     * the existing record with the corresponding ID is updated. 
     * If the object is new (denoted by null ID field), 
     * new record is inserted.
     * 
     *  This method also set the ID field for new record.
     * */
    public void save(Person person);

    /**
     * fetch all person object in database.
     * @return List of all person
     * */
    public List getAll();

    /**
     * fetch Person object with the speficied ID. 
     * @param id identifier for person object
     * @return Person object if there is record found for the speficied id, null otherwise
     * */
    public Person getById(Long id);
}
</code></pre>

<p>Seperti terlihat dalam deklarasi import, class ini menggunakan class <code>Person</code>, yang sudah tersedia di shared repository. Kita akan melakukan build dengan menggunakan script <code>build.xml</code>. Isinya sama dengan yang ada di modul person-model, dengan perkecualian nama projectnya. Berikut isi <code>build.xml</code>.</p>

<pre><code>&lt;project name="person-dao-api" default="build"&gt;

    &lt;property file="build.properties"/&gt;

    &lt;import file="${basedir}/../person-build/default.xml"/&gt;
    &lt;import file="${basedir}/../person-build/ivy-builder.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>Dependensi modul <code>person-dao-api</code> terhadap <code>person-model</code> kita deklarasikan dalam <code>ivy.xml</code> sebagai berikut.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="person-dao-api"/&gt;

    &lt;publications&gt;
        &lt;artifact name="${ant.project.name}" conf="api"/&gt;
        &lt;artifact name="${ant.project.name}-sources" conf="source" type="src" ext="jar"/&gt;
    &lt;/publications&gt;

    &lt;dependencies&gt;
        &lt;dependency name="person-model" rev="latest.integration" conf="api"/&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Setelah <code>build.xml</code> dan <code>ivy.xml</code> selesai dibuat, kita bisa langsung melakukan build. Panggil target dari command line sebagai berikut:</p>

<pre><code>ant build
</code></pre>

<p>Dari output perintah di atas terlihat bahwa Ivy akan menguraikan dependensi project dengan melakukan query ke semua resolver yang terdaftar. Setelah modul yang dibutuhkan (person-model) ditemukan, Ivy akan langsung mendonlodnya ke dalam folder lib. Karena isi folder lib sudah kita daftarkan ke dalam classpath, maka proses kompilasi akan berjalan dengan mulus. Berikut struktur folder <code>person-dao-api</code> setelah melakukan proses resolve.</p>

<p><img src="/images/uploads/2008/09/folder-person-dao-api-after-resolve.png" title="" ></p>

<p>Pada deklarasi dependensi di atas, terlihat bahwa modul <code>person-dao-api</code> memiliki dependensi terhadap modul <code>person-model</code> dengan revision <code>latest.integration</code>. Ini artinya Ivy akan menggunakan versi terbaru yang ada dalam repository. Untuk melihat kemampuan fitur ini, mari kita publish <code>person-model</code> dengan revision yang lebih baru.</p>

<p>Edit file build.properties dalam modul person-model, sehingga menjadi seperti ini.</p>

<pre><code>build.version = 0.0.2
release.type = integration
</code></pre>

<p>Setelah itu, bersihkan hasil kompilasi terdahulu, dan publish modul <code>person-model</code>.</p>

<pre><code>ant clean publish-local
</code></pre>

<p>Lalu, pindah ke modul person-dao-api, dan lakukan build lagi.</p>

<pre><code>ant clean build
</code></pre>

<p>Terlihat pada output, bahwa modul <code>person-model</code> yang terbaru akan didonlod, dan yang versi lama akan dihapus. Sehingga isi folder lib akan terlihat sebagai berikut.</p>

<p>Ivy memiliki beberapa cara untuk menentukan mana artifak yang terbaru (latest), yaitu: latest-time, latest-revision, dan latest-lexico.</p>

<p>Dengan menggunakan latest-time, Ivy akan melihat tanggal dibuatnya suatu artifak. Kalau artifak berada di repository filesystem, maka tanggal sistem operasi akan digunakan. Bila repository diakses melalui http, Ivy akan melakukan query terhadap http server. Metode ini, walaupun efektif, relatif lambat bila akses jaringan ke repository tidak mumpuni.</p>

<p>Latest-revision membandingkan nama versi artifak, dan mengenali beberapa keyword. Dia dapat menentukan bahwa versi 1.0-alpha lebih baru daripada 1.0-dev1, dan 1.0 lebih baru daripada 1.0-rc1.</p>

<p>Sedangkan strategi latest-lexico hanya membandingkan berdasarkan urutan abjad. Jadi, 1.0-m1 akan lebih baru daripada 1.0-build135.</p>

<p>Ketiga strategi tersebut sudah built-in dalam Ivy dan tidak memerlukan konfigurasi lebih lanjut.</p>

<p>Selain revision, Ivy juga mengenal terminologi status. Secara default, Ivy menyediakan tiga status diurutkan dari yang paling stabil/mature, yaitu release, milestone, dan integration. Bila kita menggunakan latest.integration, Ivy akan mengambil artifak terbaru berstatus apapun dari repository. Bila kita gunakan latest.milestone, Ivy akan mengabaikan rilis integration, dan hanya akan membandingkan milestone dan release. Demikian juga bila kita gunakan latest.release, maka versi terbaru hanya akan dicari dari artifak berstatus release.</p>

<p>Cara deklarasi latest.integration di atas disebut dengan dynamic revision, karena nomer revision tidak secara eksplisit disebutkan. Selain menggunakan latest.integration, ada beberapa mekanisme lain, yaitu menggunakan +, dan menggunakan range.</p>

<p>Kita bisa menggunakan + untuk memilih revisi terbaru untuk rilis tertentu. Misalnya bila kita memiliki modul dengan revisi 1.0.1, 1.0.4, 1.0.7, dan 1.1.4 dalam repository, kita dapat menggunakan 1.0.+ untuk memilih versi terbaru dalam lini 1.0, yaitu 1.0.7.</p>

<p>Kita juga bisa menggunakan range, untuk menentukan revisi yang dapat digunakan, misalnya [1.0,2.2] akan memilih semua revisi yang sama atau lebih besar dari 1.0, tapi lebih kecil atau sama dengan 2.2. Lebih lengkap tentang ini bisa dilihat di dokumentasi Ivy tentang dependensi.</p>

<p>Demikianlah deklarasi dependensi dengan Ivy. Pada artikel ini, kita baru mencoba dependensi terhadap modul yang kita buat sendiri. Di <a href="http://endy.artivisi.com/blog/java/ant-ivy-6/">artikel selanjutnya</a>, kita akan lihat bagaimana mendeklarasikan dependensi terhadap modul eksternal seperti Spring Framework atau Hibernate.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-4/">Publish Modul Ke Repository</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-10T16:57:41+07:00" pubdate data-updated="true">Sep 10<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Template project sudah dibuat pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-3/">artikel sebelumnya</a>. Pada artikel ini, kita akan menghubungkan kedua modul ini dengan menggunakan Ivy.</p>

<p>Seperti kita ketahui, modul <code>person-dao-api</code> mempunyai dependensi terhadap modul <code>person-model</code>. Berikut gambarnya.</p>

<p><img src="/images/uploads/2008/09/dep-after.png" title="" ></p>

<p>Dependensi ini terlihat di source-code <code>PersonDao.java</code>, yang melakukan import terhadap class Person, sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.dao;

import java.util.List;

import com.artivisi.tutorial.ivy.model.Person;

public interface PersonDao {

    /**
     * saves Person object into database. 
     * If object is already exists (denoted by not-null ID field), 
     * the existing record with the corresponding ID is updated. 
     * If the object is new (denoted by null ID field), 
     * new record is inserted.
     * 
     *  This method also set the ID field for new record.
     * */
    public void save(Person person);

    /**
     * fetch all person object in database.
     * @return List of all person
     * */
    public List getAll();

    /**
     * fetch Person object with the speficied ID. 
     * @param id identifier for person object
     * @return Person object if there is record found for the speficied id, null otherwise
     * */
    public Person getById(Long id);
}
</code></pre>

<p>Agar class diatas bisa dikompilasi dengan lancar, ada tiga hal yang harus dilakukan:</p>

<ol>
<li><p>Menyediakan lokasi yang dapat diakses oleh kedua modul</p></li>
<li><p>Mempublikasikan distribusi modul person-model</p></li>
<li><p>Mendeklarasikan dependensi person-dao-api terhadap person-model</p></li>
</ol>


<h3>Repository Ivy</h3>

<p>Dalam dunia Ivy, file-file distribusi suatu modul, seperti <code>person-model.jar</code>, <code>person-model-sources.jar</code>, disebut dengan istilah artifact.
Artifact ini diletakkan di lokasi tertentu, disebut dengan istilah repository. Konfigurasi tentang cara mengakses suatu repository disebut dengan istilah resolver. Ivy menyediakan berbagai resolver untuk berbagai metode/protokol, yaitu:</p>

<ul>
<li><p>Filesystem : ini biasanya digunakan untuk folder di komputer lokal atau shared folder (NFS atau Windows Share)</p></li>
<li><p>URL : digunakan untuk mengakses repository melalui http</p></li>
<li><p>SSH : digunakan untuk mengakses repository melalui mekanisme scp</p></li>
<li><p>SFTP : menggunakan protokol FTP yang terenkripsi</p></li>
<li><p>VFS : menggunakan Apache Commons VFS sebagai backend. Mendukung apapun jenis filesystem yang didukung VFS, salah satunya sftp</p></li>
<li><p>Ibiblio : untuk mengakses repository maven2</p></li>
</ul>


<p>Selain itu, Ivy juga menyediakan composite resolver, yaitu resolver yang dapat menampung resolver lainnya. Composite resolver ada dua:</p>

<ul>
<li><p>Chain Resolver : menggabungkan beberapa resolver, sehingga kalau suatu artifak tidak ditemukan di resolver pertama, bisa melanjutkan pencarian ke resolver selanjutnya dalam chain</p></li>
<li><p>Dual Resolver : memisahkan resolver untuk menghitung dependensi, dan resolver untuk mendownload artifak.</p></li>
</ul>


<p>Baiklah, ternyata Ivy bisa menangani macam-macam protokol. Tapi bagaimana cara kita mendesain repository yang baik? Bagaimana best-practicesnya? Mari kita bahas.</p>

<h3>Desain Repository</h3>

<p>Biasanya, kita memiliki dua jenis repository, internal dan external. Repository internal digunakan untuk menyimpan artifak yang dihasilkan project dalam organisasi. Sebagian atau semua artifak internal ini mungkin saja bersifat komersil atau proprietary, sehingga tidak dibuka untuk konsumsi publik.</p>

<p>Di internet tersedia repository yang bisa diakses semua orang. Pengguna Maven biasanya menggunakan <a href="http://www.ibiblio.org/maven/">repository ibiblio</a>. Pengguna Spring OSGi biasanya menggunakan <a href="http://www.springsource.com/repository">repository SpringSource</a>, yang sudah berisi library yang OSGi compliant. Repository SpringSource kompatibel baik dengan Ivy maupun Maven. Untuk menghemat bandwidth internasional, organisasi kita bisa membuat mirror dari repository publik ini agar dependensi bisa diunduh dari jaringan lokal.</p>

<p>Pada artikel ini, kita hanya akan membahas tentang internal repository. Pembahasan tentang external repository akan dibahas pada artikel yang akan datang.</p>

<h3>Internal Repository</h3>

<p>Internal repository dibagi lagi menjadi dua kategori, yaitu local repository, dan shared repository.</p>

<p>Local repository berada di PC masing-masing programmer. Misalnya satu programmer mengerjakan dua modul yang saling berhubungan, misalnya <code>person-model</code> dan <code>person-dao-api</code>. Seringkali dia membuat perubahan di <code>person-model</code> yang akan digunakan di <code>person-dao-api</code>. Tapi karena kode programnya belum sempurna, dia tidak ingin merilis artifak tersebut ke anggota tim yang lain. Untuk kebutuhan ini, dia mempublikasikan artifact <code>person-model</code> ke local repo di PCnya dia sendiri, sehingga bisa diakses oleh modul <code>person-dao-api</code>.</p>

<p>Setelah <code>person-model</code> dan <code>person-dao-api</code> dibuat dan ditest secara menyeluruh, barulah programmer tersebut merilis artifak ke shared repo agar bisa digunakan rekan-rekannya.</p>

<h3>Konfigurasi Internal Resolver</h3>

<p>Untuk mengimplementasikan skenario di atas, kita pertama akan mendefinisikan repository local. Asumsikan saja repository ini akan disimpan di folder local-repo sejajar dengan modul-modul yang lainnya. Kita akan mengkonfigurasi resolvernya di file bernama <code>ivysettings.xml</code>, diletakkan di modul <code>person-build</code> dalam subfolder ivy. Berikut isinya.</p>

<pre><code>&lt;ivysettings&gt;
    &lt;settings defaultResolver="local" /&gt;

    &lt;caches defaultCacheDir="${ivy.settings.dir}/../../ivy-cache" /&gt;
    &lt;resolvers&gt;     
        &lt;filesystem name="local"&gt;
            &lt;artifact
                pattern="${ivy.settings.dir}/../../local-repo/release/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
            &lt;ivy
                pattern="${ivy.settings.dir}/../../local-repo/release/[organisation]/[module]/[revision]/[artifact]-[revision].xml" /&gt;
        &lt;/filesystem&gt;
    &lt;/resolvers&gt;
&lt;/ivysettings&gt;
</code></pre>

<p>Ada beberapa hal yang harus dijelaskan di sini.</p>

<ul>
<li><p>defaultResolver : ini adalah resolver yang digunakan oleh Ivy bila kita tidak secara eksplisit memilih resolver. Setting ini akan berguna nantinya bila kita mendeklarasikan dependensi</p></li>
<li><p>defaultCacheDir : menyebutkan lokasi cache di komputer lokal. Bila tidak dikonfigurasi, Ivy akan menyimpan cache di folder <code>.ivy2/cache</code> dalam home folder user.</p></li>
<li><p>Variabel ${ivy.settings.dir} : lokasi folder tempat file <code>ivysettings.xml</code> berada</p></li>
<li><p>Artifact Pattern : struktur folder tempat artifak disimpan</p></li>
<li><p>Ivy Pattern : struktur folder tempat metadata modul disimpan. Kita akan membahas tentang metadata ini nanti.</p></li>
</ul>


<p>Selanjutnya, kita butuh repository yang bisa digunakan seluruh tim dan programmer dalam perusahaan. Ini berguna bila modul yang kita buat akan digunakan oleh tim lain. Untuk itu, kita akan mengkonfigurasi repository yang akan kita beri nama company. Agar aman, kita gunakan protokol scp untuk memindahkan file ke server. Otentikasinya menggunakan public/private key supaya semua artifact disimpan dengan nama user yang sama. Berikut konfigurasi resolvernya. Tambahkan di bawah resolver local.</p>

<pre><code>&lt;ssh name="company" keyFile="${user.home}/.ssh/id_rsa" host="nama-servernya" user="user-untuk-login-di-server"&gt;
    &lt;ivy
        pattern="/lokasi-folder-di-server/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
    &lt;artifact
        pattern="/lokasi-folder-di-server/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;
&lt;/ssh&gt;
</code></pre>

<p>Kita telah memiliki dua resolver, satu untuk repository di komputer lokal, dan satu lagi repository yang disharing ke seluruh organisasi.</p>

<h3>Target Resolve dan Publish</h3>

<p>Setelah kita melakukan konfigurasi resolver, sekarang kita bisa mempublish artifact dari modul person-model.
Untuk melakukan publishing, kita perlu membuat target di buildfile kita. Agar buildfile tetap rapi, kita buat file baru, yaitu <code>ivy-builder.xml</code>, diletakkan di modul <code>person-build</code>. File ini nantinya akan kita import di <code>build.xml</code> dalam masing-masing modul. Berikut isi file <code>ivy-builder.xml</code></p>

<pre><code>&lt;project name="ivy-related-targets" xmlns:ivy="antlib:org.apache.ivy.ant"&gt;

    &lt;target name="resolve" description="--&gt; resolve and retrieve dependencies with ivy"&gt;
        &lt;ivy:retrieve 
            sync="true"
            pattern="lib/[conf]/[artifact].[ext]"
        /&gt;
    &lt;/target&gt;

    &lt;target name="clean-cache" description="--&gt; clean the ivy cache"&gt;
        &lt;ivy:cleancache /&gt;
    &lt;/target&gt;


    &lt;target name="publish-local" depends="build" description="--&gt; publish this project in the ivy repository"&gt;
        &lt;property name="revision" value="${build.version}" /&gt;
        &lt;delete file="${build.dir}/ivy.xml" /&gt;
        &lt;ivy:publish 
            artifactspattern="${dist.dir}/[artifact].[ext]" 
            resolver="local" 
            pubrevision="${revision}" 
            status="${release.type}" 
            update="true" 
            overwrite="true" 
        /&gt;
        &lt;echo message="project ${ant.project.name} released locally with version ${revision} and status ${release.type}" /&gt;
    &lt;/target&gt;

    &lt;target name="publish-company" depends="build" description="--&gt; publish this project to company repository"&gt;
        &lt;property name="revision" value="${build.version}" /&gt;
        &lt;delete file="${build.dir}/ivy.xml" /&gt;
        &lt;ivy:publish 
            artifactspattern="${dist.dir}/[artifact].[ext]" 
            resolver="company" 
            pubrevision="${revision}" 
            status="${release.type}" 
            update="true" 
            overwrite="true" 
        /&gt;
        &lt;echo message="project ${ant.project.name} released to company repo with version ${revision} and status ${release.type}" /&gt;
    &lt;/target&gt;

    &lt;target name="ivy-report" depends="resolve" description="--&gt; generate dependency report"&gt;
        &lt;ivy:report todir="build/ivy-report"/&gt;
    &lt;/target&gt;

&lt;/project&gt;
</code></pre>

<p>Terlihat dari target publish di atas bahwa kita membutuhkan dua variabel untuk melakukan publish, yaitu <code>${revision}</code> dan <code>${release.type}</code>. Kedua variabel ini akan kita sediakan pada masing-masing modul.</p>

<p>Bila kita ingin mempublish artifact, terlebih dulu kita harus melakukan build. Kita juga memiliki target resolve untuk menentukan dependency. Target resolve ini dijalankan sebelum melakukan kompilasi. Dengan demikian, kita harus menyesuaikan target compile dalam <code>default.xml</code> agar menjalankan resolve sebelum compile. Ubah baris berikut dalam <code>default.xml</code></p>

<pre><code>&lt;target name="compile" depends="prepare"&gt;
    &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
&lt;/target&gt;
</code></pre>

<p>menjadi seperti ini.</p>

<pre><code>&lt;target name="compile" depends="resolve, prepare"&gt;
    &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
&lt;/target&gt;
</code></pre>

<h3>Mempublish Artifact</h3>

<p>Sekarang kita ingin mempublish artifact yang dihasilkan modul <code>person-model</code>. Seperti kita ketahui pada artikel sebelumnya, bila kita menjalankan target build, akan dihasilkan dua jar dalam folder <code>dist</code>, yaitu <code>person-model.jar</code> dan <code>person-model-sources.jar</code>. Kita akan mempublish kedua artifak ini ke repository.</p>

<p>Pastikan file <code>ivy-builder.xml</code> sudah diimport dalam <code>build.xml</code>. Isi <code>build.xml</code> harusnya terlihat seperti ini.</p>

<pre><code>&lt;project name="person-model" default="build"&gt;
    &lt;property file="build.properties"/&gt;

    &lt;import file="${basedir}/../person-build/default.xml"/&gt;
    &lt;import file="${basedir}/../person-build/ivy-builder.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>File tersebut mengacu pada file <code>build.properties</code>. Berikut isi file <code>build.properties</code>.</p>

<pre><code>build.version = 0.0.1
release.type = integration
</code></pre>

<p>Kedua variabel di atas digunakan untuk mengisi variabel <code>${build.version}</code> dan <code>${release.type}</code> yang dibutuhkan target publish di atas. Setiap kali kita melakukan publish, kita harus menentukan versi dan jenis artifak tersebut.</p>

<p>Nomer versi (build.version) tidak sulit dipahami. Untuk menentukan mana yang lebih baru, tinggal dibandingkan versi major, minor, dan micronya. Release type membutuhkan penjelasan lebih lanjut.</p>

<p>Secara default, Ivy memiliki tiga jenis release, diurutkan dari yang paling experimental sampai yang paling stabil: integration, milestone, dan release. Kita juga bisa mendefinisikan jenis release sendiri, dengan menggunakan tag status dalam <code>ivysettings.xml</code>. Untuk kebutuhan kita, tiga status yang disediakan Ivy sudah memadai.</p>

<p>Selanjutnya, kita mendefinisikan beberapa metadata yang berkaitan dengan artifact yang ingin dipublish, yaitu:</p>

<ul>
<li><p>Nama organisasi kita. Ini akan digunakan Ivy untuk mengatur struktur folder dalam repository</p></li>
<li><p>Nama modul yang akan dipublish</p></li>
<li><p>Daftar artifak yang akan dipublish. Satu modul bisa mempublish banyak artifak, misalnya: *.jar yang berisi hasil compile, javadoc, source-code, dsb</p></li>
</ul>


<p>Metadata tersebut ditulis dalam file yang bernama <code>ivy.xml</code>. Diletakkan di sebelah <code>build.xml</code>. Berikut isinya.</p>

<pre><code>&lt;ivy-module version="1.0"&gt;
    &lt;info organisation="com.artivisi" module="com.artivisi.tutorial.ivy.model"/&gt;
    &lt;publications&gt;    
        &lt;artifact name="${ant.project.name}"/&gt;
        &lt;artifact name="${ant.project.name}-sources" type="src" ext="jar"/&gt;
    &lt;/publications&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>Setelah semuanya lengkap, kita tinggal memanggil</p>

<pre><code>ant publish-local 
</code></pre>

<p>untuk mempublish ke repository local, atau</p>

<pre><code>ant publish-company
</code></pre>

<p>untuk mempublish ke repository shared. Bila dalam proses pembuatan private key kita menggunakan password, akan muncul dialog box yang menanyakan password. Isikan nama user yang digunakan untuk login ke server dan password dari private key kita. Sekali lagi, username yang dimasukkan adalah username di server, sedangkan password yang dimasukkan adalah password untuk private key kita sendiri. Jadi, kita tidak memasukkan password dari username di server.</p>

<p>Setelah dijalankan, kita akan melihat banyak file dalam repository. Ivy akan merilis: <code>person-model-0.0.1.jar</code>, <code>person-sources-0.0.1.jar</code>, dan <code>ivy-0.0.1.xml</code> yang berisi metadata dari rilis tersebut. Setiap file disertai signature md5 dan sha1 untuk kebutuhan verifikasi keabsahan file.</p>

<p>Berikut struktur folder keseluruhan.
<img src="/images/uploads/2008/09/struktur-folder-4-all.png" title="" ></p>

<p>Isi folder local repo sebagai berikut.</p>

<p><img src="/images/uploads/2008/09/struktur-folder-4-local-repo.png" title="" ></p>

<p>Isi folder person-build sebagai berikut.</p>

<p><img src="/images/uploads/2008/09/struktur-folder-4-person-build.png" title="" ></p>

<p>Isi folder person-model sebagai berikut.
<img src="/images/uploads/2008/09/struktur-folder-4-person-model.png" title="" ></p>

<p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-5">artikel selanjutnya</a>, kita akan membahas bagaimana cara mengambil artifact yang sudah dipublish tersebut.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-3/">Otomasi Build Process Dengan Ant</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-09T16:48:30+07:00" pubdate data-updated="true">Sep 9<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Setelah pada artikel sebelumnya kita memahami <a href="http://endy.artivisi.com/blog/java/ant-ivy-2">mengapa dan kapan kita butuh Ivy</a>, mulai dari artikel ini, kita akan menjalani langkah demi langkah supaya kegiatan build kita benar-benar terintegrasi dan efisien.</p>

<p>Pada artikel ini, kita akan membuat satu modul dulu, yang sama sekali tidak memiliki dependensi, yaitu modul <code>person-model</code>.
Kita akan mengotomasi proses build untuk modul ini, kemudian menyiapkan infrastruktur lainnya sehingga siap untuk digunakan oleh modul lainnya.</p>

<p>Tiap modul yang kita buat, setara dengan satu project dalam IDE. Dalam IDE kita dapat mendaftarkan (membuat referensi ke) project lain dalam build-path sehingga tidak muncul peringatan compile error.</p>

<p>Berikut struktur folder modul <code>person-model</code>.</p>

<p><img src="/images/uploads/2008/09/01-project-person-model.png" title="" ></p>

<p>Tidak ada yang istimewa, kita memiliki build.xml disertai dengan folder <code>src</code> yang berisi source code java. Kita ingin agar struktur folder kita seragam di semua modul, jadi untuk seluruh modul nantinya strukturnya akan sama.</p>

<p>Kita hanya memiliki satu file source code sederhana, <code>Person.java</code> sebagai berikut.</p>

<pre><code>package com.artivisi.tutorial.ivy.model;

import java.util.Date;

public class Person {
    private Integer id;
    private String name;
    private Date birthdate;

    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    public void setBirthdate(Date birthdate) {
        this.birthdate = birthdate;
    }   
}
</code></pre>

<p>Sebagai rangkaian build, kita akan melakukan kegiatan sebagai berikut:</p>

<ul>
<li><p>Bersihkan hasil kompilasi sebelumnya (clean)</p></li>
<li><p>Kompilasi (compile)</p></li>
<li><p>Distribusi, membuat file *.jar dari hasil kompilasi (build)</p></li>
</ul>


<p>Rangkaian kegiatan tersebut kita tuliskan dalam file <code>build.xml</code>, sebagai berikut</p>

<pre><code>&lt;project name="person-model"&gt;

    &lt;property name="src.java.dir" value="src/java" /&gt;
    &lt;property name="compile.dir" value="build/bin" /&gt;
    &lt;property name="dist.dir" value="build/dist" /&gt;

    &lt;path id="compile.classpath"&gt;
        &lt;pathelement location="${src.java.dir}" /&gt;
        &lt;fileset dir="lib" includes="**/*.jar" /&gt;
    &lt;/path&gt;

    &lt;target name="prepare"&gt;
        &lt;mkdir dir="lib" /&gt;
        &lt;mkdir dir="build" /&gt;
        &lt;mkdir dir="${compile.dir}" /&gt;
        &lt;mkdir dir="${dist.dir}" /&gt;
    &lt;/target&gt;

    &lt;target name="clean"&gt;
        &lt;delete dir="build" /&gt;
        &lt;delete dir="lib" /&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="prepare"&gt;
        &lt;javac srcdir="${src.java.dir}" destdir="${compile.dir}" classpathref="compile.classpath" /&gt;
    &lt;/target&gt;

    &lt;target name="build" depends="compile"&gt;
        &lt;!-- binary distribution --&gt;
        &lt;jar destfile="${dist.dir}/${ant.project.name}.jar"&gt;
            &lt;fileset dir="${compile.dir}"&gt;
                &lt;exclude name="**/*Test.class"/&gt;
            &lt;/fileset&gt;
        &lt;/jar&gt;

        &lt;!-- source distribution --&gt;
        &lt;jar destfile="${dist.dir}/${ant.project.name}-sources.jar"&gt;
            &lt;fileset dir="${src.java.dir}"&gt;
                &lt;exclude name="**/*Test.java"/&gt;
            &lt;/fileset&gt;
        &lt;/jar&gt;
    &lt;/target&gt;
&lt;/project&gt;
</code></pre>

<p>Selanjutnya, kita bisa coba melakukan build.</p>

<pre><code>ant build
</code></pre>

<p>Nanti Ant akan menghasilkan file <code>person-model.jar</code> dan <code>person-model-sources.jar</code> dalam folder dist.</p>

<p>File <code>build.xml</code> ini nantinya akan kita gunakan di seluruh modul. Seluruh modul tentunya butuh kegiatan kompilasi dan membuat jar. Untuk menghindari perulangan dan copy-paste, kita simpan <code>build.xml</code> ini di folder bersama, kita beri nama saja person-build.</p>

<p>Karena digunakan di banyak modul, kita perlu melakukan penyesuaian sedikit, yaitu namanya kita ganti menjadi <code>default.xml</code>. Deklarasi nama project juga diganti, dari seperti ini:</p>

<pre><code>&lt;project name="person-model"&gt;
</code></pre>

<p>menjadi seperti ini:</p>

<pre><code>&lt;project name="default-build"&gt;
</code></pre>

<p>Struktur foldernya menjadi seperti ini</p>

<p><img src="/images/uploads/2008/09/02-project-person-build.png" title="" ></p>

<p>Selanjutnya, dalam build.xml di project person-model, kita hanya perlu melakukan import saja. Isi <code>build.xml</code> menjadi seperti ini:</p>

<pre><code>&lt;project name="person-model" default="build"&gt;

    &lt;import file="${basedir}/../person-build/build.xml"/&gt;

&lt;/project&gt;
</code></pre>

<p>Silahkan coba lakukan build di dalam folder <code>person-model</code>. Seharusnya modul ini bisa dibuild tanpa error, sama seperti sebelumnya.</p>

<p>Bila modul person-model sudah lancar, kita bisa mulai mereplikasi modul-modul yang lainnya. Dengan semua modul sudah dibuatkan sesuai template, berikut struktur foldernya.</p>

<p><img src="/images/uploads/2008/09/03-project-all.png" title="" ></p>

<p>File <code>build.xml</code> di masing-masing project mirip dengan person-model, hanya dibedakan di baris pertama saja.</p>

<pre><code>&lt;project name="person-model"&gt;
</code></pre>

<p>Sesuaikan dengan nama modul masing-masing.</p>

<p>Persiapan template project kita sudah selesai. Sampai tahap ini, kita hanya memiliki satu source-code java, yaitu Person.java. Source-code ini akan dipaket menjadi file distribusi <code>person-model.jar</code> (binary) dan <code>person-model-sources.jar</code> (source-code). Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-4/">artikel selanjutnya</a>, kita akan mempublikasikan distribusi ini agar bisa digunakan oleh modul lain.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/ant-ivy-2/">Build Management Dengan Ivy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-08T16:48:29+07:00" pubdate data-updated="true">Sep 8<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-1">posting sebelumnya</a>, saya telah membahas tentang <a href="http://endy.artivisi.com/blog/java/ant-ivy-1">cara instalasi Ivy</a>, dan juga sedikit pengantar tentang apa itu Ivy.</p>

<p>Ivy adalah dependency management tools. Dia mampu menangani dependensi antar modul dalam aplikasi. Tentunya penjelasan ini sangat abstrak. Baiklah mari kita lihat problem apa yang kita hadapi dalam membuat aplikasi, dan bagaimana Ivy menyelesaikan problem tersebut.</p>

<blockquote><p>Peringatan : Bukan untuk pemula !!!</p></blockquote>

<p>Rangkaian artikel ini diperuntukkan untuk Senior Developer, Team Leader, atau Architect.</p>

<p>Saya asumsikan pembaca sudah mahir menggunakan Ant, Linux, dan memiliki bandwidth yang besar.</p>

<h3>Studi Kasus</h3>

<p>Untuk contoh kasus, mari kita buat aplikasi sederhana dengan Spring MVC 2.5. Aplikasi ini bisa didonlod <a href="http://code.google.com/p/hello-spring-25">di sini</a>.</p>

<p>Aplikasi sederhana ini terdiri dari 3 bagian utama, yaitu:</p>

<ul>
<li><p>Domain Model</p></li>
<li><p>Kode Akses Database (DAO)</p></li>
<li><p>Tampilan (UI)</p></li>
</ul>


<p>Hubungan dependensi antara ketiga bagian ini dapat digambarkan sebagai berikut:</p>

<p><img src="/images/uploads/2008/09/dep-before.png" title="" ></p>

<p>Tanda panah dibaca sebagai &#8220;tergantung kepada&#8221;. Contohnya, modul DAO tergantung kepada modul Domain Model, sehingga untuk mengkompilasi modul DAO, kita harus punya modul Domain Model. Sebaliknya, untuk mengkompilasi modul Domain Model, kita tidak butuh modul DAO.</p>

<h3>Dependensi, Pembagian Tim, dan Penjadwalan</h3>

<p>Ketergantungan antar modul ini perlu dipertimbangkan dengan seksama, karena dari desain ketergantungan ini, kita dapat menentukan pembagian tim yang efisien. Idealnya masing-masing tim development dapat bekerja secara paralel dan tidak saling menunggu tim lain selesai.</p>

<p>Dengan skema dependensi seperti di atas, pembagian tugas antar tim kita tidak efisien, karena tim DAO harus menunggu tim DM selesai, baru dia dapat mulai. Demikian juga, tim UI harus menunggu tim DM dan juga tim DAO selesai, baru dia dapat mulai. Ini dapat dilihat di project schedule berikut.</p>

<p><img src="/images/uploads/2008/09/sch-before.png" title="" ></p>

<p>Dengan schedule seperti ini, kita membutuhkan 11 minggu untuk development, karena modul UI dan DAO yang membutuhkan waktu lama harus dikerjakan secara serial.</p>

<p>Agar kita dapat bekerja secara paralel, kita dapat mengatur ulang dependensi sebagai berikut.</p>

<p><img src="/images/uploads/2008/09/dep-after.png" title="" ></p>

<p>Kita menambahkan modul baru, yaitu DAO-API dan DAO-Impl. Modul DAO-API ini berisi interface dari modul DAO, tanpa implementasi. Implementasinya berada di modul DAO-Impl.</p>

<p>Pembagian yang baru ini didasarkan pada waktu pengembangan dari masing-masing modul. Modul DM dan DAO-API bisa dikembangkan dengan cepat, karena hanya berisi struktur data dan deklarasi method saja. Modul UI dan DAO-Impl butuh waktu lama, karena relatif kompleks dan membutuhkan banyak test.</p>

<p>Dengan skema baru, project schedule menjadi seperti ini.</p>

<p><img src="/images/uploads/2008/09/sch-after.png" title="" ></p>

<p>Dengan skema di atas, kita dapat mengalokasikan agar tim DAO dan tim UI bersama-sama mengerjakan modul Domain Model dan DAO-API. Setelah selesai, tim UI dapat mengerjakan modul UI secara paralel dengan tim DAO yang mengerjakan modul DAO-Impl.</p>

<p>Durasi development dapat dikurangi menjadi 7 minggu saja.</p>

<h3>Masalah dalam implementasi</h3>

<p>Ok, kita sudah mendesain dependensi sedemikian rupa, sehingga bisa meminimasi idle time. Berarti kita sudah menjadi Development Team Leader yang canggih &#8230; benar??</p>

<p>Belum, yang kita lakukan ini baru setengah jalan. Mengelola tim yang bekerja paralel itu bukan pekerjaan yang mudah. Desain dependensi yang baik memungkinkan tim bekerja paralel. Tapi butuh perangkat tambahan agar mereka bisa berkoordinasi secara efisien.</p>

<p>Masalah terbesar dengan project multi-modul ini adalah bagaimana mengelola perubahan (Change Management). Developer yang berpengalaman pasti sudah tahu bahwa keinginan end-user selalu berubah. Perubahan ini menjadi masalah bila terjadi di modul yang digantungi banyak modul lain.</p>

<p>Contohnya, pada assessment awal, kita sudah mendefinisikan bahwa class Person memiliki tiga property, yaitu id, nama, dan tanggalLahir. Class Person ini kita tempatkan di modul Domain Model, yang digunakan oleh semua modul lain. Katakan saja misalnya kita rilis dengan versi 1.0.</p>

<p>Ternyata peta persaingan bisnis aplikasi contact berubah. Perusahaan pesaing menyediakan aplikasi yang tidak hanya menyimpan tanggal lahir, tapi juga nomer handphone. Tentunya kita harus buru-buru mengupgrade aplikasi (yang belum selesai dikerjakan) agar juga memuat data nomer handphone.</p>

<p>Nah, bagaimana mengelola perubahan ini agar kedua tim yang sedang bekerja (DAO-Impl dan UI) dapat menyesuaikan diri dengan mudah?</p>

<p>Implementasi yang paling sederhana bisa dilakukan dengan USB Flashdisk. Compile saja modul DM, kemudian copy ke flashdisk. Edarkan flashdisk tersebut ke seluruh tim &#8230; masalah selesai.</p>

<p>Cara flashdisk, walaupun bisa dilakukan, tapi tidak scalable. Jika dependensinya rumit (misalnya membuat aplikasi ERP), kita harus membuat satu departemen khusus untuk mengedarkan flashdisk.</p>

<p>Nah, inilah gunanya Ivy. Dengan Ivy, kita bisa membuat perubahan di class Person, kemudian menyuruh Ivy untuk mempublikasikannya ke lokasi tertentu dengan versi 1.1. Begitu tim lain melakukan kompilasi, Ivy secara otomatis akan mendeteksi bahwa ada update terbaru di modul Domain Model, mendownload versi terbaru, menghapus versi yang lama, baru melakukan kompilasi.</p>

<p>Ivy dapat mengelola dependensi antar modul dalam internal perusahaan, maupun dependensi dengan pustaka open-source. Contoh aplikasi kita di atas menggunakan pustaka dari <a href="http://www.springframework.org">Spring Framework</a>, <a href="http://www.mysql.org">MySQL</a>, <a href="http://velocity.apache.org">Velocity</a>, dan SiteMesh. Masing-masing pustaka tersebut memiliki dependensi lagi terhadap pustaka lain, misalnya <a href="http://commons.apache.org">Apache Commons</a> dan <a href="http://logging.apache.org/log4j">Log4J</a>.</p>

<p>Dengan menggunakan Ivy, kita hanya perlu mendeklarasikan dependensi langsung, yaitu Spring Framework, MySQL, Velocity, dan SiteMesh. Selanjutnya Ivy akan mencari tahu semua dependensi level kedua terhadap Jakarta Commons dan Log4J. Begitu kita melakukan kompilasi, Ivy akan terlebih dulu mengunduh semua dependensi dari internet, melakukan setting CLASSPATH, baru melakukan kompilasi.</p>

<p>Ivy juga memiliki fitur configuration. Dengan fitur ini, kita bisa membedakan dependensi untuk kompilasi, melakukan test, atau mendeploy aplikasi ke production.</p>

<p>Contohnya, bila kita menggunakan database, kita tidak perlu mendownload *.jar apapun untuk melakukan kompilasi. Pada saat kita test di IDE sendiri, kita gunakan database HSQLDB supaya ringan dan cepat. Untuk test oleh tim tester, kita gunakan database MySQL. Akhirnya, untuk UAT dan production, kita gunakan database Oracle.</p>

<p>Contoh lain, kita bisa mendefinisikan konfigurasi deployment dan delivery. Untuk deployment, kita menginstal aplikasi di tempat client. Tentunya kita hanya butuh <em>.jar saja. Lain halnya dengan delivery. Selain </em>.jar, kita juga harus memuat source code, javadoc, manual penggunaan, dan lainnya ke dalam DVD untuk diserah-terimakan dengan client.</p>

<p>Dengan menggunakan fitur configuration Ivy, kita dapat mendefinisikan berbagai kombinasi artifak yang dibutuhkan untuk berbagai situasi.</p>

<p>Pada <a href="http://endy.artivisi.com/blog/java/ant-ivy-3/">artikel selanjutnya</a>, kita akan mulai membuat modul Domain Model. Seluruh modul yang dibuat dalam rangkaian artikel ini bisa dibuat dengan Text Editor biasa. Tidak perlu IDE canggih semacam Netbeans, Eclipse, atau IDEA.</p>

<p>Stay tuned.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/linux/login-ssh-dengan-private-key/">Login Ssh Dengan Private Key</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-05T22:45:03+07:00" pubdate data-updated="true">Sep 5<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Masih dalam rangka mengotomasi workflow di ArtiVisi, artikel ini akan membahas tentang cara memindahkan file antar komputer secara aman tapi otomatis.</p>

<p>Ada berbagai cara kita memindahkan file dari satu komputer ke komputer lain, diantaranya:</p>

<ul>
<li><p>Menggunakan USB Flashdisk</p></li>
<li><p>Windows File Sharing</p></li>
<li><p>NFS</p></li>
<li><p>FTP atau SFTP</p></li>
<li><p>SCP</p></li>
<li><p>dan sebagainya</p></li>
</ul>


<p>Cara pertama jelas tidak bisa diotomasi.</p>

<p>Cara kedua sampai keempat mengharuskan kita membuka write access tanpa password di komputer tujuan supaya bisa otomatis. Kalau ada passwordnya kan harus ada seseorang yang mengetik password tersebut. Jadi agak sulit mengotomasinya.</p>

<p>Oleh karena itu, kita akan membahas cara kelima, yaitu SCP. SCP &#8211;atau Secure Copy&#8211; adalah mekanisme copy file melalui protokol SSH. File yang dikirim terenkripsi. Untuk dapat masuk ke komputer tujuan, kita harus melakukan otentikasi. Jadi ini adalah cara yang relatif aman untuk mengirim file.</p>

<p>Tunggu dulu, katanya mau otomatis, tapi kok harus otentikasi?? Berarti harus ada yang mengetik password dong &#8230;.</p>

<p>Tidak juga, makanya saya menggunakan istilah otentikasi, bukan password. SSH dapat melakukan otentikasi dengan password maupun private key. Pada artikel ini, kita akan membahas tentang otentikasi private key.</p>

<p>Artikel ini dibuat menggunakan Ubuntu Hardy dengan openssh sudah terinstal.</p>

<p>Ada beberapa langkah yang harus kita lakukan, yaitu:</p>

<ol>
<li><p>Membuat private key di komputer pengirim</p></li>
<li><p>Mengirim public key ke komputer tujuan</p></li>
<li><p>Registrasi public key di komputer tujuan</p></li>
</ol>


<p>Sebelum mulai, kita tentukan dulu studi kasusnya.</p>

<blockquote><p>Di tengah pertarungan dengan Pain, guru genit Jiraiya tiba-tiba berhasil menemukan kelemahan musuhnya. Dia ingin mengirim file berisi informasi tersebut ke sang Hokage seksi, yaitu Tsunade. Rencananya, dia akan login ke server di markas dengan username Tsunade dan menyimpan file tersebut di folder <code>/home/tsunade/important</code>.</p></blockquote>

<p>Tentunya Tsunade tidak akan memberitahukan passwordnya kepada Jiraiya, mengingat tabiatnya yang genit. Sebagai gantinya, dia mendaftarkan public key Jiraiya ke user accountnya di server, sehingga Jiraiya bisa login sebagai Tsunade, tanpa Tsunade harus memberitahukan passwordnya kepada Jiraiya.</p>

<p>Pada cerita di atas, kita punya dua komputer, yaitu laptopnya Jiraiya yang dibawanya kemanapun pergi, dan server di markas. Kita juga punya dua user, yaitu Jiraiya dan Tsunade.</p>

<p>Agar bisa melakukan public key authentication, tentunya hal pertama yang harus dilakukan adalah membuat public key.</p>

<h3>Membuat public key</h3>

<p>Jiraiya harus membuat public key di laptopnya sendiri. Public key selalu berpasangan dengan private key. Untuk membuat public key, Jiraiya mengetik perintah berikut di terminal.</p>

<pre><code>ssh-keygen
</code></pre>

<p>Perintah tersebut akan menanyakan password untuk membuka private key. Jiraiya memilih tidak memberikan password. Sebetulnya ini kurang aman, karena kalau ada orang lain yang berhasil mendapatkan file private key, dia bisa login ke server di markas tanpa hambatan.</p>

<p>Tapi mau bagaimana lagi, hidup sebagai ninja sangat berbahaya. Kita tidak tahu apakah setelah pertarungan kita masih punya tangan untuk mengetik password.</p>

<p>Tekan enter beberapa kali sampai selesai. Berikut output yang dihasilkan.</p>

<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (/home/jiraiya/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/jiraiya/.ssh/id_rsa.
Your public key has been saved in /home/jiraiya/.ssh/id_rsa.pub.
The key fingerprint is:
6f:7c:e2:52:f1:14:5d:2c:7f:3a:53:5e:fe:7f:98:9c jiraiya@laptop
</code></pre>

<p>Selanjutnya, kita harus kirimkan file public key ke Tsunade agar didaftarkan di accountnya. File public key ini bisa ditemukan di folder <code>/home/jiraiya/.ssh/</code> dengan nama <code>id_rsa.pub</code>. Public key bisa dikirim melalui media apapun, misalnya email, usb flashdisk, burung hantu, maupun burung merpati.</p>

<h3>Registrasi Public Key</h3>

<p>Singkat kata, Tsunade telah menerima public key dari Jiraiya. Dia harus mendaftarkannya di accountnya agar Jiraiya bisa login.</p>

<p>Tsunade harus login dulu ke server dan menaruh file public key tersebut di sana. Misalnya dia letakkan di folder <code>/home/tsunade/</code> dan nama filenya diubah menjadi <code>jiraiya_id_rsa.pub</code>.</p>

<p>Untuk meregistrasinya, Tsunade menggunakan perintah berikut di terminal.</p>

<pre><code>cat /home/tsunade/jiraiya_id_rsa.pub &gt;&gt; /home/tsunade/.ssh/authorized_keys
</code></pre>

<p>Setelah itu, public key tidak lagi diperlukan, sehingga bisa dihapus.</p>

<pre><code>rm /home/tsunade/jiraiya_id_pub
</code></pre>

<p>Selesai sudah konfigurasi di server, sekarang kita kembali ke pertarungan Jiraiya vs Pain.</p>

<h3>Login dengan public key</h3>

<blockquote><p>Sesaat sebelum Jiraiya menekan tombol Send di Mozilla Thunderbird, Pain mendaratkan serangan mematikan ke Jiraiya, sehingga ybs tidak dapat menggerakkan tangannya. Jiraiya membatin, &#8220;Untung saja saya sudah setup public key di server dengan account Tsunade. Baiklah, mari kita scp saja.&#8221;</p></blockquote>

<p>Untuk mengirim file tersebut melalui scp dengan public key, berikut adalah perintahnya</p>

<pre><code>scp -i /path/menuju/private/key username@komputer-tujuan:folder-tujuan
</code></pre>

<p>Jadi, untuk mengirim file <code>pain-secret.txt</code> ke server dengan username tsunade, Jiraiya menggunakan perintah berikut</p>

<pre><code>scp -i /home/jiraiya/.ssh/id_rsa pain-secret.txt tsunade@server:/home/tsunade/important/
</code></pre>

<p>File akan segera terkirim tanpa harus mengetik password.</p>

<p>Lebih lanjut tentang ssh dengan public/private key bisa dibaca <a href="http://www.debuntu.org/ssh-key-based-authentication">di sini</a>.</p>

<p>Lebih lanjut tentang nasib Jiraiya bisa dibaca <a href="http://narutochaos.com/download/10/429">di sini</a>.</p>

<p>Selamat mencoba</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/linux/backup-trac/">Backup Trac</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-04T19:41:14+07:00" pubdate data-updated="true">Sep 4<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://endy.artivisi.com/blog/linux/instalasi-trac">Trac sudah terinstal</a>, sekarang harus diamankan melalui prosedur backup.</p>

<p>Seperti biasa, semua prosedur backup harus otomatis dan terjadwal. Kalau tidak begitu, pasti tidak akan dijalankan. Jadi, selain kegiatan memburn CD, kegiatan backup lainnya harus diotomasi.</p>

<p>Di website Trac sudah dijelaskan tentang <a href="http://trac.edgewall.org/wiki/TracBackup">cara melakukan backup terhadap instalasi Trac</a>. Kita hanya perlu membuat script sedikit supaya bisa membackup seluruh project dalam folder parent trac, dan mengkompresnya.</p>

<p>Berikut scriptnya, seperti biasa, menggunakan Ruby.</p>

<p>Script ini diadaptasi dari <a href="http://endy.artivisi.com/blog/aplikasi/svn-parentpath-backup/">script sebelumnya untuk backup Subversion repo</a>.</p>

<p>Berikut scriptnya</p>

<pre><code>require 'zlib'
require 'fileutils' 

if ARGV.length &lt; 2
  puts "Usage : ruby trac-backup.rb &lt;Trac Parent folder&gt; &lt;backupfolder&gt;"
  exit
end

# some configuration
trac_parent_path = ARGV[0]
backup_folder = ARGV[1]

# variable initialization
current_date = Time.now.strftime("%Y%m%d")

Dir.foreach(trac_parent_path) { |trac|
    next if('.' == trac || '..' == trac)
    puts "Start to process folder : "+trac

    puts "Performing trac hotcopy"
    project_name = trac_parent_path + File::SEPARATOR + trac
    dumpfile_folder = trac + '-' +current_date
    dumpfile = backup_folder + File::SEPARATOR + dumpfile_folder

    `trac-admin #{project_name} hotcopy #{dumpfile}`

    puts "Compressing dumpfile"
    `tar czf #{backup_folder}/#{dumpfile_folder}.tar.gz -C #{backup_folder} #{dumpfile_folder}`

    puts "Deleting uncompressed backup"
    FileUtils.rm_r dumpfile
}
</code></pre>

<p>Save dengan nama <code>trac-backup.rb</code>.</p>

<p>Warning, kode di atas tidak bisa dijalankan di Windows, karena menggunakan command line tar untuk mengkompres file. Jika Anda ingin menggunakan di Windows, silahkan gunakan TugZIP seperti <a href="http://endy.artivisi.com/blog/aplikasi/subversion-backup-script-untuk-windows/">contoh ini</a>.</p>

<p>Untuk menjalankannya, cukup panggil dari command prompt.</p>

<pre><code>ruby trac-backup.rb /var/lib/trac /folder/tempat/backup
</code></pre>

<p>Supaya fully-automated, daftarkan di cron. Buka editor crontab.</p>

<pre><code>crontab -e
</code></pre>

<p>Kemudian ketikkan entri sebagai berikut</p>

<pre><code>0 23 * * 5 /usr/bin/ruby /full/path/ke/trac-backup.rb /var/lib/trac /full/path/ke/folder/backup
</code></pre>

<p>Backup akan dijalankan setiap jam 23.00 pada hari Jumat. Lebih lanjut tentang cron bisa <a href="http://bandung.linux.or.id/node/24">dibaca di sini</a>. Jika bingung dengan formatnya, bisa gunakan <a href="http://www.htmlbasix.com/crontab.shtml">generator crontab online</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/linux/instalasi-trac/">Instalasi Trac</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-09-03T23:54:21+07:00" pubdate data-updated="true">Sep 3<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mulai beberapa minggu ini, ArtiVisi kebanjiran project. Ini tentu harus dikelola dengan baik. Semua orang harus bekerja se-efisien mungkin. Menjadi tugas saya sebagai manager untuk memudahkan orang-orang bekerja.</p>

<p>Opa Abe Lincoln pernah bilang gini, jauh sebelum mas Barry masuk sekolah di SD Besuki, Menteng.</p>

<blockquote><p>If I had eight hours to chop down a tree, I&#8217;d spend six hours sharpening my axe</p></blockquote>

<p>So be it &#8230;.</p>

<p>Hal pertama yang harus dilakukan sebelum mulai bekerja adalah mempersiapkan environment. Ada beberapa tools yang dapat digunakan untuk mempercepat kegiatan software development, terutama di Java. Ini pernah saya bahas di <a href="http://endy.artivisi.com/blog/manajemen/starter-kit/">artikel ini</a>.</p>

<p><a href="http://endy.artivisi.com/blog/aplikasi/instalasi-subversion/">Subversion sudah terinstal</a> sejak hari pertama ArtiVisi buka warung. Bahkan sebelum websitenya jadi, repository sudah siap digunakan dan <a href="http://endy.artivisi.com/blog/aplikasi/svn-parentpath-backup/">diamankan melalui prosedur backup</a>. Ant-Ivy juga sudah terinstal dan terkonfigurasi. Tinggal menunggu terisi dengan *.jar external dari <a href="http://www.ibiblio.org/maven/">repository ibiblio</a> dan <a href="http://www.springsource.com/repository/">repository springsource</a>.</p>

<p>Hal berikutnya adalah mempersiapkan bug tracker dan project management tools. Karena saya menggunakan Eclipse, maka kriteria pemilihan bug tracker tentu saja adalah kompatibilitasnya dengan <a href="http://www.eclipse.org/mylyn/">Mylyn</a>. <a href="http://www.bugzilla.org/">Bugzilla</a> cuma bisa untuk bug-tracker, jadi saya pilih saja <a href="http://trac.edgewall.org/">Trac</a>.</p>

<p>Berikut langkah instalasi di Ubuntu Gutsy Server.</p>

<h3>Instalasi Trac</h3>

<p>Instalasi Trac tidak sulit, cukup satu baris perintah saja.</p>

<pre><code>sudo apt-get install trac libapache2-mod-python python-setuptools
</code></pre>

<p>Selanjutnya, kita konfigurasi VirtualHost Apache. Saya buatkan satu subdomain khusus yang namanya trac.artivisi.com. Jadi, kita buat file <code>/etc/apache2/sites-available/trac.artivisi.com</code>.</p>

<p>Subdomain ini nantinya akan menampung data Trac untuk banyak project. Jadi, kita harus mengkonfigurasi parent path yang menyatakan folder tempat data trac untuk masing-masing project disimpan.</p>

<p>Berikut isi filenya.</p>

<pre><code> &lt;Location /trac&gt;

    SetHandler mod_python
    PythonHandler trac.web.modpython_frontend
    PythonOption TracEnvParentDir /var/lib/trac
    PythonOption TracUriRoot /trac

 &lt;/Location&gt;
</code></pre>

<p>Selanjutnya, kita konfigurasi otentikasinya supaya mengacu ke LDAP tempat menyimpan username dan password Subversion. Jadi username dan password untuk svn commit sama dengan untuk login ke Trac.</p>

<pre><code> &lt;LocationMatch "/trac/[^/]+/login"&gt;

    AuthType Basic
    AuthName "ArtiVisi Trac Server"

    AuthBasicProvider ldap
        AuthLDAPURL url-ldap-server
    AuthLDAPBindDN dn-untuk-apache-login-di-ldap
    AuthLDAPBindPassword password-dn-tersebut

    AuthzLDAPAuthoritative off

    Require valid-user

 &lt;/LocationMatch&gt;
</code></pre>

<p>Sekarang konfigurasi Apache sudah selesai. Jangan lupa me-restart apache.</p>

<pre><code>sudo /etc/init.d/apache2/restart
</code></pre>

<p>Berikutnya, membuat project baru.</p>

<h3>Membuat Project</h3>

<p>Misalnya kita ingin membuat project bernama hello-world. Sebagai root, masuk ke folder /var/lib/trac. Kemudian buat projectnya. Jangan lupa tambahkan user administratornya sekaligus.Terakhir, ganti kepemilikan folder sesuai dengan user yang digunakan proses webserver.</p>

<pre><code>sudo -i
cd /var/lib/trac
trac-admin hello-world initenv
trac-admin hello-world permission add endy TRAC_ADMIN
chown -R www-data.www-data hello-world
</code></pre>

<p>Langkah di atas akan menginisialisasi Trac dengan satu username &#8211;yaitu endy&#8211; sebagai administrator. Selanjutnya, kita edit konfigurasinya agar setiap perubahan bug/task akan mengirim notifikasi ke email. Edit file /var/lib/trac/hello-world/conf/trac.ini</p>

<pre><code>smtp_enabled = true
smtp_default_domain = artivisi.com
smtp_from_name = ArtiVisi Trac Server
smtp_from = artivisi.dev@gmail.com
smtp_replyto = artivisi.dev@gmail.com

smtp_server = smtp.gmail.com
smtp_port = 587
smtp_user = artivisi.dev
smtp_password = rahasia_dong
use_tls = true
</code></pre>

<p>Pada konfigurasi di atas, kita menggunakan Gmail yang gratis dan mudah. Kita buat account di Gmail bernama artivisi.dev dan kita berikan password rahasia_dong.</p>

<p>Selesai sudah. Sekarang silahkan browse ke URLnya.</p>

<h3>Plugin WebAdmin</h3>

<p>Sebagai tambahan, kita bisa menambahkan plugin webadmin supaya kita bisa menambah user dan mengatur permission melalui interface web.</p>

<p>Ubuntu secara default menginstal Trac versi 0.10, jadi kita harus menginstal plugin WebAdmin secara manual. Di versi 0.11 Trac sudah menyertakan WebAdmin secara default.</p>

<p>Instalasi dijalankan langsung dari subversion repository.</p>

<pre><code>sudo easy_install http://svn.edgewall.org/repos/trac/sandbox/webadmin/
</code></pre>

<p>Untuk menjalankan plugin, kita perlu membuat file <code>/etc/trac/trac.ini</code>. Berikut isinya.</p>

<pre><code>[components]
webadmin.* = enabled
</code></pre>

<p>Voila, nanti akan muncul tombol admin setelah kita login.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/12/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
    <a class="next" href="/page/10/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Endy Muhardin</h1>

<p>Software Developer berdomisili di Jabodetabek, berkutat di lingkungan open source, terutama Java dan Linux.</p>

<p>
    <ul>
        <li>
            <span class="icon-phone" style="text-align: left; width: 100%">&nbsp;
            +62 812 98000 468
            </span>
        </li>
        <li>
            <span class="icon-envelope" style="text-align: left; width: 100%">&nbsp;
                <a href="mailto:endy.muhardin@gmail.com">endy.muhardin@gmail.com</a>
            </span>
        </li>
        <li>
            <span class="icon-twitter" style="text-align: left; width: 100%">&nbsp;
                <a href="http://twitter.com/endymuhardin">@endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-github" style="text-align: left; width: 100%">&nbsp;
                <a href="https://github.com/endymuhardin">github.com/endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-facebook" style="text-align: left; width: 100%">&nbsp;
                <a href="http://facebook.com/endy.muhardin">facebook.com/endy.muhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-google-plus" style="text-align: left; width: 100%">&nbsp;
                <a href="http://google.com/+EndyMuhardin">google.com/+EndyMuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-linkedin" style="text-align: left; width: 100%">&nbsp;
                <a href="http://id.linkedin.com/pub/endy-muhardin/3/940/1bb">LinkedIn</a>
            </span>
        </li>
    </ul>
</p>
</section>

<section>

Bila artikel di website ini membantu meningkatkan penghasilan Anda, 
jangan ragu untuk memberikan donasi :)

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYByjmBHWB1u9oWkn33FHJ7Lu41iidZkdKLciblvSz2Oa/oBArw42F4/7nq3imMAWUvpA6Cx9zwNr3R7WqjnMlDr91VTkeyl1jusRB6Knw/JAaNI2yz20lbFtVNMhUrh2LJ6qXUwvdL4jvZeNUeOcvq/muETfy8BzgdKwCF3gNGpoTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQId7q7vUD8KwOAgaAyBdpVvmsdYWgKdVROwaJazFrOpQpWEncNGoycnyfeJRNwHXXZU1mj0oTJuvj/CUGr6cZC5RnQNBHC6FLnbjCVheTNtjBSs/CjD7HZMn28kElykLad2wDrFUsBkQCdRU43ZBLoRedRKbGVWP4wk6DgLovkwPzYNLKtl3clJbgm3UDXigmJqeAyvmafF2yk8LV4ACLTJtCu6qtSBVHkuUPToIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTMwNzExMDY0MjAwWjAjBgkqhkiG9w0BCQQxFgQUwzp1u86AW3VypUoSwjzfYA4KYn8wDQYJKoZIhvcNAQEBBQAEgYBExEV1zgHTrd+4zfXwIP0KO0/W7b4s2KDLbZ3Vq9FrtdtC9W3NEf6SbVZDYE+bEheP10XokfC8BslN7nZgsfPTvSNXv7ixfpWUVBb/gQB+QO70q1NZ2tuF2M/t1QzFUEZ9FeA0sgFMBS7nxmu7ynaSzez3B4FTG/jUzuRljVWhew==-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
</form>

</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/manajemen/capacity-planning/">Capacity Planning</a>
      </li>
    
      <li class="post">
        <a href="/java/memahami-authentication/">Memahami Authentication</a>
      </li>
    
      <li class="post">
        <a href="/java/desain-skema-database/">Desain Skema Database</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/tahapan-membuat-aplikasi/">Tahapan Membuat Aplikasi</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/aplikasi-prakarya-vs-aplikasi-production/">Aplikasi Prakarya vs Aplikasi Production</a>
      </li>
    
      <li class="post">
        <a href="/java/membuat-subreport-jasper-dalam-springmvc/">Membuat subreport Jasper dalam SpringMVC</a>
      </li>
    
      <li class="post">
        <a href="/linux/cara-mengetahui-ip-address-dari-mac-address/">Cara Mengetahui IP Address dari MAC Address</a>
      </li>
    
      <li class="post">
        <a href="/life/menjadi-mahasiswa-hi-tech/">Menjadi Mahasiswa Hi-Tech</a>
      </li>
    
      <li class="post">
        <a href="/java/silabus-kuliah-pemrograman/">Silabus Kuliah Pemrograman</a>
      </li>
    
      <li class="post">
        <a href="/javascript/javascript-development-stack/">JavaScript Development Stack</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
