
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Di milis JUG, lagi-lagi ada yang tanya tentang load balancing, failover, dan clustering. Jawabannya masih sama sejak 10 tahun saya berkecimpung di &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://software.endy.muhardin.com/page/8/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36102948-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:software.endy.muhardin.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="my_site_title">
            Living life and make it better
        </span>
       
           <span class="my_site_subtitle">
             life, learn, contribute
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/calendar">Calendar</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/aplikasi/konsep-clustering/">Konsep Clustering</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-30T04:15:14+07:00" pubdate data-updated="true">Jan 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di milis JUG, lagi-lagi ada yang tanya tentang load balancing, failover, dan clustering. Jawabannya masih sama sejak 10 tahun saya berkecimpung di urusan coding-mengcoding. Jadi, baiklah saya tulis di blog saja, supaya next time bisa jadi referensi.</p>

<p>Ini sebetulnya dua hal yang berbeda.
Load balancing ya membagi beban.
Failover ya mencegah single point of failure.</p>

<h3>Load Balancing</h3>

<p>Load balancer terdiri dari satu balancer dan banyak worker.
Bebannya dibagi2 ke semua worker dengan algoritma yang biasanya bisa dipilih.
Bisa merata (round robin) bisa juga dengan bobot (weighted), misalnya worker X mendapat 2 kali worker Y karena dia specnya lebih tinggi.
Atau bisa juga dynamic, artinya si LB akan mengetes kondisi semua worker, mana yang kira2 sedang idle itu yang dikasi.
Mana yang sedang idle ini nanti ada lagi settingnya, apakah melihat CPU usage pakai SNMP, melihat ping response time, whatever.</p>

<p>Failover minimal harus ada 2 titik.
Kalo kita implement LB aja, point of failure (POF) nya adalah si LB.
Begitu LB nya mati, ya udah semua worker gak bisa diakses.
Untuk mencegah ini, LB nya harus ada 2, satu aktif satu standby (pasif).</p>

<p>Contoh aplikasi load balancer :</p>

<ul>
<li>HAProxy</li>
<li>ldirectord (Ultra Monkey)</li>
<li>Pound</li>
</ul>


<p>Contoh aplikasi lain yang bisa jadi load balancer :</p>

<ul>
<li>Apache (mod_proxy_balancer)</li>
<li>Nginx</li>
<li>lighttpd</li>
<li>bind (DNS Server)</li>
</ul>


<h3>Failover</h3>

<p>Contoh aplikasi failover :</p>

<ul>
<li><a href="http://www.linux-ha.org/wiki/Heartbeat">heartbeat</a></li>
<li><a href="http://clusterlabs.org/wiki/Main_Page">pacemaker</a></li>
<li><a href="http://corosync.github.io/corosync/">corosync</a></li>
<li><a href="http://www.pureftpd.org/project/ucarp">ucarp</a></li>
<li><a href="http://www.keepalived.org/">keepalived</a></li>
</ul>


<p>Failover artinya mengatasi kalau ada service yang mati. Ada dua jenis aplikasi untuk menangani failover :</p>

<ul>
<li>Network Oriented : keepalived, ucarp</li>
<li>Cluster Oriented : corosync, heartbeat</li>
</ul>


<p>Penjelasan lengkapnya bisa dibaca <a href="http://www.formilux.org/archives/haproxy/1003/3259.html">di sini</a>. Namun ringkasnya seperti ini:</p>

<p>Network oriented failover memastikan <strong>minimal satu</strong> service aktif, dan <strong>tidak apa-apa</strong> bila ada lebih dari satu service yang aktif. Ini cocok untuk dipasang di load balancer, karena load balancer tidak menyimpan state. Tidak masalah kalau user melihat ada dua LB, kadang diarahkan ke LB-1 dan kadang ke LB-2.</p>

<p>Cluster oriented failover memastikan <strong>hanya satu</strong> service yang aktif, dan <strong>tidak apa-apa</strong> bila tidak ada service yang aktif. Ini cocok untuk dipasang di database server, karena kita tidak mau database utama dan cadangan dua-duanya aktif. Bisa-bisa datanya tidak tersimpan dengan benar (<a href="http://en.wikipedia.org/wiki/Split-brain_(computing)">split brain</a>). Untuk lebih jelas tentang cara kerja cluster-oriented failover, bisa dibaca <a href="http://blog.clusterlabs.org/blog/2010/pacemaker-heartbeat-corosync-wtf/">di sini</a>.</p>

<p>Nah, mudah2an sampe di sini jelas bahwa load balancing dan failover itu dua hal yang tidak saling terkait (orthogonal) dan biasanya dikombinasikan untuk mendapatkan konfigurasi yang robust dan performant.</p>

<blockquote><blockquote><p>Setahu saya konsep2x Clustering diatas berlaku pada saat hit pertama.
Pertanyaan saya.. Bagaimana jika request sudah terlayani tetapi ditengah-tengah proses server tiba2x down.. Apakah proses tersebut langsung di alihkan ke server yang lagi up? Jika iya apakah proses akan di restart dari awal atau server yang sedang up bisa melanjutkan sisa dari proses yang belum dikerjakan di server yang telah down?</p></blockquote></blockquote>

<h3>Sticky Session</h3>

<p>Tidak selalu, tergantung konfigurasinya.
Ada konfigurasi sticky session.
Artinya, pada hit pertama, si user akan diberikan penanda, biasanya berbentuk cookie.
Pada hit berikutnya, LB akan melihat cookienya, dan mengarahkan ke server yang sebelumnya sudah mengurus si user ini.</p>

<p>Ada juga konfigurasi non-sticky.
Artinya tiap hit dianggap hit baru, dan didistribusikan ke semua server sesuai algoritma yang dipilih, round robin, weighted, atau dynamic, sesuai penjelasan di atas.</p>

<p>Mau pilih yang mana? Ya tergantung kemampuan LB nya.
Ada yang bisa 2-2 nya sehingga bisa pilih, dan ada juga yang rada stupid sehingga terpaksa pakai non-sticky.
Istilahnya, LBnya layer berapa? Kalo layer 7 biasanya bisa sticky, kalo layer 4 ya gak bisa.
Lebih jauh tentang urusan layer-layeran ini bisa dibaca <a href="http://blog.loadbalancer.org/why-layer-7-sucks/">di sini</a> dan <a href="http://1wt.eu/articles/2006_lb/">di sini</a></p>

<p>Nah, apa impact sticky vs non-sticky?
Ini pengaruhnya ke session data.
Session data adalah data sementara masing-masing user.
Karena sifatnya sementara, maka biasanya tidak disimpan secara persistent di tabel database.
Contoh paling klasik adalah isi shopping cart.
Itu barang belum diorder, tapi sudah dipilih, sehingga biasanya belum disimpan di database.</p>

<p>Kalo pake non-sticky, si user pertama milih barang di server X.
Pada saat dia pilih barang kedua, dilayani server Y.
Karena pilihan pertama ada di server X, ya pas dia pilih barang kedua, cuma tercatat 1 barang padahal harusnya 2.</p>

<p>Ini tidak terjadi kalo kita pakai sticky balancer.
Request kedua dan seterusnya akan diarahkan ke server X lagi.</p>

<p>Jadi, sticky atau non-sticky itu impactnya ke temporary data user, sering disebut dengan istilah session data atau user state.</p>

<p>Nah, setelah jelas apa dampaknya sticky vs non-sticky, mari kita lanjut ke pertanyaan selanjutnya.</p>

<blockquote><blockquote><p>Kalau untuk Java EE Application Server apakah untuk pertanyaan saya di atas sudah ada featurenya atau perlu ada tambahan produk lagi untuk bisa sharing informasi terhadap state suatu proses yang dijalankan di satu server sehingga jika server tersebut down proses bisa dilanjutkan di server yang lain tanpa merestart proses?</p></blockquote></blockquote>

<h3>Session Replication</h3>

<p>Mengenai urusan session/state management, ini sangat tergantung merek application server yang digunakan.
Secara umum, settingan standar appserver biasanya simpan data session di memori.
Kalau kita enable cluster, misalnya terdiri dari 4 worker, maka data session ini biasanya akan direplikasi ke satu worker lain.
Pada saat worker utama mati, request berikutnya akan diarahkan ke worker cadangannya, sehingga user gak kehilangan data belanjaan.
Biasanya, satu state itu disimpan ke 2 worker saja, bukan direplikasi ke semua untuk alasan efisiensi bandwidth.</p>

<p>Pada penjelasan di atas banyak sekali saya gunakan kata &#8216;biasanya&#8217;. Ini karena kapabilitas dan konfigurasi masing-masing merek appserver sangat berbeda sehingga sulit untuk menggeneralisir kondisinya.</p>

<p>Lalu bagaimana?
Saya biasanya mengambil pendekatan yang universal, yang jalan di semua appserver, sehingga tidak perlu pusing menghafal appserver apa bisa apa settingnya gimana.
Teknik universalnya sederhana: aplikasi webnya dibuat stateless.
Jangan ada simpan data di memori. Simpan semua di database, atau di distributed cache (misalnya memcached).</p>

<p>Di Java, data yang ada di memori antara lain : session variable, static variable, context variable.
Di PHP, CMIIW cuma session dan global variable aja.</p>

<p>Karena selama ini saya menggunakan teknik ini, jadi saya kurang up to date terhadap appserver apa bisa apa settingnya gimana.
Demikian juga tentang load balancer apa support sticky atau tidak, saya tidak pernah memikirkannya.
Pokoknya simpan state di distributed cache atau database, setelah itu mau pakai appserver Tomcat, Jetty, Glassfish, Weblogic, terserah.
Mau pakai load balancer Apache HTTPD, Nginx, lighty, HAProxy, Pound, Ultramonkey, juga terserah.</p>

<p>Demikian sekilas sharing mengenai load balancing dan clustering. Semoga menjadi cerah.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/development-stack-2011/">Development Stack 2011</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-25T20:33:18+07:00" pubdate data-updated="true">Jan 25<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Posting ini adalah update dari <a href="http://endy.artivisi.com/blog/java/stack-2008-1/">posting tiga tahun yang lalu</a>. Tidak banyak yang berubah dalam stack ini, yang bisa berarti dua hal: pilihan tiga tahun yang lalu sudah tepat atau malas belajar selama 3 tahun ini.
Mudah-mudahan alasannya yang pertama :D</p>

<blockquote><p>Update : Gradle tidak jadi dipakai, karena kita tidak mau maintain 2 skillset. Maven 2 ternyata stabil dan bekerja sesuai harapan. Hudson terlibat kerusuhan dengan Oracle, akhirnya fork jadi Jenkins.</p></blockquote>

<h3>Presentation Layer</h3>

<ul>
<li><p>Spring MVC</p></li>
<li><p>SiteMesh</p></li>
<li><p>Dojo Toolkit</p></li>
<li><p>ExtJS</p></li>
<li><p>Spring Security</p></li>
<li><p>Jasper Report</p></li>
<li><p>Jackson</p></li>
</ul>


<h3>Business Layer</h3>

<ul>
<li><p>Spring Framework</p></li>
<li><p>Hibernate</p></li>
</ul>


<h3>Library lain yang sering digunakan</h3>

<ul>
<li><p>Logback</p></li>
<li><p>Joda Time</p></li>
<li><p>Velocity</p></li>
<li><p>JPos</p></li>
</ul>


<h3>Infrastruktur</h3>

<ul>
<li><p>Version Control : Git + Gitosis</p></li>
<li><p>Testing Tools : JUnit, DBUnit, JMeter, Sonar</p></li>
<li><p>Issue Tracker : Redmine</p></li>
<li><p>Build Tools : <del>Gradle</del>, Maven</p></li>
<li><p>Continuous Integration : <del>Hudson</del> Jenkins</p></li>
<li><p>OS Programmer : Ubuntu Desktop</p></li>
<li><p>OS Server : Ubuntu Server, Debian</p></li>
</ul>


<h3>Deployment Target</h3>

<ul>
<li><p>Database Server : MySQL, Oracle</p></li>
<li><p>Application Server : Tomcat, Glassfish</p></li>
</ul>


<p>Praktis perubahan yang terjadi hanyalah dari Subversion ganti menjadi Git.
Nah, bagaimana menurut Anda? Pilihan tepat atau malas belajar?</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/aplikasi/sharing-repository-git/">Sharing Repository Git</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-11T17:47:43+07:00" pubdate data-updated="true">Jan 11<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Skenario : selama ini kita coding di laptop sendiri saja. Kemudian ada kebutuhan untuk kolaborasi dengan orang lain melalui Git. Bagaimana caranya? Baiklah mari kita bahas di artikel ini.</p>

<h2>Inisialisasi Repository Git</h2>

<p>Pertama, kita inisialisasi dulu repository Git. Masuk ke dalam folder project dan ketikkan</p>

<pre><code>git init
</code></pre>

<p>Git akan membuat repository kosong di dalam folder project, ditandai dengan adanya folder baru bernama .git</p>

<p>Selanjutnya, kita akan memasukkan semua file dan folder project kita ke dalam repository. Yang harus dimasukkan adalah file source code, baik itu Java, HTML, XML, dan sebagainya. Yang tidak perlu dimasukkan adalah file hasil kompilasi atau hasil generate. Kita perlu mendaftarkan file yang tidak ingin disimpan dalam file konfigurasi yang bernama .gitignore</p>

<p>File ini harus kita buat sendiri menggunakan text editor. Berikut contoh isi filenya, bila kita coding menggunakan Eclipse atau Netbeans</p>

<p>[gist id=773975]</p>

<p>Setelah kita setting ignore file, berikutnya kita masukkan semua file dan folder ke dalam antrian.</p>

<pre><code>git add . 
</code></pre>

<p>Kemudian, simpan ke repository</p>

<pre><code>git commit -m "commit pertama project XXX"
</code></pre>

<p>Project sudah tersimpan di repository Git di komputer lokal kita. Mari kita upload ke server, atau dikenal dengan istilah push.</p>

<h2>Share Repository</h2>

<p>Kita memerlukan server di mana kita memiliki ijin akses untuk melakukan push. Cara memperoleh ijin akses tidak dibahas pada artikel ini. Silahkan buat account di Github atau Gitorious. Bila ingin push ke repository perusahaan, minta informasinya pada admin Anda.</p>

<p>Setelah kita mendapatkan URL server yang bisa kita gunakan, daftarkan sebagai remote. Berikut perintahnya.</p>

<pre><code>git remote add &lt;namaremote&gt; &lt;URL&gt;
</code></pre>

<p>Contohnya seperti ini</p>

<pre><code>git remote add github git@github.com:endymuhardin/project-terbaru-saya.git
</code></pre>

<p>Pastikan remotenya sudah terdaftar dengan perintah berikut</p>

<pre><code>git remote -v
</code></pre>

<p>Terakhir, mari kita push dengan perintah berikut</p>

<pre><code>git push &lt;namaremote&gt; &lt;namabranch&gt;
</code></pre>

<p>Contohnya</p>

<pre><code>git push github master
</code></pre>

<p>Hore, project kita sudah naik ke server. Kita tinggal share URL tersebut ke rekan kerja kita.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/aplikasi/menggunakan-gist/">Menggunakan Gist</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-09T03:40:16+07:00" pubdate data-updated="true">Jan 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Gist adalah fitur yang disediakan oleh Github. Fungsi dasarnya mirip dengan pastebin, yaitu kita bisa paste text di sana, dan disharing dengan orang lain. Keunggulan Gist adalah dia sudah memiliki kemampuan version control dengan Git. Sehingga kita bisa fork, clone, modifikasi, dan push lagi ke repo utama dengan seluruh history tersimpan di sana.</p>

<p>Untuk bisa menggunakan Gist, kita harus memiliki account Github dulu. Setelah itu, kita bisa buat <a href="https://gist.github.com">gist di sini</a>.</p>

<p>Cara membuatnya tidak sulit. Cukup entri nama file, keterangan, dan isi text yang mau dishare.</p>

<p><img src="/images/uploads/2011/01/01-create-gist-300x204.png" title="" ></p>

<p>Setelah itu, tekan Create Public Gist. Gist kita akan siap digunakan.</p>

<p><img src="/images/uploads/2011/01/02-gist-created-300x207.png" title="" ></p>

<p>Gist yang sudah dibuat bisa dipasang di blog. Caranya, klik tombol embed.</p>

<p><img src="/images/uploads/2011/01/03-embed-link-300x205.png" title="" ></p>

<p>Nanti akan muncul textfield berisi tag HTML untuk dipasang di blog, kira-kira seperti ini tagnya:</p>

<pre><code>&lt;script src="https://gist.github.com/770832.js?file=HelloWorld.java"&gt;&lt;/script&gt;
</code></pre>

<p>Tag ini bisa langsung dipasang di blog kita. Hasilnya seperti di bawah ini.</p>

<p>Kelemahan cara ini adalah dia membutuhkan javascript, dan isi filenya tidak terindeks oleh spider. Untuk mengatasinya, kita gunakan <a href="http://wordpress.org/extend/plugins/embed-github-gist/">plugin wordpress ini</a>.</p>

<p>Setelah digunakan, kita cukup memasang tag khusus seperti dijelaskan di websitenya. Ini contoh hasilnya</p>

<p>[gist id=770832]</p>

<p>Sekilas tidak terlihat bedanya antara pakai plugin dan tidak. Tapi coba lihat source halaman ini, klik kanan kemudian View Source. Yang menggunakan plugin, source codenya benar-benar ada tulisannya. Sedangkan yang pakai tag script tidak ada source code hello worldnya.</p>

<p>Nah, kalau sudah pakai ini, tidak perlu bingung lagi mewarnai source code di blog. Kalau mau revisi, tinggal edit aja di Github, dan otomatis di blog langsung terupdate.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/aplikasi/instalasi-git-di-windows/">Instalasi Git Di Windows</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-07T18:28:25+07:00" pubdate data-updated="true">Jan 7<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Setelah kemarin kita bahas <a href="http://endy.artivisi.com/blog/lain/migrasi-subversion-ke-git/">migrasi di sisi server</a>, sekarang kita bahas instalasi di client. Kenapa yang dijelaskan hanya Windows, sedangkan Linux tidak? Well, ini karena di Linux instalasinya begitu mudah sehingga terlalu pendek kalau ingin dijadikan satu posting sendiri.</p>

<p>Gak percaya? Ini caranya install di Ubuntu. Buka command prompt, dan ketik</p>

<pre><code>sudo apt-get install git-core git-svn git-gui gitk
</code></pre>

<p>Sedikit konfigurasi standar.</p>

<pre><code>git config --global user.name "Endy Muhardin"
git config --global user.email "endy.muhardin@geemail.com"
git config --global color.ui "true"
</code></pre>

<p>Kemudian, bila kita belum punya public key, silahkan bikin seperti <a href="http://endy.artivisi.com/blog/linux/login-ssh-dengan-private-key/">tutorial di sini</a>.</p>

<p>Dan selesailah sudah. Seperti saya bilang sebelumnya, singkat dan sama sekali gak seru. Gak ada screenshotnya :D</p>

<p>Nah, mari kita bahas instalasi di Windows.</p>

<p>Pada intinya, langkah-langkahnya adalah sebagai berikut :</p>

<ol>
<li><p>Instalasi Putty : Ini kita perlukan untuk membuat public key. Public key digunakan untuk berinteraksi dengan repository git di server. Apa itu public key dan apa manfaatnya sedikit banyak sudah dibahas <a href="http://endy.artivisi.com/blog/linux/login-ssh-dengan-private-key/">di artikel ini</a>.</p></li>
<li><p>Instalasi Git : Ini adalah aplikasi Git nya sendiri. Ada dua varian, Cygwin dan MSysGit. Kita akan gunakan yang lebih populer, yaitu MSysGit.</p></li>
<li><p>Instalasi TortoiseGit : Seperti TortoiseSVN, ini adalah aplikasi GUI yang terintegrasi dengan Windows Explorer, sehingga pengelolaan repository dapat dilakukan di Windows Explorer seperti manipulasi file/folder biasa.</p></li>
</ol>


<h2>Instalasi Putty</h2>

<p>Putty bisa diunduh <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">di sini</a>. Pilih saja versi installer, supaya tidak pusing.</p>

<p>Putty ini akan kita gunakan untuk membuat pasangan public key dan private key. Caranya adalah menggunakan aplikasi PuttyGen. Jalankan PuttyGen, dan klik tombol Generate.
<img src="/images/uploads/2011/01/01-ssh-generate-keypair-300x290.png" title="Generate keypair" ></p>

<p>PuttyGen akan membuatkan public key dan private key. Save private keynya. Kita akan membutuhkan ini nanti. Klik tombol Save Private Key, dan simpan di folder mana saja.
<img src="/images/uploads/2011/01/02-ssh-save-keypair-300x210.png" title="" ></p>

<p>Terakhir, copy-paste text public keynya. Ini akan kita perlukan untuk dipasang di server supaya kita bisa mengakses repository di server, misalnya Github atau repository kantor.
<img src="/images/uploads/2011/01/03-ssh-export-public-key-300x236.png" title="" ></p>

<h2>Instalasi Git</h2>

<p>Pertama, <a href="http://code.google.com/p/msysgit/">unduh dulu MSysGit</a>. Di websitenya ada banyak file yang bisa diunduh. Kita perlu yang Git, bukan msysgit. Nama filenya diawali Git, seperti ini: Git-1.7.3.1-preview20101002.exe. Ambil saja versi yang terbaru.</p>

<p>Setelah diunduh, tentu kita jalankan. Berikut screenshot next-next seperti biasa.</p>

<p><img src="/images/uploads/2011/01/01-msysgit-install-welcome-300x230.png" title="" ></p>

<p><img src="/images/uploads/2011/01/02-msysgit-install-component-300x233.png" title="" ></p>

<p><img src="/images/uploads/2011/01/03-msysgit-install-path-300x232.png" title="" ></p>

<p><img src="/images/uploads/2011/01/04-msysgit-install-crlf-300x232.png" title="" ></p>

<h2>Instalasi TortoiseGit</h2>

<p>TortoiseGit bisa <a href="http://code.google.com/p/tortoisegit/">diunduh di sini</a>.
Setelah selesai mengunduh, lagi-lagi klik next-next.</p>

<p><img src="/images/uploads/2011/01/01-tortoisegit-install-welcome-300x233.png" title="" ></p>

<p><img src="/images/uploads/2011/01/02-tortoisegit-install-sshclient-300x231.png" title="" ></p>

<p>Sampai di sini, instalasi Git sudah selesai. Tapi masih ada langkah tambahan supaya kita bisa melakukan clone dari repository server (misalnya Github).</p>

<h2>Clone dari Github</h2>

<p>Untuk bisa clone dari github, pertama kali kita harus punya account Github. Silahkan <a href="https://github.com/plans">daftar dulu</a>.</p>

<p>Setelah punya account, login, dan kita akan melihat dashboard.</p>

<p><img src="/images/uploads/2011/01/01-github-dashboard-300x208.png" title="" ></p>

<p>Klik account setting, dan masuk ke menu SSH Public Keys</p>

<p><img src="/images/uploads/2011/01/02-github-add-pubkey-300x206.png" title="" ></p>

<p>Pastekan public key yang sudah kita export menggunakan PuttyGen di atas. Setelah diadd, public key kita akan terdaftar. Kita boleh pasang public key banyak-banyak, karena biasanya satu public key mencerminkan satu komputer. Bisa saja kita punya PC dan juga Laptop.
<img src="/images/uploads/2011/01/03-github-add-pubkey-completed-300x201.png" title="" ></p>

<p>Setelah public key didaftarkan, selanjutnya kita lihat repository yang kita punya.
<img src="/images/uploads/2011/01/04-github-repositories-300x183.png" title="" ></p>

<p>Kalau belum punya repository, Anda bisa fork <a href="https://github.com/endymuhardin/belajarGit">repository belajarGit punya saya</a>, sehingga nanti Anda punya repo belajarGit sendiri.</p>

<p>Setiap repository punya URL untuk melakukan clone. Copy paste URL clone repository.
<img src="/images/uploads/2011/01/05-github-repo-belajarGit-300x208.png" title="" ></p>

<p>Untuk melakukan clone, buka Windows Explorer, klik kanan, dan pilih Git Clone.
<img src="/images/uploads/2011/01/03-tortoisegit-use-clone-300x208.png" title="" ></p>

<p>Masukkan URL yang tadi kita copy dari Github, dan load private key yang kita buat dengan PuttyGen.</p>

<p><img src="/images/uploads/2011/01/04-tortoisegit-clone-info-300x200.png" title="" ></p>

<p>Putty akan melakukan komunikasi dengan Github. Kalau kita belum pernah clone dari Github sebelumnya, Putty akan menanyakan apakah kita ingin menerima koneksi dari Github. Jawab saja Yes.
<img src="/images/uploads/2011/01/05-tortoisegit-clone-save-host-key-300x210.png" title="" ></p>

<p>Setelah kita jawab Yes, TortoiseGit akan mendownload repository dari Github untuk kita pakai di local, yang lebih dikenal dengan istilah clone. Ini ditunjukkan dengan progress bar kura-kura salto. Jumlah kura-kura yang salto tergantung dari ukuran repository kita. Semakin besar repositorynya, semakin banyak kura-kura yang salto. Bersabarlah, dan tunggu sampai semua kura-kura selesai melakukan aksinya.</p>

<p><img src="/images/uploads/2011/01/06-tortoisegit-clone-complete-300x211.png" title="" ></p>

<p>Sekarang repository sudah ada di local, dan siap digunakan. Bagaimana cara menggunakannya, stay tuned. Akan dibahas di posting berikutnya.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/aplikasi/migrasi-subversion-ke-git/">Migrasi Subversion Ke Git</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-03T06:02:23+07:00" pubdate data-updated="true">Jan 3<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di tahun yang baru ini, kami di ArtiVisi juga beralih menggunakan version control baru, yaitu Git.
Menggantikan Subversion yang sudah kita gunakan sejak 2008.</p>

<p>Ada banyak keunggulan Git dibandingkan Subversion, diantaranya:</p>

<ul>
<li><p>offline operation. Git adalah distributed/decentralized version control system (DVCS), artinya tidak membutuhkan server terpusat untuk bisa bekerja. Keunggulan ini berakibat pada keunggulan berikutnya, yaitu:</p></li>
<li><p>commit sesuai task, bukan sesuai koneksi internet. Dulu, karena koneksi internet terbatas, programmer commit hanya pada saat ada internet. Akibatnya satu commit berisi perubahan untuk banyak task, tercampur aduk tidak jelas peruntukannya. DVCS memungkinkan programmer untuk commit walaupun tidak ada koneksi internet, dan melakukan sinkronisasi pada saat offline.</p></li>
<li><p>fitur staging area di Git, memungkinkan kita untuk mengatur isi commit secara detail.</p></li>
<li><p>fitur rebase untuk mengatur commit. Commit yang teratur akan memudahkan review.</p></li>
<li><p>branch dan merge yang lebih baik daripada subversion. Karena branch dan merge mudah, maka kita bisa menerapkan berbagai teknik workflow dalam mengelola development.</p></li>
<li><p>website social coding. Github dan Gitorious merupakan Facebook-nya para programmer. Untuk bisa terlibat di dalamnya, terlebih dulu kita harus bisa Git.</p></li>
</ul>


<p>Selain Git, ada juga DVCS lain seperti Mercurial (hg), Bazaar (bzr), dsb. Git dipilih karena :</p>

<ul>
<li><p>popularitas. Semakin populer, tutorial dan aplikasi pendukung semakin banyak, sehingga semakin nyaman digunakan. Saat ini yang paling populer cuma dua, yaitu git dan hg.</p></li>
<li><p>local/named branch. Ini fitur penting, tapi entah kenapa tidak ada di core hg. Sepertinya ada di extension, tapi yang jelas merupakan workaround dan bukan didesain sejak awal. Tanpa named branch, pilihan workflow menjadi terbatas.</p></li>
<li><p>Social coding Git (Github dan Gitorious) jauh lebih superior daripada Mercurial (Bitbucket)</p></li>
</ul>


<p>Beberapa faktor di atas adalah alasan kenapa Git yang dipilih.</p>

<p>Baiklah, sekarang saatnya migrasi. Kita akan mengkonversi repository Subversion menjadi repository Git.
Berikut langkah-langkah yang akan kita lakukan:</p>

<ol>
<li><p>Dump repository Subversion</p></li>
<li><p>Restore lagi di laptop supaya cepat</p></li>
<li><p>Buat authorsfile</p></li>
<li><p>Buat ignore file</p></li>
<li><p>Clone tanpa metadata</p></li>
<li><p>Konversi branch</p></li>
<li><p>Konversi tags</p></li>
<li><p>Clone hasil konversi menjadi bare repository</p></li>
</ol>


<h2>Dump repository Subversion</h2>

<p>Seperti biasa, sebelum melakukan apapun, lakukan backup dulu. Just in case.
Perintahnya gampang.</p>

<pre><code>svnadmin dump /path/ke/repository | bzip2 -c9 &gt; dump-repository-yyyyMMdd.dmp.bz2
</code></pre>

<h2>Restore lagi di laptop/PC supaya cepat</h2>

<p>Langkah ini optional, kalau kita ingin melakukannya di komputer kita sendiri, bukan di server.
Tapi sebaiknya dilakukan, karena nanti kita akan checkout beberapa kali yang pasti membutuhkan waktu lama jika dilakukan ke server.</p>

<p>Perintah restore gampang.</p>

<pre><code>bzcat dump-repository-yyyyMMdd.dmp.bz2 | svnadmin load /path/ke/repo/svn/di/lokal
</code></pre>

<h2>Buat authorsfile</h2>

<p>Setelah kita memiliki repository Subversion, kita perlu mengambil daftar nama orang-orang yang pernah commit. Ini akan kita butuhkan pada waktu konversi. Nama committer ini diambil dari hasil checkout Subversion. Jadi mari kita checkout dulu.</p>

<pre><code>svn checkout file:///path/ke/repo/svn/di/lokal checkout-project-svn
</code></pre>

<p>Karena lokal, harusnya hanya membutuhkan beberapa menit saja.</p>

<p>Setelah dilakukan checkout, kita membutuhkan script untuk mengambil nama committer. Berikut isi scriptnya, simpan saja dengan nama extract-svn-authors.sh</p>

<pre><code>#!/usr/bin/env bash
authors=$(svn log -q | grep -e '^r' | awk 'BEGIN { FS = "|" } ; { print $2 }' | sort | uniq)
for author in ${authors}; do
  echo "${author} = NAME &lt;USER@DOMAIN&gt;";
done
</code></pre>

<p>Jalankan script tersebut di dalam folder hasil checkout.</p>

<pre><code>cd checkout-project-svn
sh /path/ke/script/extract-svn-authors.sh &gt; nama-committers.txt 
</code></pre>

<p>Ini akan menghasilkan file nama-committers.txt yang berisi nama committer seperti ini :</p>

<pre><code>endy = NAME &lt;USER@DOMAIN&gt;
</code></pre>

<p>Editlah file ini supaya mencerminkan nama dan email yang benar, seperti ini :</p>

<pre><code>endy = Endy Muhardin &lt;endy.muhardin@geemail.com&gt;
</code></pre>

<h2>Buat ignore file</h2>

<p>Dalam mengerjakan project, ada file-file yang ada di folder kerja, tapi tidak kita masukkan ke repository. Misalnya file hasil kompilasi, setting IDE, dan sebagainya. File dan folder hasil generate ini biasanya kita daftarkan di ignore list, supaya tidak ikut dicommit ke repository. Kita perlu mengkonversi format ignore di Subversion (svn property ignore) menjadi format ignore versi Git (yaitu file .gitignore).</p>

<p>Untuk membuatnya, kita clone dulu repository Subversion menjadi repository Git. Ini dilakukan di folder yang berbeda dengan hasil checkout Subversion di langkah sebelumnya.</p>

<pre><code>cd .. 
git svn clone --stdlayout -A nama-committers.txt file:///path/ke/repo git-svn-migrasi-project-dengan-metadata
</code></pre>

<p>Setelah diclone, konversi ignore list nya.</p>

<pre><code>cd git-svn-migrasi-project-dengan-metadata
git svn show-ignore &gt; .gitignore
</code></pre>

<h2>Clone tanpa metadata</h2>

<p>Selanjutnya, kita lakukan clone lagi. Kali ini tanpa menyertakan metadata, sehingga hasilnya bersih. Metadata ini digunakan bila kita ingin tetap commit ke repository Subversion, tapi ingin menggunakan Git sebagai frontend.</p>

<p>Perintahnya mirip seperti sebelumnya, kali ini kita tambahkan opsi tanpa metadata.</p>

<pre><code>cd .. 
git svn clone --no-metadata --stdlayout -A nama-committers.txt file:///path/ke/repo git-svn-migrasi-project-tanpa-metadata
</code></pre>

<p>Ini akan menghasilkan folder git-svn-migrasi-project-tanpa-metadata berisi repository Subversion yang sudah dikonversi menjadi repository Git. Semua langkah selanjutnya akan dilakukan di dalam folder ini.</p>

<p>Setelah selesai, kita masukkan file .gitignore ke repo Git yang baru ini.</p>

<pre><code>cd git-svn-migrasi-project-tanpa-metadata
cp ../git-svn-migrasi-project-dengan-metadata/.gitignore ./
git add . 
git commit -m "add ignore list"
</code></pre>

<h2>Konversi branch</h2>

<p>Branch yang ada di Subversion harus kita konversi menjadi branch di Git.
Berikut perintahnya.</p>

<pre><code>git branch -r | grep -v tags | sed -rne 's, *([^@]+)$,\1,p' | while read branch; do echo "git branch $branch $branch"; done | sh
</code></pre>

<p>Verifikasi hasilnya dengan perintah ini.</p>

<pre><code>git branch -a
</code></pre>

<p>Seharusnya semua branch yang ada di repository Subversion akan terlihat di dalam repository Git ini.</p>

<h2>Konversi tags</h2>

<p>Lakukan perintah berikut untuk mengkonversi tag Subversion menjadi tag Git.</p>

<pre><code>git branch -r | sed -rne 's, *tags/([^@]+)$,\1,p' | while read tag; do echo "git tag $tag 'tags/${tag}^'; git branch -r -d tags/$tag"; done | sh
</code></pre>

<p>Verifikasi dengan perintah ini</p>

<pre><code>git tag -l
</code></pre>

<p>Pastikan semua tag yang tadinya ada di repository Subversion sudah terdaftar di repository Git.</p>

<h2>Clone hasil konversi menjadi bare repository</h2>

<p>Setelah nama committer, ignore list, branch, dan tags berhasil kita pindahkan, inilah langkah terakhir. Kita clone sekali lagi menjadi repository bare supaya bisa dishare dengan orang lain. Biasanya repository bare ini kita publish dengan Gitosis, gitweb, atau aplikasi server lainnya.</p>

<p>Perintah ini dilakukan di luar repository Git yang kita gunakan pada langkah sebelumnya.</p>

<pre><code>cd .. 
git clone --bare git-svn-migrasi-project-tanpa-metadata nama-project.git
</code></pre>

<p>Ini akan menghasilkan satu folder dengan nama nama-project.git berisi repository Git yang siap dishare.</p>

<p>Demikian posting tahun baru. Semoga kita semua lebih sukses di tahun 2011 ini.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/prototyping/">Prototyping</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-07T01:41:17+07:00" pubdate data-updated="true">Jul 7<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pada waktu kita melakukan requirement gathering, harapan kita adalah agar requirement yang kita dapatkan di fase requirement tidak jauh bergeser dari requirement final setelah project closing. Kalau pergeserannya jauh, akan mengakibatkan waktu dan biaya pengerjaan project menjadi molor dan akibatnya kedua belah pihak akan dirugikan.</p>

<p>Pergeseran requirement ini bisa disebabkan beberapa hal, misalnya :</p>

<ol>
<li><p>business analyst (BA) kurang pengalaman, sehingga tidak bisa mengidentifikasi varian-varian skenario. Akibatnya terjadi banyak &#8216;hidden requirement&#8217;</p></li>
<li><p>business analyst kurang teliti, sehingga salah memahami penjelasan user</p></li>
<li><p>Perubahan bisnis client, sehingga requirementnya juga berubah</p></li>
<li><p>perbedaan persepsi antara user dan analyst atau programmer</p></li>
</ol>


<p>Untuk masalah 1 dan 2, solusinya adalah dengan mengganti BA dengan orang yang lebih berpengalaman. Newbie sebaiknya tidak menjadi BA. Bolehlah magang BA, tapi jangan diandalkan untuk jadi BA utama.</p>

<p>Poin 3 juga biasanya tidak masalah. Client biasanya cukup tahu diri kalau terjadi hal ini, sehingga tidak keberatan dimintai charge tambahan.</p>

<p>Nah untuk poin 4, biasanya sulit dideteksi sampai aplikasi kita deliver. Sering terjadi, usernya OK OK saja pada fase requirement, dan tiba-tiba pada waktu kita deliver aplikasinya, dia langsung bingung karena aplikasinya &#8216;aneh&#8217;.</p>

<p>Agar poin 4 ini tidak terjadi, sebaiknya kita melakukan prototyping. Bagaimana cara melakukan prototyping yang baik?</p>

<p>Prototyping itu idealnya :</p>

<ol>
<li><p>Murah meriah dan cepat
Dalam 1 hari kita harus bisa menggambar minimal 10 screen.
Begitu usernya selesai ngomong/gambar di papan tulis, screennya juga harus langsung jadi.
Jangan sampai effort untuk prototyping lebih besar dari effort untuk coding.</p></li>
<li><p>Gampang diubah
Tujuan prototype adalah supaya user bisa merasakan seperti apa aplikasinya nanti.
Kalau dirasakan kurang sesuai, tentunya dia ingin mengubahnya.
Nah, jangan sampai minta geser tombol aja harus nunggu 30 menit.</p></li>
<li><p>Mirip aslinya.
Kalo ini lebih ke sisi development.
Biar efisien, begitu prototype sign off, kita bisa mulai paralel coding dan bikin user manual.
Kalo prototypenya udah bener2 mirip, bisa langsung discreenshot dan dipasang di user manual.
Jadi begitu aplikasi jadi, user manual juga selesai.</p></li>
<li><p>Terlihat belum selesai
Ini agak kontradiktif dengan tips #3. Kalau prototype kita sangat mirip aplikasi betulan, client akan memiliki persepsi bahwa aplikasinya sudah hampir selesai. Padahal belum ada coding sama sekali. Oleh karena itu, sangat penting kita tekankan ke client bahwa masih ada jangka waktu yang lama sebelum aplikasi betulannya selesai.</p></li>
</ol>


<p>Ada beberapa tools yang bisa digunakan untuk prototyping, yaitu</p>

<h2><a href="http://www.netbeans.org">Netbeans</a></h2>

<p>Untuk project aplikasi desktop, inilah yang biasa kami gunakan di ArtiVisi. Screen dapat dibuat dengan sangat cepat, lengkap dengan behavior standar seperti popup dialog, scroll table, dsb.</p>

<p>Untuk project web, biasanya kita langsung coding di HTML dan Dojo, tentunya tanpa koneksi ke back end.</p>

<p>Sebagai nilai tambah lain, setelah prototype di-approve client, programmer bisa langsung meneruskan coding.</p>

<h2><a href="http://www.balsamiq.com/products/mockups">Balsamiq Mockup</a></h2>

<p>Tools ini berbayar dan dijalankan menggunakan Adobe AIR.</p>

<p><a href="http://pencil.evolus.vn/en-US/Home.aspx">Pencil</a>
Tools ini lumayan bagus, dijalankan sebagai Firefox Add Ons. Sudah ada palette untuk berbagai UI component seperti combo box, text area, dsb. Setelah selesai menggambar, kita bisa langsung mengekspornya menjadi image.</p>

<p>Berikut contoh mockup yang baru saja saya buat menggunakan Pencil.</p>

<p>Ini versi &#8216;bagus&#8217; yang mirip aslinya.</p>

<p><img src="/images/uploads/2010/07/windows_login-300x238.png" title="Mockup Login Screen ala Windows XP" ></p>

<p>Supaya client sadar bahwa ini adalah prototype, kita bisa gunakan versi yang coret-coretan.</p>

<p><img src="/images/uploads/2010/07/sketchy_login-300x238.png" title="Mockup Versi Coretan" ></p>

<p>Source file untuk mockup di atas bisa <a href="http://endy.artivisi.com/downloads/contoh/mockup/pencil-demo.ep">diunduh di sini</a>.</p>

<p>Demikianlah sedikit tips dan trik. Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/java/mendebug-database-production/">Mendebug Database Production</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-30T14:44:11+07:00" pubdate data-updated="true">Jun 30<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Suatu aplikasi, walaupun sudah go-live di environment production, tetap bisa saja mengalami error dan bug. Bug ini seringkali tidak ditemukan di environment development karena berbagai hal, misalnya variasi data, jumlah data, dan sebagainya.</p>

<p>Langkah pertama ketika kita mengetahui ada bug tentunya adalah melokalisir masalah. Pada kondisi mana saja bug tersebut muncul. Setelah itu, kita dapat memfokuskan pencarian masalah di lokasi tersebut. Ini lebih efisien daripada kita harus menelusuri keseluruhan sistem.</p>

<p>Misalnya kita sudah berhasil melokalisir masalah, yaitu transaksi di bulan tertentu. Langkah selanjutnya adalah memindahkan data production di lokasi tersebut ke environment development. Ini kita lakukan supaya kita bebas bereksperimen dengan data tersebut tanpa khawatir membahayakan data production.</p>

<p>Masalahnya, tools backup database yang tersedia biasanya tidak bisa digunakan untuk mengambil sebagian data. Walaupun bisa (mysqldump menyediakan opsi where untuk membatasi record yang diambil), biasanya terbatas hanya di satu tabel saja. Sedangkan untuk bisa merestore-nya di development, kita butuh semua relasinya.</p>

<p>Sebagai contoh, coba lihat skema berikut.</p>

<p><img src="/images/uploads/2010/06/diagram-er-payment.png" title="" ></p>

<p>Untuk mengambil data payment, tentunya kita juga harus menarik data lain yang berelasi dengannya, yaitu di tabel grup loket, loket, payment value, payment info dan fee loket. Ini sangat sulit dilakukan, apalagi kalau data payment tersebut jumlahnya ratusan ribu record.</p>

<p>Untunglah ada tools untuk mengatasi masalah ini, namanya <a href="http://jailer.sourceforge.net/">Jailer</a>. Dengan menggunakan Jailer, kita dapat menentukan tabel mana yang akan diambil datanya (payment), kriteria pengambilan (bulan tertentu saja), dan relasi mana saja yang ingin kita ambil. Hasilnya adalah satu set data lengkap dengan dependensinya yang bisa kita restore di development.</p>

<h2>Persiapan Jailer</h2>

<p>Pertama, tentunya kita unduh dulu Jailer di websitenya. Jangan lupa teriakkan, &#8220;Hidup Open Source !!!&#8221;, karena aplikasi ini tersedia secara gratis berkat gerakan open source.</p>

<p>Setelah berhasil diunduh, extract ke folder tertentu. Jailer tidak menyertakan driver untuk koneksi ke database, sehingga kita harus sediakan sendiri. Karena saya menggunakan MySQL, saya masukkan file mysql-connector.jar ke dalam folder lib. Kita mengikutkan driver database ke folder Jailer karena nantinya folder ini akan kita pack dan upload ke server production.</p>

<p>Jailer ini akan kita jalankan di mesin development yang sudah terisi skema database. Kita akan coba dulu ambil data di development, kalau sudah sukses baru kita jalankan di production.</p>

<p>Ada dua script untuk menjalankan jailer, yaitu jailerGUI dan jailer. jailerGUI digunakan untuk mendesain pengambilan data, sedangkan jailer adalah antarmuka command line untuk menjalankan pengambilan data. Karena kita ingin mendesain proses pengambilannya, kita gunakan jailerGUI.</p>

<pre><code>$ sh jailerGUI.sh
</code></pre>

<p>Berikut adalah tampilan awal Jailer.</p>

<p><img src="/images/uploads/2010/06/01-jailer-welcome-300x206.png" title="Jailer Welcome Page" ></p>

<p>Jailer memberitahu kita bahwa belum ada data model yang bisa dikerjakan, dan menyarankan kita untuk menganalisa database. Klik Analyze Database. Selanjutnya Jailer akan meminta informasi cara koneksi ke database.</p>

<p><img src="/images/uploads/2010/06/02-analyze-db-300x134.png" title="Analyze Database" ></p>

<p>Isikan informasi koneksi database dan driver yang digunakan. Driver yang kita gunakan adalah yang tadi sudah kita copy ke folder lib.</p>

<p><img src="/images/uploads/2010/06/03-mysql-connectorj-300x128.png" title="Konfigurasi MySQL" ></p>

<p>Klik OK untuk menganalisa database.</p>

<p><img src="/images/uploads/2010/06/04-connect-to-db-300x212.png" title="Koneksi ke database" ></p>

<p>Setelah itu, Jailer akan menghubungi database untuk mengambil informasi. Lognya akan ditampilkan di log output. Jailer akan memberi tahu kita tabel-tabel yang tidak ada primary keynya. Jailer tidak dapat memproses tabel tanpa primary key.</p>

<p><img src="/images/uploads/2010/06/05-autodetect-result-300x233.png" title="Hasil Autodetect" ></p>

<p>Klik tabel yang berwarna merah, dan definisikan primary keynya. Primary key yang kita definisikan di sini hanya digunakan Jailer, sehingga tidak perlu khawatir skema aslinya akan berubah.</p>

<p><img src="/images/uploads/2010/06/06-edit-table-pk-300x200.png" title="Add Primary Key" ></p>

<p>Setelah itu, klik OK. Jailer akan menampilkan screen Extraction Model Editor. Pilih tabel payment, di dropdown subject, karena inilah tabel yang akan kita gunakan sebagai pusat extraction.</p>

<p><img src="/images/uploads/2010/06/07-payment-relasi-300x206.png" title="Pilih tabel yang ingin diimport" ></p>

<p>Jailer mendeteksi relasi antar tabel berdasarkan constraint foreign key yang kita pasang di database. Kadangkala ada tabel-tabel yang berelasi, namun tidak ada constraintnya. Entah karena malas mendefinisikan, atau memang sengaja tidak dikaitkan. Kita bisa mendaftarkan relasi tanpa constraint ini dengan membuka lagi Data Model Editor, kemudian klik Add di kotak Association sebelah kanan.</p>

<p><img src="/images/uploads/2010/06/08-relasi-non-fk-300x234.png" title="Relasi non Foreign Key" ></p>

<p>Setelah diklik OK, maka skema relasi di Extraction Model Editor akan berubah sesuai relasi yang ditambahkan. Sama dengan definisi primary key di atas, relasi ini hanya disimpan oleh Jailer dan tidak diaplikasikan ke skema database.</p>

<p><img src="/images/uploads/2010/06/09-payment-relasi-2-300x168.png" title="Relasi Payment - Loket" ></p>

<p>Kita perlu mendefinisikan batasan record payment yang akan diambil, yaitu yang terjadi di bulan Juni 2010. Dalam bentuk SQL, berikut adalah query yang digunakan</p>

<pre><code>select * from payment where date_format(paid_date, '%Y-%m') = '2010-06'
</code></pre>

<p>Kita ambil expression setelah where dan pasang di textfield where dalam Extraction Model Editor.</p>

<p><img src="/images/uploads/2010/06/10-payment-where-300x206.png" title="Restriction" ></p>

<p>Simpan dulu extraction modelnya.</p>

<p><img src="/images/uploads/2010/06/11-save-extraction-300x208.png" title="Save Extraction" ></p>

<p>Beri nama yang representatif, misalnya payment-201006. Jailer akan menyimpan extraction model ini dalam format csv. Kalau sudah memahami formatnya, kita bisa membuatnya dengan text editor tanpa GUI (kalau mau).</p>

<p>Setelah tersimpan, kita bisa klik Export Data sehingga memunculkan dialog berikut.</p>

<p><img src="/images/uploads/2010/06/12-data-export-300x283.png" title="Export Data" ></p>

<p>Di screen tersebut kita bisa mengatur konfigurasi pengambilan data. Bagi saya, nilai defaultnya sudah memadai sehingga tidak ada yang diubah.</p>

<p>Di box paling bawah ada command line yang bisa kita copy-paste untuk dijalankan tanpa GUI. Copy saja isinya ke text file untuk digunakan nanti.</p>

<p>Yang harus kita isi di screen ini adalah textfield Into. Ini adalah nama file yang akan menampung script SQL berisi data yang diinginkan. Isi saja dengan nama payment-201006.sql.</p>

<p><img src="/images/uploads/2010/06/13-export-into-300x205.png" title="Export Into File" ></p>

<p>Setelah itu, klik Export Data. Jailer akan segera bekerja dan menampilkan hasilnya dalam bentuk tree.</p>

<p><img src="/images/uploads/2010/06/14-export-result-300x168.png" title="Hasil Export" ></p>

<p>Di situ kita bisa lihat berapa row yang akan diambil dari masing-masing tabel.
Seperti kita lihat, cukup signifikan, yaitu 2000an record. Ini disebabkan karena jailer mengambil record secara rekursif tanpa ada batasan.</p>

<p>Setelah dianalisa, kita hanya ingin mengambil tabel-tabel yang berkaitan langsung, yaitu payment, payment_info, payment_value, dan fee_loket. Sedangkan tabel sisanya dapat diabaikan karena bersifat pelengkap atau master data yang sudah ada di database development.</p>

<p>Dengan melihat ke tree-nya, kita bisa memutus relasi fee_loket ke loket, karena dari situlah semua data lain akan ikut terbawa.</p>

<p>Tutup screennya, dan kembali ke Extraction Model Editor.</p>

<p><img src="/images/uploads/2010/06/15-restricted-dependency-300x168.png" title="Membatasi Relasi" ></p>

<p>Di kotak Association, expand node yang ingin kita putuskan, yaitu fee loket. Klik relasi loket, dan centang checkbox disabled di pojok kiri bawah. Setelah itu, jalankan lagi Export Data.</p>

<p><img src="/images/uploads/2010/06/16-restricted-dependency-warning-300x153.png" title="Warning Restricted Dependency" ></p>

<p>Jailer akan mengingatkan bahwa dengan membatasi dependensi, referential integrity akan rusak, karena relasi foreign key dari fee_loket ke loket akan terputus. Klik saja Yes, karena di database development kita tabel loket sudah terisi lengkap.</p>

<p>Inilah hasilnya</p>

<p><img src="/images/uploads/2010/06/17-restricted-export-result-300x82.png" title="Hasil Export setelah dibatasi" ></p>

<p>Seperti kita lihat di atas, kita cuma mendapatkan 84 record dan pengambilan data berhenti di tabel fee_loket.
Periksa output payment-201006.sql di folder Jailer untuk memastikan hasilnya sudah benar.</p>

<p>Setelah sukses dijalankan di database development, compress lagi jailer yang sudah dimodifikasi barusan dan upload ke server production. Setibanya di server production, extract, kemudian jalankan script yang tadi kita copy-paste.</p>

<p>Kalau baru pertama kali dijalankan, script ini akan menimbulkan error sebagai berikut :</p>

<pre><code>$ ./export-payment-201006.sh 
2010-06-28 14:15:08,114 [main] INFO   - Jailer 3.4.5
2010-06-28 14:15:08,117 [main] INFO   - added 'lib/mysql-connector-java-5.1.6-bin.jar' to classpath
2010-06-28 14:15:08,119 [main] INFO   - exporting 'extractionmodel/payment-201006.csv' to 'payment-201006.sql'
2010-06-28 14:15:08,700 [main] INFO   - begin guessing SQL dialect
2010-06-28 14:15:08,711 [main] INFO   - end guessing SQL dialect
2010-06-28 14:15:08,718 [main] ERROR  - Can't find working tables! Run 'bin/jailer.sh create-ddl' and execute the DDL-script first!
java.lang.RuntimeException: Can't find working tables! Run 'bin/jailer.sh create-ddl' and execute the DDL-script first!
    at net.sf.jailer.entitygraph.EntityGraph.create(EntityGraph.java:122)
    at net.sf.jailer.Jailer.export(Jailer.java:1142)
    at net.sf.jailer.Jailer.jailerMain(Jailer.java:1064)
    at net.sf.jailer.Jailer.jailerMain(Jailer.java:989)
    at net.sf.jailer.Jailer.main(Jailer.java:967)
Caused by: java.sql.SQLException: "Table 'ppobgsp_test.JAILER_GRAPH' doesn't exist" in statement "Insert into JAILER_GRAPH(id, age) values (2104021762, 1)"
    at net.sf.jailer.database.Session.executeUpdate(Session.java:470)
    at net.sf.jailer.entitygraph.EntityGraph.create(EntityGraph.java:120)
    ... 4 more
Error: java.lang.RuntimeException: Can't find working tables! Run 'bin/jailer.sh create-ddl' and execute the DDL-script first!
2010-06-28 14:15:08,724 [main] ERROR  - working directory is /opt/downloads/java/tools/test/integration-test/jailer
</code></pre>

<p>Ini disebabkan karena Jailer ternyata membuat beberapa tabel di database untuk kebutuhan internalnya. Ini dapat dilihat pada database development kita.</p>

<p><img src="/images/uploads/2010/06/18-jailer-tables-300x226.png" title="Tabel Internal Jailer" ></p>

<p>Untuk menggenerate tabel di atas, kita jalankan jailer dengan opsi create-ddl. Ini akan menghasilkan SQL di layar. SQL ini harus kita jalankan di database production supaya tabelnya terbentuk.</p>

<pre><code>$ sh jailer.sh create-ddl
DROP TABLE JAILER_ENTITY;
DROP TABLE JAILER_DEPENDENCY;
DROP TABLE JAILER_SET;
DROP TABLE JAILER_GRAPH;
DROP TABLE JAILER_CONFIG;
DROP TABLE JAILER_TMP;

CREATE TABLE JAILER_CONFIG
(
   jversion        VARCHAR(20),
   jkey            VARCHAR(200),
   jvalue          VARCHAR(200)
) ;

INSERT INTO JAILER_CONFIG(jversion, jkey, jvalue) values('3.4.5', 'magic', '837065098274756382534403654245288');

CREATE TABLE JAILER_GRAPH
(
   id              INTEGER NOT NULL,
   age             INTEGER NOT NULL

--   ,CONSTRAINT jlr_pk_graph PRIMARY KEY(id)
) ;

CREATE TABLE JAILER_ENTITY
(
   r_entitygraph   INTEGER NOT NULL,

   PK0 BIGINT , PK1 VARCHAR(255) , PK2 VARCHAR(255) , PK3 INT , PK4 VARCHAR(255) , PK5 BIGINT ,
   birthday        INTEGER NOT NULL,
   type            VARCHAR(120) NOT NULL,

   PRE_PK0 BIGINT , PRE_PK1 VARCHAR(255) , PRE_PK2 VARCHAR(255) , PRE_PK3 INT , PRE_PK4 VARCHAR(255) , PRE_PK5 BIGINT ,
   PRE_TYPE        VARCHAR(120),
   orig_birthday   INTEGER,
   association     INTEGER

-- ,  CONSTRAINT jlr_fk_graph_e FOREIGN KEY (r_entitygraph) REFERENCES JAILER_GRAPH(id)
) ;

CREATE INDEX jlr_enty_brthdy ON JAILER_ENTITY (r_entitygraph, birthday, type) ;
CREATE INDEX jlr_enty_upk1 ON JAILER_ENTITY (r_entitygraph , PK0, PK1, PK2, PK3, PK4, PK5, type) ;


CREATE TABLE JAILER_SET
(
   set_id          INTEGER NOT NULL,
   type            VARCHAR(120) NOT NULL,
   PK0 BIGINT , PK1 VARCHAR(255) , PK2 VARCHAR(255) , PK3 INT , PK4 VARCHAR(255) , PK5 BIGINT 
) ;

CREATE INDEX jlr_pk_set1 ON JAILER_SET (set_id , PK0, PK1, PK2, PK3, PK4, PK5, type) ;


CREATE TABLE JAILER_DEPENDENCY
(
   r_entitygraph   INTEGER NOT NULL,
   assoc           INTEGER NOT NULL,
   depend_id       INTEGER NOT NULL,
   traversed       INTEGER,
   from_type       VARCHAR(120) NOT NULL,
   to_type         VARCHAR(120) NOT NULL,
   FROM_PK0 BIGINT , FROM_PK1 VARCHAR(255) , FROM_PK2 VARCHAR(255) , FROM_PK3 INT , FROM_PK4 VARCHAR(255) , FROM_PK5 BIGINT ,
   TO_PK0 BIGINT , TO_PK1 VARCHAR(255) , TO_PK2 VARCHAR(255) , TO_PK3 INT , TO_PK4 VARCHAR(255) , TO_PK5 BIGINT    

-- ,  CONSTRAINT jlr_fk_graph_d FOREIGN KEY (r_entitygraph) REFERENCES JAILER_GRAPH(id)
) ;

CREATE INDEX jlr_dep_from1 ON JAILER_DEPENDENCY (r_entitygraph, assoc , FROM_PK0, FROM_PK1, FROM_PK2, FROM_PK3, FROM_PK4, FROM_PK5) ;

CREATE INDEX jlr_dep_to1 ON JAILER_DEPENDENCY (r_entitygraph , TO_PK0, TO_PK1, TO_PK2, TO_PK3, TO_PK4, TO_PK5) ;


CREATE TABLE JAILER_TMP 
(
    c1 INTEGER, 
    c2 INTEGER
) ;

INSERT INTO JAILER_CONFIG(jversion, jkey, jvalue) values('3.4.5', 'upk', '679547784');
</code></pre>

<p>Setelah tabelnya siap, jalankan kembali script yang error di atas. Berikut outputnya.</p>

<pre><code>$ ./export-payment-201006.sh 
2010-06-28 14:12:31,175 [main] INFO   - Jailer 3.4.5
2010-06-28 14:12:31,190 [main] INFO   - added 'lib/mysql-connector-java-5.1.6-bin.jar' to classpath
2010-06-28 14:12:31,191 [main] INFO   - exporting 'extractionmodel/payment-201006.csv' to 'payment-201006.sql'
2010-06-28 14:12:32,850 [main] INFO   - SQL dialect is MYSQL
2010-06-28 14:12:32,925 [main] INFO   - gather statistics after 0 inserted rows...
2010-06-28 14:12:32,966 [main] INFO   - reading file 'renew.sql'
2010-06-28 14:12:32,966 [main] INFO   - 0 statements (100%)
2010-06-28 14:12:32,967 [main] INFO   - successfully read file 'renew.sql'
2010-06-28 14:12:32,977 [main] INFO   - exporting payment Where date_format(paid_date,'%Y-%m') = '2010-06'
2010-06-28 14:12:33,028 [main] INFO   - day 1, progress: payment
2010-06-28 14:12:33,039 [main] INFO   - starting 4 jobs
2010-06-28 14:12:33,040 [main] INFO   - gather statistics after 3 inserted rows...
2010-06-28 14:12:33,041 [main] INFO   - reading file 'renew.sql'
2010-06-28 14:12:33,042 [main] INFO   - 0 statements (100%)
2010-06-28 14:12:33,042 [main] INFO   - successfully read file 'renew.sql'
2010-06-28 14:12:33,047 [main] INFO   - resolving payment -&gt; payment_info (inverse-FKE25C3F47AB64A229) 1:n on B.id_payment=A.id...
2010-06-28 14:12:33,105 [main] INFO   - 66 entities found resolving payment -&gt; payment_info (inverse-FKE25C3F47AB64A229) 1:n on B.id_payment=A.id
2010-06-28 14:12:33,105 [main] INFO   - resolving payment -&gt; cetak_ulang (inverse-FK45B985E0AB64A229) 1:n on B.id_payment=A.id...
2010-06-28 14:12:33,126 [main] INFO   - 0 entities found resolving payment -&gt; cetak_ulang (inverse-FK45B985E0AB64A229) 1:n on B.id_payment=A.id
2010-06-28 14:12:33,126 [main] INFO   - resolving payment -&gt; fee_loket (inverse-FK9632AFFEAB64A229) 1:n on B.id_payment=A.id...
2010-06-28 14:12:33,129 [main] INFO   - 3 entities found resolving payment -&gt; fee_loket (inverse-FK9632AFFEAB64A229) 1:n on B.id_payment=A.id
2010-06-28 14:12:33,131 [main] INFO   - resolving payment -&gt; payment_value (inverse-FK69DD09F8AB64A229) 1:n on B.id_payment=A.id...
2010-06-28 14:12:33,142 [main] INFO   - 12 entities found resolving payment -&gt; payment_value (inverse-FK69DD09F8AB64A229) 1:n on B.id_payment=A.id
2010-06-28 14:12:33,143 [main] INFO   - executed 4 jobs
2010-06-28 14:12:33,143 [main] INFO   - day 2, progress: payment_info, fee_loket, payment_value
2010-06-28 14:12:33,144 [main] INFO   - skip reversal association payment_info -&gt; payment
2010-06-28 14:12:33,144 [main] INFO   - skip reversal association fee_loket -&gt; payment
2010-06-28 14:12:33,147 [main] INFO   - skip reversal association payment_value -&gt; payment
2010-06-28 14:12:33,147 [main] INFO   - starting 1 jobs
2010-06-28 14:12:33,148 [main] INFO   - executed 1 jobs
2010-06-28 14:12:33,149 [main] INFO   - exported payment Where date_format(paid_date,'%Y-%m') = '2010-06'
2010-06-28 14:12:33,149 [main] INFO   - total progress: payment_info, payment, fee_loket, payment_value
2010-06-28 14:12:33,149 [main] INFO   - export statistic:
2010-06-28 14:12:33,169 [main] INFO   - Exported Rows:     84
2010-06-28 14:12:33,169 [main] INFO   -     fee_loket                      3
2010-06-28 14:12:33,169 [main] INFO   -     payment                        3
2010-06-28 14:12:33,172 [main] INFO   -     payment_info                   66
2010-06-28 14:12:33,172 [main] INFO   -     payment_value                  12
2010-06-28 14:12:33,173 [main] INFO   - writing file 'payment-201006.sql'...
2010-06-28 14:12:33,178 [main] INFO   - independent tables: payment
2010-06-28 14:12:33,179 [main] INFO   - starting 1 jobs
2010-06-28 14:12:33,380 [main] INFO   - executed 1 jobs
2010-06-28 14:12:33,380 [main] INFO   - independent tables: payment_info, fee_loket, payment_value
2010-06-28 14:12:33,384 [main] INFO   - starting 3 jobs
2010-06-28 14:12:33,447 [main] INFO   - executed 3 jobs
2010-06-28 14:12:33,447 [main] INFO   - cyclic dependencies for: 
2010-06-28 14:12:33,447 [main] INFO   - starting 0 jobs
2010-06-28 14:12:33,448 [main] INFO   - executed 0 jobs
2010-06-28 14:12:33,448 [main] INFO   - gather statistics after 84 inserted rows...
2010-06-28 14:12:33,450 [main] INFO   - reading file 'renew.sql'
2010-06-28 14:12:33,450 [main] INFO   - 0 statements (100%)
2010-06-28 14:12:33,454 [main] INFO   - successfully read file 'renew.sql'
2010-06-28 14:12:33,456 [main] INFO   - starting 0 jobs
2010-06-28 14:12:33,467 [main] INFO   - executed 0 jobs
2010-06-28 14:12:33,486 [main] INFO   - file 'payment-201006.sql' written.
</code></pre>

<p>Selesai sudah, data yang kita inginkan ada di file payment-201006.sql, siap diunduh dan dijalankan di database development.</p>

<p>Semoga bermanfaat, kalau ada yang kurang jelas, silahkan baca <a href="http://jailer.sourceforge.net/exporting-data.htm">tutorial resminya</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/programming/tuning-performance/">Tuning Performance</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-05-05T15:24:18+07:00" pubdate data-updated="true">May 5<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Setelah aplikasi dicoding dengan benar, biasanya langkah berikutnya adalah tuning performance. Hal ini banyak ditanyakan di berbagai milis pemrograman yang saya ikuti. Agar tidak berkali-kali menulis jawaban yang sama, berikut artikel tentang metodologi saya dalam melakukan tuning performance aplikasi.</p>

<h2>0. Miliki tujuan yang jelas</h2>

<p>Misalnya :
Mampu menghandle 100 request/detik dengan response time &lt; 2 detik
dengan 1 juta record di database. Bisa jadi pada tahap ini, ternyata keputusannya adalah tidak perlu tuning, karena performance aplikasi yang sekarang sudah memenuhi keinginan.</p>

<h2>1. Pastikan aplikasinya berjalan benar</h2>

<p>Make it right, then make it fast.
Gak ada gunanya mentuning aplikasi buggy.
Kita juga harus punya perangkat pengetes yang lengkap.
Supaya nanti setelah tuning, bisa dipastikan bahwa tuningnya tidak menimbulkan bug baru.</p>

<h2>2. Pasang monitor di aplikasi</h2>

<p>Misalnya :
- CPU usage
- Memory usage
- Aktifitas harddisk
- Aktifitas database</p>

<p>Di linux, CPU dan Memory usage bisa <a href="http://www.linuxforums.org/articles/using-top-more-efficiently_89.html">dipantau dengan top</a>,
sedangkan aktifitas harddisk dengan <a href="http://royontechnology.blogspot.com/2007/06/using-iostat-for-monitoring-disk.html">iostat</a>.
Di MySQL, aktifitas database bisa dimonitor dengan perintah <a href="http://dev.mysql.com/doc/refman/5.1/en/show-processlist.html">show processlist</a>.</p>

<h2>3. Setelah monitor siap, penyiksaan dimulai</h2>

<p>Berikan load yang tinggi ke aplikasi dengan menggunakan tools penyiksaan seperti misalnya <a href="http://jakarta.apache.org/jmeter/">JMeter</a>.
Tingkatkan terus loadnya sampai response time tidak lagi memenuhi syarat.
Misalnya, pada 30 request/detik, response time menjadi 10 detik.</p>

<h2>4. Cari bottlenecknya</h2>

<p>Amati monitor, aspek mana yang overload.
Apakah CPU, I/O, atau memori.
Perhatikan juga aktifitas database untuk mencari penyebabnya.</p>

<h2>5. Lakukan tuning</h2>

<p>Silahkan dioprek dengan metode trial and error.
Biasanya pada tahap ini saya mencari kolom mana yang perlu diindex,
bagian mana di source code yang perlu diperbaiki,
atau konfigurasi seperti apa yang optimal.</p>

<h2>6. Test lagi</h2>

<p>Setelah dioprek, jalankan lagi tools penyiksaan.
Kalau langkah no #5 benar, biasanya bottlenecknya akan pindah.
Misalnya, tadinya CPU maxed out 100%, setelah tuning jadi santai 10%,
tapi memory usage jadi 80%.</p>

<h2>7. Ulangi langkah #5 dan #6</h2>

<p>Ulangi terus tuning dan test sampai aplikasi memenuhi tujuan yang diset di langkah #0.
Inilah pentingnya langkah #0, supaya kita tahu kapan harus berhenti.</p>

<p>Beberapa hal yang harus diingat dalam tuning performance:</p>

<ol>
<li><p>Tidak ada pil ajaib, masing-masing kasus berbeda. Kadang masalahnya ada di index database, kadang di prosesor, dsb.</p></li>
<li><p>Jangan main tebak-tebakan, semua keputusan harus berdasarkan hasil monitoring. Soalnya seringkali tebakan kita salah.</p></li>
<li><p>Jangan lupakan maintenance source code. Proses tuning mungkin saja akan membuat source code menjadi kompleks dan sulit dibaca. Jangan sampai kita mengorbankan kerapian coding demi sedikit peningkatan performance. Lebih baik upgrade hardware daripada mengotori source code.</p></li>
<li><p>Tahu kapan harus berhenti. Tuning merupakan pekerjaan yang menarik, mirip seperti bermain game. Oleh karena itu penting bagi kita untuk punya tujuan. Begitu tujuan dicapai, segera berhenti. Lebih baik menambah fitur yang memiliki business value daripada terus menerus berkutat dengan performance.</p></li>
</ol>


<p>Demikian sekilas tentang tuning. Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/manajemen/fase-requirement/">Fase Requirement</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-18T04:20:29+07:00" pubdate data-updated="true">Apr 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Dari seluruh fase yang ada di project, fase Requirement Development adalah yang paling penting. Bila kita melakukan kegiatan requirement dengan asal-asalan, akibatnya antara lain :</p>

<ul>
<li><p>aplikasi sudah selesai dibuat, tapi tidak sesuai dengan keinginan user</p></li>
<li><p>pada fase coding, banyak terjadi delay karena ternyata ada requirement yang belum jelas</p></li>
<li><p>pada fase coding, banyak pekerjaan harus diulang karena salah memahami requirement</p></li>
</ul>


<p>Kenapa saya sebut dengan istilah Requirement Development, bukan Requirement Gathering seperti yang umum dipakai orang? Sebabnya adalah karena requirement yang baik itu tidak didapat dengan mudah. Tidak seperti memungut barang di jalanan (gathering), melainkan harus melalui proses yang iteratif (development). Kita tidak bisa mendapatkan requirement yang baik sekali jalan. Kita harus terus menerus melakukan investigasi, klarifikasi, verifikasi, agar requirement yang didapat benar-benar bagus kualitasnya.</p>

<p>Pada artikel ini, kita akan membahas bagaimana cara membuat requirement yang baik.</p>

<p>Sebelum ke masalah teknis, kita lihat dulu, kenapa kita harus melalui fase requirement? Kenapa tidak langsung coding saja? Kan customer ingin aplikasi jadi, bukan notulensi meeting dan setumpuk dokumen?</p>

<h2>Tujuan Requirement</h2>

<p>Kita melakukan requirement development karena kita ingin tahu apa yang ingin dibuat. Setelah mengetahui apa yang ingin dibuat, barulah kita bisa:</p>

<ul>
<li><p>memilih anggota tim yang tepat</p></li>
<li><p>memperkirakan biaya dan waktu yang dibutuhkan untuk membuatnya</p></li>
<li><p>memilih arsitektur dan teknologi yang sesuai</p></li>
</ul>


<p>Jadi, proses requirement membantu kita untuk melakukan project planning.
Selain itu, proses requirement juga membantu kita mencegah project menjadi molor dan merugi. Kalau kita langsung terjun coding, maka akan banyak waktu terbuang untuk melakukan perubahan. Misalnya, kalau kita sudah coding, ternyata user minta tambahan satu field entry, maka kita terpaksa mengubah tampilan, skema database, format report, dokumentasi user (kalau sudah ada), dan mungkin banyak lagi. Tapi kalau perubahan ini dilakukan pada fase requirement, paling effortnya cuma mengubah dummy dan dokumentasi user story saja.</p>

<p>Requirement juga bisa membantu kita mengendalikan perubahan dalam project, seperti kita akan lihat di bagian selanjutnya.</p>

<p>Setelah kita tahu tujuannya, mari kita ke langkah pertama yang paling menentukan.</p>

<h2>Identifikasi Usernya</h2>

<p>Segera setelah project dimulai, kita akan segera dihujani jadwal meeting untuk membahas requirement. Nah di sini kita harus jeli. Mendengarkan user itu penting, tapi yang lebih penting lagi adalah menjawab pertanyaan, siapa usernya?</p>

<p>Ada bermacam-macam jenis user, dan ini menentukan informasi apa yang ingin kita dengarkan, dan informasi mana yang kita abaikan.</p>

<ul>
<li><p>End User. Ini adalah user yang nantinya akan menggunakan aplikasi. Kita harus mendengarkan user ini, terutama dari sisi usability. Apakah aplikasi kita nyaman dipakai, mudah digunakan, indah dilihat, dan sebagainya. Tapi, jangan sekali-kali mengambil keputusan tentang proses bisnis dengan user ini. Jangan juga memutuskan untuk menambah/mengurangi fitur <strong>hanya</strong> berdasarkan pendapat user ini. Kita membutuhkan user selanjutnya, yaitu :</p></li>
<li><p>Sponsor atau Client. Ini adalah orang yang akan membayar invoice untuk pembuatan aplikasi. Semua keputusan penting (proses bisnis dan list fitur adalah penting) harus disetujui Client. Dan jangan salah, seringkali pendapat End User tidak sama dengan pendapat Client. Misalnya, Client menginginkan suatu transaksi harus melalui approval supervisor, manager, dan direktur secara berjenjang. Tapi tentunya fitur ini akan memberatkan End User, karena ada banyak proses yang harus dilalui. Nah, tentunya Anda tahu siapa yang harus kita dengarkan. Nah, jadi kapan-kapan melakukan requirement development, cari tahu dulu siapa yang mengotorisasi bilyet giro :D</p></li>
<li><p>Konsultan Internal. Seringkali di organisasi client, ada seseorang yang cukup senior dari sisi teknis. Bisa jadi dia adalah divisi IT di organisasi client, atau orang luar yang dipercaya oleh client. Apakah orang ini harus kita dengarkan pendapatnya? Tergantung dari seberapa besar pengaruhnya terhadap client. Kita bisa mengetes pengaruhnya dengan membuat satu fitur yang tidak sesuai dengan pendapat konsultan internal ini, dan lihat apa reaksi client. Kalau client setuju dengan kita, berarti pengaruhnya tidak besar, dan pendapat selanjutnya bisa kita diabaikan.</p></li>
<li><p>Customer. Ada kalanya Client membeli aplikasi kita untuk dijual lagi ke orang lain. Nah orang lain ini disebut Customer. Sukses atau tidaknya project kita banyak ditentukan oleh berapa customer yang bisa didapatkan client. Jadi, penting juga untuk kita mengetahui profil customer (kalau ada). Apa business objective dari customer, sehingga bisa kita akomodasi dengan baik</p></li>
</ul>


<p>Baiklah, saya sudah memetakan, si A adalah End User, si B Client, si C konsultan internal, dan si D adalah customernya. Apakah sekarang sudah bisa kita mulai interviewnya? Ok ok .. mari kita suruh Business Analyst (BA) untuk melakukan tugasnya. Oh, tunggu dulu, BA belum direkrut? Bagaimana kualifikasinya?</p>

<h2>Kualifikasi Business Analyst</h2>

<p>Pertama, BA harus menguasai proses bisnis. Kalau kita ingin membuat aplikasi akunting, BAnya harus mengerti akuntansi. Aturan sederhana dan logis, tapi masih banyak saja perusahaan yang mengirim programmer untuk melakukan requirement development.</p>

<p>Secara umum, BA harus sudah punya pengetahuan dasar dulu sebelum dia ketemu client. Kalau kita kirim programmer, maka dia bukan melakukan requirement development, tapi dia akan belajar bisnis proses ke client. Seperti kita akan lihat, ini pasti akan menimbulkan delay, karena :</p>

<blockquote><p>Seorang BA harus bisa membedakan mana proses bisnis yang fundamental dan jarang berubah (karenanya boleh dihardcode), mana yang kondisional dan sering berubah (sehingga harus configurable)</p></blockquote>

<p>Programmer yang belajar bisnis proses ke client tidak akan bisa membedakan ini. Sebagai contoh, mari kita lihat prosedur procurement.</p>

<p>Proses bisnis fundamentalnya adalah, ada pengajuan (purchase request), kemudian dilanjutkan dengan minta quotation ke vendor (request for quotation), memilih vendor, baru melakukan pemesanan (purchase order).
Ini adalah flow fundamental, dan boleh di-hardcode.</p>

<p>Kemudian end user akan bilang, purchase request akan dilakukan oleh masing-masing dept, approval dilakukan manager, dst, dst. Siapa yang mengentri, siapa yang mengapprove, dan pada nilai transaksi berapa dia boleh approve, ini adalah kondisional dan harus bisa dikonfigurasi.</p>

<p>Nah, seorang BA yang baik harus bisa membedakan kedua hal ini.</p>

<p>Coba temani BA anda pada saat sesi interview dengan end user. Kalau dia pernah bilang begini,</p>

<blockquote><p>Oh, di perusahaan Anda prosesnya begini ya? Biasanya yang umum dilakukan orang adalah seperti ini. Proses Anda kurang optimal karena blablabla. Apakah proses Anda mau berubah, atau aplikasi yang ingin ikut proses Anda dengan konsekuensi ABC?</p></blockquote>

<p>Nah, kapan-kapan dia minta naik gaji, jangan buru-buru ditolak. Ini BA bagus. Dia menguasai bidangnya, dan tahu best practices.</p>

<p>Banyak perusahaan yang ingin bikin produk dari project tapi tidak kunjung berhasil. Misalnya, ada client minta dibuatkan aplikasi gudang, trus manajemen mikir, &#8220;Wah kayaknya ini kalo dibikin jadi produk bakalan prospek&#8221;. Tapi ternyata setelah project selesai, aplikasinya tidak applicable di perusahaan lain. Ini salah satu sebabnya adalah BA yang kurang pengalaman sehingga tidak tahu mana fitur yang generik berlaku umum dan mana yang spesifik hanya untuk perusahaan tertentu saja.</p>

<p>Tahu bisnis proses saja masih kurang, BA yang baik juga paham usability. Seperti kita tahu, ada banyak cara untuk mengentri transaksi. Bisa dientri via screen, bisa upload file, bisa via HP, bisa import dari aplikasi lain, dsb. BA yang baik bisa memberikan rekomendasi pada programmer mengenai user experience. Bagaimana urutan screen, penempatan komponen, apakah pilihan tertentu disajikan dengan dropdown, radio, atau lookup.</p>

<p>Kalau BAnya tidak paham usability, aplikasi kita akan benar secara proses bisnis, tapi tidak enak digunakan. Programmer tidak bisa menentukan usability, karena dia tidak tahu bagaimana biasanya end-user menggunakan fitur tertentu.</p>

<p>Ok, BA saya sudah canggih, paham bisnis proses, tau best practices, dan pernah magang sama <a href="http://www.useit.com">Jakob Nielsen</a>. Bisa kita mulai interview user?</p>

<h2>Interview User</h2>

<p>Pada fase ini, biarkan saja BA menjalankan tugasnya. Dia akan berbicara dengan user, dan menanyakan hal-hal berikut:</p>

<ul>
<li><p>Flow global dari awal sampai akhir. Untuk aplikasi procurement, berarti dari request pembelian, sampai barang diterima.</p></li>
<li><p>Flow detail untuk masing-masing tahap. Contohnya, bagaimana detail flow proses request pembelian</p></li>
<li><p>Variasi skenario. Di sini BA akan mengidentifikasi percabangan dari tiap flow. Apa saja variasi skenarionya, perbedaan datanya, role user yang mengaksesnya, kondisi outputnya, dan sebagainya.</p></li>
</ul>


<p>Jangan lupa untuk meminta :</p>

<ul>
<li><p>Contoh report yang diinginkan</p></li>
<li><p>Sampel data transaksi untuk kita test di internal</p></li>
<li><p>Rumus atau formula perhitungan</p></li>
</ul>


<p>Tergantung clientnya, ada kemungkinan dia akan meminta perjanjian kerahasiaan sebelum mengeluarkan data-data di atas.</p>

<p>Setelah interview, BA pulang ke kantor, dan akan membuat dokumentasi requirement.</p>

<h2>Dokumentasi Requirement</h2>

<p>Untuk apa kita membuat dokumentasi? Tujuannya adalah</p>

<ul>
<li><p>Untuk mengidentifikasi kalau ada hal yang kurang jelas, sehingga bisa langsung ditanyakan</p></li>
<li><p>Sebagai bahan untuk verifikasi dengan user, apakah pemahaman kita sudah sama dengan yang dimaksud user.</p></li>
<li><p>Sebagai pedoman untuk programmer</p></li>
<li><p>Untuk mencegah project molor</p></li>
</ul>


<p>Lho, bagaimana bisa dokumen requirement mencegah project molor? Ya bisa saja, berikut alasannya</p>

<ul>
<li><p>Kalau ada kesalahan dan ditemukan pada fase ini, biaya perbaikannya jauh lebih kecil daripada kalau ditemukan pada fase coding. Misalnya ada kesalahan rumus perhitungan. Kalau kesalahan ini ditemukan pada fase requirement, paling biayanya cuma mengedit user story. Tapi kalau ditemukan pada waktu UAT, bisa-bisa butuh 2-3 hari untuk fixingnya. Ini <a href="http://www.stevemcconnell.com/articles/art08.htm">katanya Steve McConnell</a>, bukan bikin-bikinan saya.</p></li>
<li><p>Setelah requirement disign off, semua perubahan harus melalui change procedure. Ini mencegah project molor karena user terus menerus berubah pikiran. Sekarang maunya A, besok B, lusa ganti lagi.</p></li>
</ul>


<p>Lalu, apa saja yang harus didokumentasikan? Daripada panjang lebar, silahkan lihat <a href="http://software.endy.muhardin.com/downloads/user-story.odt">template User Story ArtiVisi</a>. Di situ sudah kita siapkan form isian apa saja yang harus dicantumkan.</p>

<p>Coba lihat dulu, supaya nyambung dengan pembahasan di bawah.</p>

<blockquote><p>Lho kenapa ada flow pengetesan? Apa bedanya dengan test scenario?</p></blockquote>

<p>Sama saja, yang kita maksud flow pengetesan memang adalah test scenario. Lalu apakah wajib dibuat pada fase requirement? Kami sangat menganjurkan untuk membuatnya, dengan alasan sebagai berikut:</p>

<ul>
<li><p>Dengan memikirkan bagaimana nanti pengetesannya, kualitas user story akan meningkat. BA terpaksa memikirkan step-by-step bagaimana aplikasi akan digunakan, apa inputnya, dan apa outputnya. Dengan memikirkan ini, semua variasi dan kebutuhan input, dan ekspektasi output mau tidak mau akan terpikirkan dan teridentifikasi sejak dini. Ini akan mengurangi requirement yang ambigu, tidak lengkap, atau tidak mungkin diimplementasikan</p></li>
<li><p>Test scenario yang ditandatangani user merupakan exit strategy bagi vendor. Kalau client sudah setuju dengan skenario testnya, maka vendor cukup membuat aplikasi yang lulus test tersebut. Setelah lulus test, jangan ditambah-tambahi lagi. Ini akan mencegah programmer menambah fitur-fitur menarik namun tidak memiliki business value.</p></li>
</ul>


<p>Seperti bisa dilihat pada template, kita mengharuskan adanya screen prototype di dokumen requirement. Screen ini dirancang oleh BA (makanya dia harus paham usability), dan kalau mau, bisa dibuatkan dummy-nya. Dummy bisa dibuat dengan apapun teknologi yang murah dan cepat. Begitu desain screen jadi, seharusnya tidak lebih dari 2 jam waktu yang dibutuhkan untuk membuat dummy-nya, bahkan untuk screen kompleks sekalipun.</p>

<p>Yang harus ada di desain screen adalah :</p>

<ul>
<li><p>Input field, harus jelas komponennya, apakah text, radio, dsb</p></li>
<li><p>Contoh isian. Jangan membuat input kosong, buatlah seolah-olah sudah diisi user. Ini akan memudahkan pada saat presentasi</p></li>
<li><p>Contoh output. Demikian juga dengan output hasil query, report, dsb. Jangan tampilkan tabel kosong. Isilah dengan data statis barang beberapa baris, agar user mempunyai gambaran bagaimana hasil akhirnya</p></li>
</ul>


<p>Tidak perlu repot-repot mengimplementasikan dummy ini. Semuanya adalah data statis yang langsung diketik apa adanya.</p>

<p>Dokumen user story dan dummy dipresentasikan ke end user dan direvisi sesuai input. Pada fase ini, end user bebas membuat perubahan apapun yang diinginkan. Perubahan bebas untuk diakomodasi, asal jangan pernah melupakan siapa yang tandatangan otorisasi bilyet giro :D</p>

<h2>Sign Off</h2>

<p>Setelah semua user story diiterasi dengan end user sampai puas, maka tiba saatnya untuk melakukan feature-freeze. Semua dokumentasi requirement diupdate sehingga sesuai kondisi terakhir, lalu minta approval tertulis dari client. Ingatlah selalu, <strong>approval client, bukan end-user, bukan konsultan internal</strong>. Ini adalah aktivitas paling critical dan harus dilakukan. Segala usaha proses requirement akan percuma tanpa sign off client.</p>

<h2>Change Management</h2>

<p>Sebelum sign off, end user bebas mengajukan perubahan apapun. Setelah sign off, semua perubahan harus melalui change procedure. Intinya adalah, perubahan diajukan secara tertulis, diestimasi penambahan durasi dan costnya, lalu diajukan ke manajemen, baik vendor maupun client. Kalau salah satu pihak tidak setuju, maka perubahan tidak akan dijalankan.</p>

<p><img src="/images/uploads/2010/02/change-procedure_id-724x1024.png" title="Prosedur Change Management" ></p>

<p>Lebih jelas tentang informasi apa saja yang dibahas di change management, bisa melihat <a href="http://software.endy.muhardin.com/downloads/change-request.odt">template change request ArtiVisi</a>.</p>

<p>Seperti kita lihat, di sini faktor sign off sangat berperan. Tanpa ada sign off, tidak ada batas kapan user bisa berubah seenaknya, dan kapan tidak boleh.</p>

<p>Kalau change management dijalankan dengan baik, project akan lebih terkontrol. Walaupun ada kemunduran, kedua belah pihak sadar apa sebabnya. Semua perubahan diketahui manajemen, sehingga tidak ada bos yang tiba-tiba muncul dan bilang</p>

<blockquote><p>Ini project kenapa gak beres-beres?</p></blockquote>

<p>Kunci sukses change management adalah mulai dari awal, dan perhatikan hal kecil. Kita sebagai vendor sering mengabaikan prosedur ini dengan berbagai alasan, diantaranya</p>

<ul>
<li><p>Ah perubahannya terlalu kecil, kalo langsung diimplement cuma 5 menit, tapi kalo change procedure bisa 2 hari.</p></li>
<li><p>Kita tidak mau terlihat birokratis seperti pegawai kelurahan perpanjang KTP</p></li>
<li><p>Kita berbaik hati pada client, masa perubahan sedikit saja hitung-hitungan banget</p></li>
</ul>


<p>Ini merupakan kesalahan besar. Dengan memberlakukan change procedure bahkan untuk hal kecil, kita akan menimbulkan kesadaran di client bahwa kita mengelola project dengan ketat. Dengan demikian, mereka tidak sembarangan meminta perubahan. Client juga akan menyadari bahwa perubahan kecil saja akan berdampak pada keseluruhan project.</p>

<p>Kalau kita memang ingin berbaik hati pada client, silahkan digratiskan. Tapi prosedur tetap dijalankan. Jadi kalo tiba-tiba ada bos client yang tanya seperti di atas, tinggal kita sodori binder berisi daftar change request yang sudah diapprove.</p>

<p>Change procedure juga ada bonusnya, yaitu tidak banyak mengganggu programmer. Estimasi dan approval mostly dilakukan oleh business analyst dan project manager. Dan belum tentu juga client setuju. Kita akan menghemat banyak waktu, konsentrasi, dan pikiran programmer yang tidak perlu memikirkan usulan perubahan yang ternyata tidak disetujui.</p>

<p>Di change request juga ada timing kapan change akan diberlakukan. Untuk menjaga konsentrasi dan ritme tim, PM bisa menggunakan opsi ini untuk menunda change ke iterasi selanjutnya.</p>

<h2>Requirement Traceability</h2>

<p>Yang satu ini titipan dari CMMI. Di process area Requirement Management, CMMI mengharuskan adanya <em>bidirectional traceability</em>. Artinya, setiap hal di requirement harus bisa ditelusuri dokumen desain mana yang membahasnya, baris kode mana yang mengimplementasikannya, test scenario mana yang memverifikasinya. Demikian juga sebaliknya (makanya disebut bidirectional), setiap baris kode, harus bisa ditelusuri requirement mana yang membutuhkannya.</p>

<p>Ini ide yang bagus. Dengan melaksanakan ini, kita memastikan bahwa effort coding kita benar-benar efisien. Tidak ada effort terbuang percuma untuk fitur-fitur yang tidak perlu. Demikian juga sebaliknya, kita memastikan bahwa semua requirement sudah diimplementasikan dan tidak ada yang ketinggalan.</p>

<p>Walaupun demikian, ide bagus belum tentu realistis di lapangan. Saat ini di ArtiVisi, kita baru bisa merelasikan antara baris kode dengan requirement dengan menggunakan Trac. Tapi tidak untuk dokumen lainnya seperti user manual, test scenario, dsb. Dan itupun tidak bidirectional.</p>

<p>Kalau ingin tahu bagaimana ini diimplementasikan, silahkan lihat <a href="http://sourceforge.net/projects/osrmt/">aplikasi ini</a>.</p>

<p>Oh iya, kalau kita sudah melakukan semua anjuran di artikel ini, lengkap dengan Requirement Traceability, kita sudah siap untuk diaudit untuk proses area Requirement Management (Maturity Level 2) dan Requirement Development (Maturity Level 3) :D</p>

<p>Demikian penjelasan tentang fase requirement. Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/9/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
    <a class="next" href="/page/7/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Endy Muhardin</h1>

<p>Software Developer berdomisili di Jabodetabek, berkutat di lingkungan open source, terutama Java dan Linux.</p>

<p>
    <ul>
        <li>
            <span class="icon-phone" style="text-align: left; width: 100%">&nbsp;
            +62 812 98000 468
            </span>
        </li>
        <li>
            <span class="icon-envelope" style="text-align: left; width: 100%">&nbsp;
                <a href="mailto:endy.muhardin@gmail.com">endy.muhardin@gmail.com</a>
            </span>
        </li>
        <li>
            <span class="icon-twitter" style="text-align: left; width: 100%">&nbsp;
                <a href="http://twitter.com/endymuhardin">@endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-github" style="text-align: left; width: 100%">&nbsp;
                <a href="https://github.com/endymuhardin">github.com/endymuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-facebook" style="text-align: left; width: 100%">&nbsp;
                <a href="http://facebook.com/endy.muhardin">facebook.com/endy.muhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-google-plus" style="text-align: left; width: 100%">&nbsp;
                <a href="http://google.com/+EndyMuhardin">google.com/+EndyMuhardin</a>
            </span>
        </li>
        <li>
            <span class="icon-linkedin" style="text-align: left; width: 100%">&nbsp;
                <a href="http://id.linkedin.com/pub/endy-muhardin/3/940/1bb">LinkedIn</a>
            </span>
        </li>
    </ul>
</p>
</section>

<section>

Bila artikel di website ini membantu meningkatkan penghasilan Anda, 
jangan ragu untuk memberikan donasi :)

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYByjmBHWB1u9oWkn33FHJ7Lu41iidZkdKLciblvSz2Oa/oBArw42F4/7nq3imMAWUvpA6Cx9zwNr3R7WqjnMlDr91VTkeyl1jusRB6Knw/JAaNI2yz20lbFtVNMhUrh2LJ6qXUwvdL4jvZeNUeOcvq/muETfy8BzgdKwCF3gNGpoTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQId7q7vUD8KwOAgaAyBdpVvmsdYWgKdVROwaJazFrOpQpWEncNGoycnyfeJRNwHXXZU1mj0oTJuvj/CUGr6cZC5RnQNBHC6FLnbjCVheTNtjBSs/CjD7HZMn28kElykLad2wDrFUsBkQCdRU43ZBLoRedRKbGVWP4wk6DgLovkwPzYNLKtl3clJbgm3UDXigmJqeAyvmafF2yk8LV4ACLTJtCu6qtSBVHkuUPToIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTMwNzExMDY0MjAwWjAjBgkqhkiG9w0BCQQxFgQUwzp1u86AW3VypUoSwjzfYA4KYn8wDQYJKoZIhvcNAQEBBQAEgYBExEV1zgHTrd+4zfXwIP0KO0/W7b4s2KDLbZ3Vq9FrtdtC9W3NEf6SbVZDYE+bEheP10XokfC8BslN7nZgsfPTvSNXv7ixfpWUVBb/gQB+QO70q1NZ2tuF2M/t1QzFUEZ9FeA0sgFMBS7nxmu7ynaSzez3B4FTG/jUzuRljVWhew==-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
</form>

</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/manajemen/capacity-planning/">Capacity Planning</a>
      </li>
    
      <li class="post">
        <a href="/java/memahami-authentication/">Memahami Authentication</a>
      </li>
    
      <li class="post">
        <a href="/java/desain-skema-database/">Desain Skema Database</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/tahapan-membuat-aplikasi/">Tahapan Membuat Aplikasi</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/aplikasi-prakarya-vs-aplikasi-production/">Aplikasi Prakarya vs Aplikasi Production</a>
      </li>
    
      <li class="post">
        <a href="/java/membuat-subreport-jasper-dalam-springmvc/">Membuat subreport Jasper dalam SpringMVC</a>
      </li>
    
      <li class="post">
        <a href="/linux/cara-mengetahui-ip-address-dari-mac-address/">Cara Mengetahui IP Address dari MAC Address</a>
      </li>
    
      <li class="post">
        <a href="/life/menjadi-mahasiswa-hi-tech/">Menjadi Mahasiswa Hi-Tech</a>
      </li>
    
      <li class="post">
        <a href="/java/silabus-kuliah-pemrograman/">Silabus Kuliah Pemrograman</a>
      </li>
    
      <li class="post">
        <a href="/javascript/javascript-development-stack/">JavaScript Development Stack</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
